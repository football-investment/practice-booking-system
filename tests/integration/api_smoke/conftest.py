"""
Auto-generated API smoke tests configuration
Generated by tools/generate_api_tests.py

Phase 1 Enhancement: Real test data fixtures for path parameter resolution
"""

import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional

from app.main import app
from app.database import get_db
from app.models.user import User, UserRole
from app.models.semester import Semester
from app.models.campus import Campus
from app.models.location import Location
from app.core.security import get_password_hash


@pytest.fixture(scope="module")
def api_client():
    """FastAPI test client"""
    return TestClient(app)


@pytest.fixture(scope="module")
def test_db():
    """Database session for test setup"""
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()


@pytest.fixture(scope="module")
def admin_token(test_db: Session):
    """Admin user authentication token"""
    # Check if admin exists
    admin = test_db.query(User).filter(User.email == "smoke.admin@generated.test").first()

    if not admin:
        admin = User(
            name="Smoke Test Admin",
            email="smoke.admin@generated.test",
            password_hash=get_password_hash("admin123"),
            role=UserRole.ADMIN,
            is_active=True
        )
        test_db.add(admin)
        test_db.commit()
        test_db.refresh(admin)

    # Generate token
    from app.core.auth import create_access_token
    token = create_access_token(data={"sub": admin.email}, expires_delta=timedelta(hours=1))
    return token


@pytest.fixture(scope="module")
def student_token(test_db: Session):
    """Student user authentication token"""
    student = test_db.query(User).filter(User.email == "smoke.student@generated.test").first()

    if not student:
        student = User(
            name="Smoke Test Student",
            email="smoke.student@generated.test",
            password_hash=get_password_hash("student123"),
            role=UserRole.STUDENT,
            is_active=True
        )
        test_db.add(student)
        test_db.commit()
        test_db.refresh(student)

    from app.core.auth import create_access_token
    token = create_access_token(data={"sub": student.email}, expires_delta=timedelta(hours=1))
    return token


@pytest.fixture(scope="module")
def instructor_token(test_db: Session):
    """Instructor user authentication token"""
    instructor = test_db.query(User).filter(User.email == "smoke.instructor@generated.test").first()

    if not instructor:
        instructor = User(
            name="Smoke Test Instructor",
            email="smoke.instructor@generated.test",
            password_hash=get_password_hash("instructor123"),
            role=UserRole.INSTRUCTOR,
            is_active=True
        )
        test_db.add(instructor)
        test_db.commit()
        test_db.refresh(instructor)

    from app.core.auth import create_access_token
    token = create_access_token(data={"sub": instructor.email}, expires_delta=timedelta(hours=1))
    return token


@pytest.fixture(scope="module")
def test_campus_id(test_db: Session) -> int:
    """
    Get or create a test campus for tournament session generation.

    Returns:
        Campus ID (int)
    """
    # Query existing campuses
    existing_campus = test_db.query(Campus).filter(Campus.is_active == True).first()

    if existing_campus:
        return existing_campus.id

    # Create test location if none exist
    location = test_db.query(Location).filter(Location.is_active == True).first()
    if not location:
        location = Location(
            name="Smoke Test Location",
            city="Budapest",
            is_active=True
        )
        test_db.add(location)
        test_db.commit()
        test_db.refresh(location)

    # Create test campus
    campus = Campus(
        name="Smoke Test Campus",
        location_id=location.id,
        address="Test Address 123",
        is_active=True
    )
    test_db.add(campus)
    test_db.commit()
    test_db.refresh(campus)

    return campus.id


@pytest.fixture(scope="module")
def test_tournament(test_db: Session, test_campus_id: int, student_token: str) -> Dict:
    """
    P2.1: Minimál Lifecycle Graph - State-driven test architecture.

    Creates a complete tournament with minimal viable state:
    - Tournament entity (Semester)
    - Campus schedule config
    - Reward config
    - 2 Students with PLAYER licenses
    - 2 Enrollments (APPROVED, is_active=True)
    - 1 Session (tournament_round=1)

    Note: MatchStructure/MatchResult not included (tables don't exist in DB).

    Returns:
        {
            "tournament_id": int,
            "semester_id": int,
            "code": str,
            "name": str,
            "session_ids": List[int],
            "enrolled_student_ids": List[int],
            "has_reward_config": bool,
            "has_campus_schedule": bool,
            "has_sessions": bool,
            "has_enrollments": bool
        }
    """
    from app.models.campus_schedule_config import CampusScheduleConfig
    from app.models.tournament_reward_config import TournamentRewardConfig
    from app.models.license import UserLicense
    from app.models.semester_enrollment import SemesterEnrollment, EnrollmentStatus
    from app.models.session import Session as SessionModel

    timestamp = int(datetime.now(timezone.utc).timestamp())

    # Create tournament (game_preset_id moved to GameConfiguration in P3)
    # P3.2: Default status DRAFT (neutral state, allows status transitions)
    tournament = Semester(
        code=f"SMOKE_TEST_{timestamp}",
        name=f"Smoke Test Tournament {timestamp}",
        start_date=datetime.now(timezone.utc).date(),
        end_date=(datetime.now(timezone.utc) + timedelta(days=30)).date(),
        tournament_status="DRAFT",
        enrollment_cost=0,
        age_group="PRO",
        campus_id=test_campus_id,
        is_active=True
    )
    test_db.add(tournament)
    test_db.commit()
    test_db.refresh(tournament)

    # Add campus schedule config (minimal valid configuration)
    campus_schedule = CampusScheduleConfig(
        tournament_id=tournament.id,
        campus_id=test_campus_id,
        match_duration_minutes=90,
        break_duration_minutes=15,
        parallel_fields=1,
        is_active=True
    )
    test_db.add(campus_schedule)

    # Add reward config (minimal valid configuration)
    reward_config = TournamentRewardConfig(
        semester_id=tournament.id,
        reward_policy_name="smoke_test_policy"
    )
    test_db.add(reward_config)

    test_db.commit()

    # ── 4. Create 2 Students with PLAYER Licenses ──────────────────────
    # Get student 1 (created by student_token fixture)
    student1 = test_db.query(User).filter(User.email == "smoke.student@generated.test").first()

    # Create student 2
    student2_email = f"smoke.student2.{timestamp}@generated.test"
    student2 = test_db.query(User).filter(User.email == student2_email).first()
    if not student2:
        student2 = User(
            name="Smoke Test Student 2",
            email=student2_email,
            password_hash=get_password_hash("student123"),
            role=UserRole.STUDENT,
            is_active=True,
            credit_balance=1000
        )
        test_db.add(student2)
        test_db.commit()
        test_db.refresh(student2)

    # Create UserLicense + Enrollment for both students
    enrolled_student_ids = []
    for student in [student1, student2]:
        # Check if PLAYER license exists
        user_license = test_db.query(UserLicense).filter(
            UserLicense.user_id == student.id,
            UserLicense.specialization_type == "PLAYER"
        ).first()

        if not user_license:
            user_license = UserLicense(
                user_id=student.id,
                specialization_type="PLAYER",
                current_level=1,
                max_achieved_level=1,
                started_at=datetime.now(timezone.utc),
                is_active=True
            )
            test_db.add(user_license)
            test_db.commit()
            test_db.refresh(user_license)

        # ── 5. Create Enrollment (APPROVED, is_active=True) ────────────
        enrollment = SemesterEnrollment(
            user_id=student.id,
            semester_id=tournament.id,
            user_license_id=user_license.id,
            request_status=EnrollmentStatus.APPROVED,
            is_active=True,
            requested_at=datetime.now(timezone.utc),
            approved_at=datetime.now(timezone.utc),
            enrolled_at=datetime.now(timezone.utc),
            age_category="PRO"
        )
        test_db.add(enrollment)
        enrolled_student_ids.append(student.id)

    test_db.commit()

    # ── 6. Create 1 Session ─────────────────────────────────────────────
    session_start = datetime.now(timezone.utc) + timedelta(days=1)
    session_end = session_start + timedelta(hours=2)

    session = SessionModel(
        title=f"Smoke Test Session - Round 1",
        description="Minimal lifecycle graph session",
        date_start=session_start,
        date_end=session_end,
        semester_id=tournament.id,
        campus_id=test_campus_id,
        tournament_round=1,
        tournament_match_number=1,
        session_status="scheduled",
        capacity=16
    )
    test_db.add(session)
    test_db.commit()
    test_db.refresh(session)

    return {
        "tournament_id": tournament.id,
        "semester_id": tournament.id,
        "code": tournament.code,
        "name": tournament.name,
        "session_ids": [session.id],
        "enrolled_student_ids": enrolled_student_ids,
        "has_reward_config": True,
        "has_campus_schedule": True,
        "has_sessions": True,
        "has_enrollments": True
    }


@pytest.fixture(scope="module")
def test_student_id(test_db: Session) -> int:
    """
    Get smoke test student user ID for badge/user endpoints.

    Returns:
        User ID (int)
    """
    student = test_db.query(User).filter(User.email == "smoke.student@generated.test").first()
    assert student, "Smoke test student not found - ensure student_token fixture is called first"
    return student.id


@pytest.fixture(scope="module")
def test_instructor_id(test_db: Session, instructor_token: str) -> int:
    """
    Get smoke test instructor user ID for instructor endpoints.

    Explicit dependency: instructor_token fixture creates the instructor user.

    Returns:
        User ID (int)
    """
    instructor = test_db.query(User).filter(User.email == "smoke.instructor@generated.test").first()
    assert instructor, "Smoke test instructor not found after instructor_token fixture"
    return instructor.id


@pytest.fixture(scope="module")
def test_session_id(test_tournament: Dict) -> int:
    """
    P3.1: Extract session ID from P2 lifecycle graph (surgical fix).

    Returns first session ID from test_tournament fixture.
    NO new entities created - pure extraction from existing P2 state.

    Returns:
        Session ID (int)
    """
    assert test_tournament["has_sessions"], "Tournament fixture has no sessions"
    assert len(test_tournament["session_ids"]) > 0, "Tournament fixture session_ids is empty"
    return test_tournament["session_ids"][0]


@pytest.fixture(scope="module")
def payload_factory():
    """
    Phase 1: Payload factory for generating schema-compliant request payloads.

    Eliminates 422 validation errors by generating minimally valid payloads
    based on OpenAPI schema definitions.
    """
    from tests.integration.api_smoke.payload_factory import PayloadFactory

    # Get OpenAPI schema
    openapi_schema = app.openapi()

    # Create and return factory instance
    return PayloadFactory(openapi_schema)

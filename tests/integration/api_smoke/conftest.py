"""
Auto-generated API smoke tests configuration
Generated by tools/generate_api_tests.py

Phase 1 Enhancement: Real test data fixtures for path parameter resolution
"""

import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional

from app.main import app
from app.database import get_db
from app.models.user import User, UserRole
from app.models.semester import Semester
from app.models.campus import Campus
from app.models.location import Location
from app.core.security import get_password_hash


@pytest.fixture(scope="module")
def api_client():
    """FastAPI test client"""
    return TestClient(app)


@pytest.fixture(scope="module")
def test_db():
    """Database session for test setup"""
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()


@pytest.fixture(scope="module")
def admin_token(test_db: Session):
    """Admin user authentication token"""
    # Check if admin exists
    admin = test_db.query(User).filter(User.email == "smoke.admin@generated.test").first()

    if not admin:
        admin = User(
            name="Smoke Test Admin",
            email="smoke.admin@generated.test",
            password_hash=get_password_hash("admin123"),
            role=UserRole.ADMIN,
            is_active=True
        )
        test_db.add(admin)
        test_db.commit()
        test_db.refresh(admin)

    # Generate token
    from app.core.auth import create_access_token
    token = create_access_token(data={"sub": admin.email}, expires_delta=timedelta(hours=1))
    return token


@pytest.fixture(scope="module")
def student_token(test_db: Session):
    """Student user authentication token"""
    student = test_db.query(User).filter(User.email == "smoke.student@generated.test").first()

    if not student:
        student = User(
            name="Smoke Test Student",
            email="smoke.student@generated.test",
            password_hash=get_password_hash("student123"),
            role=UserRole.STUDENT,
            is_active=True
        )
        test_db.add(student)
        test_db.commit()
        test_db.refresh(student)

    from app.core.auth import create_access_token
    token = create_access_token(data={"sub": student.email}, expires_delta=timedelta(hours=1))
    return token


@pytest.fixture(scope="module")
def instructor_token(test_db: Session):
    """Instructor user authentication token"""
    instructor = test_db.query(User).filter(User.email == "smoke.instructor@generated.test").first()

    if not instructor:
        instructor = User(
            name="Smoke Test Instructor",
            email="smoke.instructor@generated.test",
            password_hash=get_password_hash("instructor123"),
            role=UserRole.INSTRUCTOR,
            is_active=True
        )
        test_db.add(instructor)
        test_db.commit()
        test_db.refresh(instructor)

    from app.core.auth import create_access_token
    token = create_access_token(data={"sub": instructor.email}, expires_delta=timedelta(hours=1))
    return token


@pytest.fixture(scope="module")
def test_campus_id(test_db: Session) -> int:
    """
    Get or create a test campus for tournament session generation.

    Returns:
        Campus ID (int)
    """
    # Query existing campuses
    existing_campus = test_db.query(Campus).filter(Campus.is_active == True).first()

    if existing_campus:
        return existing_campus.id

    # Create test location if none exist
    location = test_db.query(Location).filter(Location.is_active == True).first()
    if not location:
        location = Location(
            name="Smoke Test Location",
            city="Budapest",
            is_active=True
        )
        test_db.add(location)
        test_db.commit()
        test_db.refresh(location)

    # Create test campus
    campus = Campus(
        name="Smoke Test Campus",
        location_id=location.id,
        address="Test Address 123",
        is_active=True
    )
    test_db.add(campus)
    test_db.commit()
    test_db.refresh(campus)

    return campus.id


@pytest.fixture(scope="module")
def test_tournament(test_db: Session, test_campus_id: int) -> Dict:
    """
    Create a test tournament directly in database (no OPS scenario).

    Returns:
        {
            "tournament_id": int,
            "semester_id": int,  # Same as tournament_id (Semester = Tournament)
            "code": str,
            "name": str
        }
    """
    # Create tournament directly in database
    timestamp = int(datetime.now(timezone.utc).timestamp())
    tournament = Semester(
        code=f"SMOKE_TEST_{timestamp}",
        name=f"Smoke Test Tournament {timestamp}",
        start_date=datetime.now(timezone.utc).date(),
        end_date=(datetime.now(timezone.utc) + timedelta(days=30)).date(),
        tournament_status="IN_PROGRESS",
        enrollment_cost=0,
        age_group="PRO",
        campus_id=test_campus_id,
        is_active=True
    )

    test_db.add(tournament)
    test_db.commit()
    test_db.refresh(tournament)

    return {
        "tournament_id": tournament.id,
        "semester_id": tournament.id,  # Same ID (Semester = Tournament)
        "code": tournament.code,
        "name": tournament.name
    }


@pytest.fixture(scope="module")
def test_student_id(test_db: Session) -> int:
    """
    Get smoke test student user ID for badge/user endpoints.

    Returns:
        User ID (int)
    """
    student = test_db.query(User).filter(User.email == "smoke.student@generated.test").first()
    assert student, "Smoke test student not found - ensure student_token fixture is called first"
    return student.id


@pytest.fixture(scope="module")
def test_instructor_id(test_db: Session) -> int:
    """
    Get smoke test instructor user ID for instructor endpoints.

    Returns:
        User ID (int)
    """
    instructor = test_db.query(User).filter(User.email == "smoke.instructor@generated.test").first()
    assert instructor, "Smoke test instructor not found - ensure instructor_token fixture is called first"
    return instructor.id

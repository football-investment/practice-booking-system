"""
Auto-generated API smoke tests configuration
Generated by tools/generate_api_tests.py

Phase 1 Enhancement: Real test data fixtures for path parameter resolution
"""

import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional

from app.main import app
from app.database import get_db
from app.models.user import User, UserRole
from app.models.semester import Semester
from app.models.campus import Campus
from app.models.location import Location
from app.core.security import get_password_hash


@pytest.fixture(scope="module")
def api_client():
    """FastAPI test client"""
    return TestClient(app)


@pytest.fixture(scope="module")
def test_db():
    """Database session for test setup"""
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()


@pytest.fixture(scope="module")
def admin_token(test_db: Session):
    """Admin user authentication token"""
    # Check if admin exists
    admin = test_db.query(User).filter(User.email == "smoke.admin@generated.test").first()

    if not admin:
        admin = User(
            name="Smoke Test Admin",
            email="smoke.admin@generated.test",
            password_hash=get_password_hash("admin123"),
            role=UserRole.ADMIN,
            is_active=True
        )
        test_db.add(admin)
        test_db.commit()
        test_db.refresh(admin)

    # Generate token
    from app.core.auth import create_access_token
    token = create_access_token(data={"sub": admin.email}, expires_delta=timedelta(hours=1))
    return token


@pytest.fixture(scope="module")
def student_token(test_db: Session):
    """Student user authentication token"""
    student = test_db.query(User).filter(User.email == "smoke.student@generated.test").first()

    if not student:
        student = User(
            name="Smoke Test Student",
            email="smoke.student@generated.test",
            password_hash=get_password_hash("student123"),
            role=UserRole.STUDENT,
            is_active=True
        )
        test_db.add(student)
        test_db.commit()
        test_db.refresh(student)

    from app.core.auth import create_access_token
    token = create_access_token(data={"sub": student.email}, expires_delta=timedelta(hours=1))
    return token


@pytest.fixture(scope="module")
def instructor_token(test_db: Session):
    """Instructor user authentication token"""
    instructor = test_db.query(User).filter(User.email == "smoke.instructor@generated.test").first()

    if not instructor:
        instructor = User(
            name="Smoke Test Instructor",
            email="smoke.instructor@generated.test",
            password_hash=get_password_hash("instructor123"),
            role=UserRole.INSTRUCTOR,
            is_active=True
        )
        test_db.add(instructor)
        test_db.commit()
        test_db.refresh(instructor)

    from app.core.auth import create_access_token
    token = create_access_token(data={"sub": instructor.email}, expires_delta=timedelta(hours=1))
    return token


@pytest.fixture(scope="module")
def test_campus_id(test_db: Session) -> int:
    """
    Get or create a test campus for tournament session generation.

    Returns:
        Campus ID (int)
    """
    # Query existing campuses
    existing_campus = test_db.query(Campus).filter(Campus.is_active == True).first()

    if existing_campus:
        return existing_campus.id

    # Create test location if none exist
    location = test_db.query(Location).filter(Location.is_active == True).first()
    if not location:
        location = Location(
            name="Smoke Test Location",
            city="Budapest",
            is_active=True
        )
        test_db.add(location)
        test_db.commit()
        test_db.refresh(location)

    # Create test campus
    campus = Campus(
        name="Smoke Test Campus",
        location_id=location.id,
        address="Test Address 123",
        is_active=True
    )
    test_db.add(campus)
    test_db.commit()
    test_db.refresh(campus)

    return campus.id


@pytest.fixture(scope="function")
def test_tournament(test_db: Session, test_campus_id: int, student_token: str) -> Dict:
    """
    P3.2: Minimál Lifecycle Graph - State-driven test architecture with FUNCTION SCOPE.

    Creates a complete tournament with minimal viable state:
    - Tournament entity (Semester)
    - Campus schedule config
    - Reward config
    - 2 Students with PLAYER licenses
    - 2 Enrollments (APPROVED, is_active=True)
    - 1 Session (tournament_round=1)

    Note: MatchStructure/MatchResult not included (tables don't exist in DB).

    ISOLATION: Function-scoped to prevent test contamination (each test gets fresh state).

    Returns:
        {
            "tournament_id": int,
            "semester_id": int,
            "code": str,
            "name": str,
            "session_ids": List[int],
            "enrolled_student_ids": List[int],
            "has_reward_config": bool,
            "has_campus_schedule": bool,
            "has_sessions": bool,
            "has_enrollments": bool
        }
    """
    from app.models.campus_schedule_config import CampusScheduleConfig
    from app.models.tournament_reward_config import TournamentRewardConfig
    from app.models.license import UserLicense
    from app.models.semester_enrollment import SemesterEnrollment, EnrollmentStatus
    from app.models.session import Session as SessionModel

    timestamp = int(datetime.now(timezone.utc).timestamp())

    # Create tournament (game_preset_id moved to GameConfiguration in P3)
    # P3.2: Default status DRAFT (neutral state, allows status transitions)
    tournament = Semester(
        code=f"SMOKE_TEST_{timestamp}",
        name=f"Smoke Test Tournament {timestamp}",
        start_date=datetime.now(timezone.utc).date(),
        end_date=(datetime.now(timezone.utc) + timedelta(days=30)).date(),
        tournament_status="DRAFT",
        enrollment_cost=0,
        age_group="PRO",
        campus_id=test_campus_id,
        is_active=True
    )
    test_db.add(tournament)
    test_db.commit()
    test_db.refresh(tournament)

    # Add campus schedule config (minimal valid configuration)
    campus_schedule = CampusScheduleConfig(
        tournament_id=tournament.id,
        campus_id=test_campus_id,
        match_duration_minutes=90,
        break_duration_minutes=15,
        parallel_fields=1,
        is_active=True
    )
    test_db.add(campus_schedule)

    # Add reward config (minimal valid configuration)
    reward_config = TournamentRewardConfig(
        semester_id=tournament.id,
        reward_policy_name="smoke_test_policy"
    )
    test_db.add(reward_config)

    test_db.commit()

    # ── 4. Create 2 Students with PLAYER Licenses ──────────────────────
    # Get student 1 (created by student_token fixture)
    student1 = test_db.query(User).filter(User.email == "smoke.student@generated.test").first()

    # Create student 2
    student2_email = f"smoke.student2.{timestamp}@generated.test"
    student2 = test_db.query(User).filter(User.email == student2_email).first()
    if not student2:
        student2 = User(
            name="Smoke Test Student 2",
            email=student2_email,
            password_hash=get_password_hash("student123"),
            role=UserRole.STUDENT,
            is_active=True,
            credit_balance=1000
        )
        test_db.add(student2)
        test_db.commit()
        test_db.refresh(student2)

    # Create UserLicense + Enrollment for both students
    enrolled_student_ids = []
    for student in [student1, student2]:
        # Check if PLAYER license exists
        user_license = test_db.query(UserLicense).filter(
            UserLicense.user_id == student.id,
            UserLicense.specialization_type == "PLAYER"
        ).first()

        if not user_license:
            user_license = UserLicense(
                user_id=student.id,
                specialization_type="PLAYER",
                current_level=1,
                max_achieved_level=1,
                started_at=datetime.now(timezone.utc),
                is_active=True
            )
            test_db.add(user_license)
            test_db.commit()
            test_db.refresh(user_license)

        # ── 5. Create Enrollment (APPROVED, is_active=True) ────────────
        enrollment = SemesterEnrollment(
            user_id=student.id,
            semester_id=tournament.id,
            user_license_id=user_license.id,
            request_status=EnrollmentStatus.APPROVED,
            is_active=True,
            requested_at=datetime.now(timezone.utc),
            approved_at=datetime.now(timezone.utc),
            enrolled_at=datetime.now(timezone.utc),
            age_category="PRO"
        )
        test_db.add(enrollment)
        enrolled_student_ids.append(student.id)

    test_db.commit()

    # ── 6. Create 1 Session ─────────────────────────────────────────────
    session_start = datetime.now(timezone.utc) + timedelta(days=1)
    session_end = session_start + timedelta(hours=2)

    session = SessionModel(
        title=f"Smoke Test Session - Round 1",
        description="Minimal lifecycle graph session",
        date_start=session_start,
        date_end=session_end,
        semester_id=tournament.id,
        campus_id=test_campus_id,
        tournament_round=1,
        tournament_match_number=1,
        session_status="scheduled",
        capacity=16
    )
    test_db.add(session)
    test_db.commit()
    test_db.refresh(session)

    return {
        "tournament_id": tournament.id,
        "semester_id": tournament.id,
        "code": tournament.code,
        "name": tournament.name,
        "session_ids": [session.id],
        "enrolled_student_ids": enrolled_student_ids,
        "has_reward_config": True,
        "has_campus_schedule": True,
        "has_sessions": True,
        "has_enrollments": True
    }


@pytest.fixture(scope="module")
def test_student_id(test_db: Session) -> int:
    """
    Get smoke test student user ID for badge/user endpoints.

    Returns:
        User ID (int)
    """
    student = test_db.query(User).filter(User.email == "smoke.student@generated.test").first()
    assert student, "Smoke test student not found - ensure student_token fixture is called first"
    return student.id


@pytest.fixture(scope="module")
def test_instructor_id(test_db: Session, instructor_token: str) -> int:
    """
    Get smoke test instructor user ID for instructor endpoints.

    Explicit dependency: instructor_token fixture creates the instructor user.

    Returns:
        User ID (int)
    """
    instructor = test_db.query(User).filter(User.email == "smoke.instructor@generated.test").first()
    assert instructor, "Smoke test instructor not found after instructor_token fixture"
    return instructor.id


@pytest.fixture(scope="function")
def test_session_id(test_tournament: Dict) -> int:
    """
    P3.2: Extract session ID from lifecycle graph (function-scoped for isolation).

    Returns first session ID from test_tournament fixture.
    NO new entities created - pure extraction from existing state.

    Returns:
        Session ID (int)
    """
    assert test_tournament["has_sessions"], "Tournament fixture has no sessions"
    assert len(test_tournament["session_ids"]) > 0, "Tournament fixture session_ids is empty"
    return test_tournament["session_ids"][0]


def ensure_tournament_status(
    tournament_id: int,
    target_status: str,
    admin_token: str,
    test_db: Session
) -> Dict[str, any]:
    """
    P3.3: Workflow orchestration helper - explicit tournament status transitions.

    Executes necessary workflow transitions to reach target status.
    Documents state machine progression for smoke test clarity.

    Supported transitions:
    - DRAFT → ENROLLMENT_OPEN
    - ENROLLMENT_OPEN → IN_PROGRESS (via session generation)
    - IN_PROGRESS → COMPLETED (via finalization)

    Args:
        tournament_id: Tournament to transition
        target_status: Desired final status
        admin_token: Admin authentication token
        test_db: Database session

    Returns:
        {"success": True, "transitions": ["DRAFT→ENROLLMENT_OPEN"], "final_status": "ENROLLMENT_OPEN"}

    Raises:
        AssertionError: If transition fails or invalid path
    """
    from app.models.semester import Semester
    from fastapi.testclient import TestClient
    from app.main import app

    client = TestClient(app)
    headers = {"Authorization": f"Bearer {admin_token}"}

    # Fetch current status
    tournament = test_db.query(Semester).filter(Semester.id == tournament_id).first()
    assert tournament, f"Tournament {tournament_id} not found"

    current_status = tournament.tournament_status
    transitions_executed = []

    # Define valid transition paths
    TRANSITION_PATHS = {
        "ENROLLMENT_OPEN": {
            "from": ["DRAFT"],
            "endpoint": f"/api/v1/tournaments/{tournament_id}/status",
            "method": "PATCH",
            "payload": {"new_status": "ENROLLMENT_OPEN"},
        },
        "IN_PROGRESS": {
            "from": ["ENROLLMENT_OPEN", "DRAFT"],
            "steps": [
                # First ensure ENROLLMENT_OPEN
                {
                    "required_from": ["DRAFT"],
                    "endpoint": f"/api/v1/tournaments/{tournament_id}/status",
                    "method": "PATCH",
                    "payload": {"new_status": "ENROLLMENT_OPEN"},
                },
                # Then transition to IN_PROGRESS (via session generation or status change)
                {
                    "endpoint": f"/api/v1/tournaments/{tournament_id}/status",
                    "method": "PATCH",
                    "payload": {"new_status": "IN_PROGRESS"},
                },
            ],
        },
        "COMPLETED": {
            "from": ["IN_PROGRESS"],
            "endpoint": f"/api/v1/tournaments/{tournament_id}/complete",
            "method": "POST",
            "payload": {},
        },
        "SEEKING_INSTRUCTOR": {
            "from": ["DRAFT"],
            "endpoint": f"/api/v1/tournaments/{tournament_id}/status",
            "method": "PATCH",
            "payload": {"new_status": "SEEKING_INSTRUCTOR"},
        },
    }

    if current_status == target_status:
        return {
            "success": True,
            "transitions": [],
            "final_status": current_status,
            "message": "Already in target status",
        }

    if target_status not in TRANSITION_PATHS:
        raise ValueError(f"Unsupported target status: {target_status}")

    transition_config = TRANSITION_PATHS[target_status]

    # Handle multi-step transitions
    if "steps" in transition_config:
        for step in transition_config["steps"]:
            # Check if this step is needed
            if "required_from" in step:
                tournament = test_db.query(Semester).filter(Semester.id == tournament_id).first()
                current_status = tournament.tournament_status
                if current_status not in step["required_from"]:
                    continue  # Skip this step

            # Execute step
            response = client.request(
                method=step["method"],
                url=step["endpoint"],
                json=step.get("payload", {}),
                headers=headers,
            )

            assert response.status_code in [200, 201, 204], (
                f"Transition step failed: {step['method']} {step['endpoint']} "
                f"→ {response.status_code} {response.text}"
            )

            # Refresh status
            test_db.expire(tournament)
            tournament = test_db.query(Semester).filter(Semester.id == tournament_id).first()
            new_status = tournament.tournament_status
            transitions_executed.append(f"{current_status}→{new_status}")
            current_status = new_status

    else:
        # Single-step transition
        assert current_status in transition_config["from"], (
            f"Invalid transition: {current_status} → {target_status}. "
            f"Valid from: {transition_config['from']}"
        )

        response = client.request(
            method=transition_config["method"],
            url=transition_config["endpoint"],
            json=transition_config.get("payload", {}),
            headers=headers,
        )

        assert response.status_code in [200, 201, 204], (
            f"Transition failed: {transition_config['method']} {transition_config['endpoint']} "
            f"→ {response.status_code} {response.text}"
        )

        transitions_executed.append(f"{current_status}→{target_status}")

    # Final validation
    test_db.expire(tournament)
    tournament = test_db.query(Semester).filter(Semester.id == tournament_id).first()
    final_status = tournament.tournament_status

    assert final_status == target_status, (
        f"Transition failed: Expected {target_status}, got {final_status}. "
        f"Transitions: {transitions_executed}"
    )

    return {
        "success": True,
        "transitions": transitions_executed,
        "final_status": final_status,
        "message": f"Successfully transitioned to {target_status}",
    }


@pytest.fixture(scope="module")
def payload_factory():
    """
    Phase 1: Payload factory for generating schema-compliant request payloads.

    Eliminates 422 validation errors by generating minimally valid payloads
    based on OpenAPI schema definitions.
    """
    from tests.integration.api_smoke.payload_factory import PayloadFactory

    # Get OpenAPI schema
    openapi_schema = app.openapi()

    # Create and return factory instance
    return PayloadFactory(openapi_schema)

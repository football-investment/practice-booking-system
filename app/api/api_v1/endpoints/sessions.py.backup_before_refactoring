from typing import Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from sqlalchemy import func, and_, or_, case

from ....services.session_filter_service import SessionFilterService

from ....database import get_db
from ....dependencies import get_current_user, get_current_admin_or_instructor_user
from ....models.user import User
from ....models.session import Session as SessionTypel, SessionType
from ....models.booking import Booking, BookingStatus
from ....models.attendance import Attendance
from ....models.feedback import Feedback
from ....schemas.session import (
    Session as SessionSchema, SessionCreate, SessionUpdate,
    SessionWithStats, SessionList
)
from ....schemas.booking import (
    BookingWithRelations, BookingList
)

router = APIRouter()


@router.post("/", response_model=SessionSchema)
def create_session(
    session_data: SessionCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_admin_or_instructor_user)
) -> Any:
    """
    Create new session (Admin/Instructor only)

    IMPORTANT: Instructors can only create sessions for semesters where they are
    the assigned master instructor.
    """
    from ....models.user import UserRole
    from ....models.semester import Semester

    # üöÄ PERFORMANCE: Fetch semester once (used for both authorization and date validation)
    semester = db.query(Semester).filter(
        Semester.id == session_data.semester_id
    ).first()

    if not semester:
        raise HTTPException(
            status_code=404,
            detail=f"Semester {session_data.semester_id} not found"
        )

    # If instructor, validate master instructor authorization
    if current_user.role == UserRole.INSTRUCTOR:
        # Check if current user is the master instructor for this semester
        if semester.master_instructor_id != current_user.id:
            raise HTTPException(
                status_code=403,
                detail=f"Only the master instructor (ID: {semester.master_instructor_id}) "
                       f"can create sessions for this semester. "
                       f"You must first accept the assignment request for this semester."
            )

        # Check if session has target_specialization (additional validation)
        if hasattr(session_data, 'target_specialization') and session_data.target_specialization:
            # Check if instructor has ACTIVE qualification for this specialization
            if not current_user.can_teach_specialization(session_data.target_specialization):
                raise HTTPException(
                    status_code=403,
                    detail=f"You do not have active teaching qualification for {session_data.target_specialization}. "
                           f"Please activate this specialization in your dashboard before creating sessions."
                )

    # Validate session dates are within semester boundaries (reuse fetched semester)
    if semester:
        session_start_date = session_data.date_start.date()
        session_end_date = session_data.date_end.date()

        if session_start_date < semester.start_date:
            raise HTTPException(
                status_code=400,
                detail=f"Session start date ({session_start_date}) cannot be before semester start date ({semester.start_date})"
            )

        if session_end_date > semester.end_date:
            raise HTTPException(
                status_code=400,
                detail=f"Session end date ({session_end_date}) cannot be after semester end date ({semester.end_date})"
            )

    session = SessionTypel(**session_data.model_dump())
    db.add(session)
    db.commit()
    db.refresh(session)

    return session


@router.get("/", response_model=SessionList)
def list_sessions(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
    page: int = Query(1, ge=1),
    size: int = Query(50, ge=1, le=100),
    semester_id: Optional[int] = Query(None),
    group_id: Optional[int] = Query(None),
    session_type: Optional[SessionType] = Query(None, description="Filter by session type (on_site, hybrid, virtual)"),
    # üéì NEW: Specialization filtering parameters
    specialization_filter: bool = Query(True, description="Filter by user's specialization"),
    include_mixed: bool = Query(True, description="Include mixed specialization sessions")
) -> Any:
    """
    List sessions with pagination and filtering
    For students: Show sessions from all current active semesters (based on date range)
    For admin/instructor: Show all sessions or filtered by semester_id
    
    Multi-semester support: When multiple semesters run concurrently (e.g., different
    tracks of Fall 2025), students will see sessions from all active semesters.
    This ensures visibility when users enroll in second semester or concurrent programs.
    """
    query = db.query(SessionTypel)
    
    # Apply role-based semester filtering
    from ....models.semester import Semester
    from ....models.user import UserRole
    
    if current_user.role == UserRole.STUDENT:
        # üåê CRITICAL: Cross-semester logic for Mbapp√© (LFA Testing)
        if current_user.email == "mbappe@lfa.com":
            # Mbapp√© gets access to ALL sessions across ALL semesters
            print(f"üåê Cross-semester access granted for {current_user.name} (LFA Testing)")
            # No semester restriction for Mbapp√© - only apply semester_id filter if explicitly requested
            if semester_id:
                query = query.filter(SessionTypel.semester_id == semester_id)
                print(f"üéØ Mbapp√© filtering by specific semester: {semester_id}")
            else:
                print("üåê Mbapp√© accessing ALL sessions across ALL semesters")
        else:
            # Regular students see sessions from all current active semesters with intelligent filtering
            if not semester_id:
                # Get all current active semesters (including parallel tracks)
                from datetime import date
                today = date.today()
                
                current_semesters = db.query(Semester).filter(
                    and_(
                        Semester.start_date <= today,
                        Semester.end_date >= today,
                        Semester.is_active == True
                    )
                ).all()
                
                if current_semesters:
                    semester_ids = [s.id for s in current_semesters]
                    query = query.filter(SessionTypel.semester_id.in_(semester_ids))
                    print(f"Student seeing sessions from {len(current_semesters)} current semesters: {[s.name for s in current_semesters]}")
                else:
                    # Fallback: if no current semesters by date, show most recent semesters
                    recent_semesters = db.query(Semester).filter(
                        Semester.is_active == True
                    ).order_by(Semester.id.desc()).limit(3).all()
                    if recent_semesters:
                        semester_ids = [s.id for s in recent_semesters]
                        query = query.filter(SessionTypel.semester_id.in_(semester_ids))
                        print(f"Fallback: Student seeing sessions from {len(recent_semesters)} recent semesters")
            else:
                # Allow filtering by specific semester for students
                query = query.filter(SessionTypel.semester_id == semester_id)
    else:
        # Admin/Instructor can see all sessions or filter by semester
        if semester_id:
            query = query.filter(SessionTypel.semester_id == semester_id)
    
    # üéì NEW: Apply specialization filtering (CRITICAL: Preserves Mbapp√© logic)
    # FIX: Only apply to STUDENTS with specialization - skip for admin/instructor
    if specialization_filter and current_user.role == UserRole.STUDENT and hasattr(current_user, 'has_specialization') and current_user.has_specialization:
        # Only apply specialization filtering to students who have a specialization
        # ‚ö†Ô∏è CRITICAL: This preserves Mbapp√© cross-semester access since he's already handled above

        specialization_conditions = []

        # Sessions with no specific target (accessible to all)
        specialization_conditions.append(SessionTypel.target_specialization.is_(None))

        # Sessions matching user's specialization
        if current_user.specialization:
            specialization_conditions.append(SessionTypel.target_specialization == current_user.specialization)

        # Mixed specialization sessions (if include_mixed is True)
        if include_mixed:
            specialization_conditions.append(SessionTypel.mixed_specialization == True)

        query = query.filter(or_(*specialization_conditions))

        if current_user.specialization:
            print(f"üéì Specialization filtering applied for {current_user.name}: {current_user.specialization.value}")
    
    # Apply other filters
    if group_id:
        query = query.filter(SessionTypel.group_id == group_id)
    if session_type:
        query = query.filter(SessionTypel.session_type == session_type)
    
    # Get total count
    total = query.count()
    
    # Apply pagination with ordering (future sessions first, then by start date)
    from datetime import datetime, timezone
    
    # Get current time in UTC and convert to naive for DB comparison
    # All datetime objects in DB are stored as naive UTC
    now_utc = datetime.now(timezone.utc)
    now_naive_utc = now_utc.replace(tzinfo=None)
    
    offset = (page - 1) * size
    
    # Apply intelligent filtering for students, standard ordering for others
    if current_user.role == UserRole.STUDENT:
        # INTERNSHIP users use target_specialization filtering only (already applied above)
        # Other specializations use SessionFilterService for keyword-based filtering
        from ....models.specialization import SpecializationType

        if current_user.specialization == SpecializationType.INTERNSHIP:
            # INTERNSHIP users: Use simple ordering, target_specialization filter already applied
            sessions = query.order_by(
                (SessionTypel.date_start > now_naive_utc).desc(),  # Future sessions first
                SessionTypel.date_start.asc()                      # Then by start time
            ).offset(offset).limit(size).all()
        else:
            # Other specializations: Use SessionFilterService for intelligent filtering
            filter_service = SessionFilterService(db)
            # Get ordered query
            ordered_query = query.order_by(
                (SessionTypel.date_start > now_naive_utc).desc(),  # Future sessions first
                SessionTypel.date_start.asc()                      # Then by start time (earliest future first)
            )
            # Apply intelligent filtering with pagination consideration
            filtered_sessions = filter_service.get_relevant_sessions_for_user(
                current_user,
                ordered_query,
                limit=size * 2  # Get more sessions to ensure enough after filtering
            )
            # Apply manual pagination to filtered results
            sessions = filtered_sessions[offset:offset + size]
    else:
        # Standard ordering and pagination for admin/instructor users
        sessions = query.order_by(
            (SessionTypel.date_start > now_naive_utc).desc(),  # Future sessions first
            SessionTypel.date_start.asc()                      # Then by start time (earliest future first)
        ).offset(offset).limit(size).all()

    # üöÄ PERFORMANCE OPTIMIZATION: Pre-fetch all stats with JOIN queries (eliminates N+1 problem)
    session_ids = [s.id for s in sessions]

    # Fetch booking stats in a single query using GROUP BY
    booking_stats_query = db.query(
        Booking.session_id,
        func.count(Booking.id).label('total_bookings'),
        func.sum(case((Booking.status == BookingStatus.CONFIRMED, 1), else_=0)).label('confirmed'),
        func.sum(case((Booking.status == BookingStatus.WAITLISTED, 1), else_=0)).label('waitlisted')
    ).filter(Booking.session_id.in_(session_ids)).group_by(Booking.session_id).all()

    # Create lookup dict for O(1) access
    booking_stats_dict = {
        stat.session_id: {
            'total': stat.total_bookings,
            'confirmed': stat.confirmed,
            'waitlisted': stat.waitlisted
        } for stat in booking_stats_query
    }

    # Fetch attendance stats in a single query
    attendance_stats_query = db.query(
        Attendance.session_id,
        func.count(Attendance.id).label('count')
    ).filter(Attendance.session_id.in_(session_ids)).group_by(Attendance.session_id).all()

    attendance_stats_dict = {stat.session_id: stat.count for stat in attendance_stats_query}

    # Fetch rating stats in a single query
    rating_stats_query = db.query(
        Feedback.session_id,
        func.avg(Feedback.rating).label('avg_rating')
    ).filter(Feedback.session_id.in_(session_ids)).group_by(Feedback.session_id).all()

    rating_stats_dict = {stat.session_id: float(stat.avg_rating) if stat.avg_rating else None for stat in rating_stats_query}

    # Add statistics
    session_stats = []
    for session in sessions:
        # Get stats from pre-fetched dicts (O(1) lookup)
        booking_stats = booking_stats_dict.get(session.id, {'total': 0, 'confirmed': 0, 'waitlisted': 0})
        booking_count = booking_stats['total']
        confirmed_bookings = booking_stats['confirmed']
        waitlist_count = booking_stats['waitlisted']
        attendance_count = attendance_stats_dict.get(session.id, 0)
        avg_rating = rating_stats_dict.get(session.id, None)

        # FIX: Build session data explicitly to handle NULL values
        session_data = {
            "id": session.id,
            "title": session.title,
            "description": session.description or "",
            "date_start": session.date_start,
            "date_end": session.date_end,
            "session_type": session.session_type,
            "capacity": session.capacity if session.capacity is not None else 0,  # FIX: Handle NULL
            "credit_cost": session.credit_cost if session.credit_cost is not None else 1,  # FIX: Include credit_cost from database
            "location": session.location,
            "meeting_link": session.meeting_link,
            "sport_type": session.sport_type,
            "level": session.level,
            "instructor_name": session.instructor_name,
            "semester_id": session.semester_id,
            "group_id": session.group_id,
            "instructor_id": session.instructor_id,
            "created_at": session.created_at or session.date_start,  # FIX: Handle NULL created_at
            "updated_at": session.updated_at,
            "target_specialization": session.target_specialization,
            "mixed_specialization": session.mixed_specialization if hasattr(session, 'mixed_specialization') else False,
            "semester": session.semester,
            "group": session.group,
            "instructor": session.instructor,
            "booking_count": booking_count,
            "confirmed_bookings": confirmed_bookings,
            "current_bookings": confirmed_bookings,
            "waitlist_count": waitlist_count,
            "attendance_count": attendance_count,
            "average_rating": float(avg_rating) if avg_rating else None
        }

        session_stats.append(SessionWithStats(**session_data))
    
    return SessionList(
        sessions=session_stats,
        total=total,
        page=page,
        size=size
    )


@router.get("/recommendations")
def get_session_recommendations(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> Any:
    """
    Get personalized session recommendations and filtering summary for current user
    """
    filter_service = SessionFilterService(db)
    recommendations_summary = filter_service.get_session_recommendations_summary(current_user)
    
    return {
        "user_profile": recommendations_summary,
        "message": "Session filtering is personalized based on your projects and interests"
    }


@router.get("/{session_id}/bookings", response_model=BookingList)
def get_session_bookings(
    session_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
    page: int = Query(1, ge=1),
    size: int = Query(50, ge=1, le=100)
) -> Any:
    """
    Get bookings for a session (Admin/Instructor only)
    """
    # Check if session exists
    session = db.query(SessionTypel).filter(SessionTypel.id == session_id).first()
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    query = db.query(Booking).filter(Booking.session_id == session_id)

    # Get total count
    total = query.count()

    # OPTIMIZED: Eager load relationships to avoid N+1 query pattern
    query = query.options(
        joinedload(Booking.user),
        joinedload(Booking.session)
    )

    # Apply pagination
    offset = (page - 1) * size
    bookings = query.offset(offset).limit(size).all()

    # Convert to response schema
    booking_responses = []
    for booking in bookings:
        booking_responses.append(BookingWithRelations(
            **booking.__dict__,
            user=booking.user,
            session=booking.session
        ))
    
    return BookingList(
        bookings=booking_responses,
        total=total,
        page=page,
        size=size
    )


@router.get("/{session_id}", response_model=SessionWithStats)
def get_session(
    session_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> Any:
    """
    Get session by ID with statistics
    """
    session = db.query(SessionTypel).filter(SessionTypel.id == session_id).first()
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    # Calculate statistics
    booking_count = db.query(func.count(Booking.id)).filter(Booking.session_id == session.id).scalar() or 0
    confirmed_bookings = db.query(func.count(Booking.id)).filter(
        and_(Booking.session_id == session.id, Booking.status == BookingStatus.CONFIRMED)
    ).scalar() or 0
    waitlist_count = db.query(func.count(Booking.id)).filter(
        and_(Booking.session_id == session.id, Booking.status == BookingStatus.WAITLISTED)
    ).scalar() or 0
    attendance_count = db.query(func.count(Attendance.id)).filter(Attendance.session_id == session.id).scalar() or 0
    avg_rating = db.query(func.avg(Feedback.rating)).filter(Feedback.session_id == session.id).scalar()
    
    return SessionWithStats(
        **session.__dict__,
        semester=session.semester,
        group=session.group,
        instructor=session.instructor,
        booking_count=booking_count,
        confirmed_bookings=confirmed_bookings,
        current_bookings=confirmed_bookings,  # FIXED: Map confirmed_bookings to current_bookings for frontend
        waitlist_count=waitlist_count,
        attendance_count=attendance_count,
        average_rating=float(avg_rating) if avg_rating else None
    )


@router.patch("/{session_id}", response_model=SessionSchema)
def update_session(
    session_id: int,
    session_update: SessionUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_admin_or_instructor_user)
) -> Any:
    """
    Update session (Admin/Instructor only)

    IMPORTANT: Instructors can only update sessions for semesters where they are
    the assigned master instructor.
    """
    from ....models.user import UserRole
    from ....models.semester import Semester

    session = db.query(SessionTypel).filter(SessionTypel.id == session_id).first()
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )

    # If instructor, validate master instructor authorization
    if current_user.role == UserRole.INSTRUCTOR:
        # Get semester to check master_instructor_id
        semester = db.query(Semester).filter(
            Semester.id == session.semester_id
        ).first()

        if semester and semester.master_instructor_id != current_user.id:
            raise HTTPException(
                status_code=403,
                detail=f"Only the master instructor (ID: {semester.master_instructor_id}) "
                       f"can update sessions for this semester."
            )

    # Update fields
    update_data = session_update.model_dump(exclude_unset=True)

    # üîç DEBUG: Log what we received
    print(f"üîç BACKEND DEBUG - Session {session_id} PATCH received:")
    print(f"   credit_cost in update_data: {update_data.get('credit_cost', 'NOT_IN_PAYLOAD')}")
    print(f"   capacity in update_data: {update_data.get('capacity', 'NOT_IN_PAYLOAD')}")
    print(f"   Full update_data: {update_data}")

    # Validate updated dates are within semester boundaries (if dates are being updated)
    if 'date_start' in update_data or 'date_end' in update_data:
        semester = db.query(Semester).filter(Semester.id == session.semester_id).first()
        if semester:
            new_start_date = (update_data.get('date_start') or session.date_start).date()
            new_end_date = (update_data.get('date_end') or session.date_end).date()

            if new_start_date < semester.start_date:
                raise HTTPException(
                    status_code=400,
                    detail=f"Session start date ({new_start_date}) cannot be before semester start date ({semester.start_date})"
                )

            if new_end_date > semester.end_date:
                raise HTTPException(
                    status_code=400,
                    detail=f"Session end date ({new_end_date}) cannot be after semester end date ({semester.end_date})"
                )

    for field, value in update_data.items():
        setattr(session, field, value)

    # üîç DEBUG: Log what was actually set on the model
    print(f"üîç BACKEND DEBUG - After setattr loop:")
    print(f"   session.credit_cost = {session.credit_cost}")
    print(f"   session.capacity = {session.capacity}")

    db.commit()
    db.refresh(session)

    # üîç DEBUG: Log after DB commit
    print(f"üîç BACKEND DEBUG - After commit + refresh:")
    print(f"   session.credit_cost = {session.credit_cost}")
    print(f"   session.capacity = {session.capacity}")

    return session


@router.delete("/{session_id}")
def delete_session(
    session_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_admin_or_instructor_user)
) -> Any:
    """
    Delete session (Admin/Instructor only)
    IMPORTANT: Instructors can only delete sessions for semesters where they are
    the assigned master instructor.
    """
    from ....models.user import UserRole
    from ....models.semester import Semester

    session = db.query(SessionTypel).filter(SessionTypel.id == session_id).first()
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )

    # If instructor, validate master instructor authorization
    if current_user.role == UserRole.INSTRUCTOR:
        semester = db.query(Semester).filter(Semester.id == session.semester_id).first()

        if semester and semester.master_instructor_id != current_user.id:
            raise HTTPException(
                status_code=403,
                detail=f"Only the master instructor (ID: {semester.master_instructor_id}) "
                       f"can delete sessions for this semester."
            )

    # üîí COMPREHENSIVE RELATIONSHIP CHECK: Prevent orphaned data
    # Check all relationships before allowing deletion
    from ....models.project import ProjectSession

    relationship_checks = []

    # Check bookings
    booking_count = db.query(func.count(Booking.id)).filter(Booking.session_id == session_id).scalar()
    if booking_count > 0:
        relationship_checks.append(("bookings", booking_count))

    # Check attendances
    attendance_count = db.query(func.count(Attendance.id)).filter(Attendance.session_id == session_id).scalar()
    if attendance_count > 0:
        relationship_checks.append(("attendance records", attendance_count))

    # Check feedbacks
    feedback_count = db.query(func.count(Feedback.id)).filter(Feedback.session_id == session_id).scalar()
    if feedback_count > 0:
        relationship_checks.append(("feedback submissions", feedback_count))

    # Check project associations
    project_session_count = db.query(func.count(ProjectSession.id)).filter(ProjectSession.session_id == session_id).scalar()
    if project_session_count > 0:
        relationship_checks.append(("project associations", project_session_count))

    # If any relationships exist, block deletion
    if relationship_checks:
        relationship_details = ", ".join([f"{count} {name}" for name, count in relationship_checks])
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Cannot delete session with existing related data: {relationship_details}. "
                   f"Please remove all related records before deleting the session."
        )

    db.delete(session)
    db.commit()

    return {"message": "Session deleted successfully"}


@router.get("/instructor/my")
def get_instructor_sessions(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
    page: int = Query(1, ge=1),
    size: int = Query(50, ge=1, le=100)
) -> Any:
    """
    Get sessions for current instructor
    """
    # Verify user is instructor
    if current_user.role.value != 'instructor':
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied. Instructor role required."
        )
    
    # Query sessions assigned to this instructor
    query = db.query(SessionTypel).filter(SessionTypel.instructor_id == current_user.id).order_by(SessionTypel.date_start.desc())
    
    # Get total count
    total = query.count()
    
    # Apply pagination
    offset = (page - 1) * size
    sessions = query.offset(offset).limit(size).all()
    
    # Return simple response for now
    session_list = []
    for session in sessions:
        # Get booking count
        booking_count = db.query(func.count(Booking.id)).filter(
            and_(
                Booking.session_id == session.id,
                Booking.status == BookingStatus.CONFIRMED
            )
        ).scalar() or 0
        
        session_dict = {
            'id': session.id,
            'title': session.title,
            'description': session.description,
            'date_start': session.date_start.isoformat(),
            'date_end': session.date_end.isoformat(),
            'location': session.location,
            'capacity': session.capacity,
            'instructor_id': session.instructor_id,
            'level': session.level,
            'sport_type': session.sport_type,
            'current_bookings': booking_count,
            'created_at': session.created_at.isoformat(),
        }
        session_list.append(session_dict)
    
    return {
        'sessions': session_list,
        'total': total,
        'page': page,
        'size': size
    }


@router.get("/calendar")
def get_calendar_events(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> List[dict]:
    """
    Get all sessions formatted for FullCalendar
    Returns simplified session data for calendar display
    """
    from datetime import datetime

    # Get all sessions
    sessions = db.query(SessionTypel).order_by(SessionTypel.date_start.asc()).all()

    # Format for FullCalendar
    calendar_events = []
    for session in sessions:
        calendar_events.append({
            'id': session.id,
            'title': session.title,
            'description': session.description,
            'date_start': session.date_start.isoformat() if session.date_start else None,
            'date_end': session.date_end.isoformat() if session.date_end else None,
            'session_type': session.session_type.value if session.session_type else 'on_site',
            'location': session.location,
            'capacity': session.capacity
        })

    return calendar_events
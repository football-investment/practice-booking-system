"""
Instructor Assignment Request System API Endpoints

NEW CONCEPT: Demand-driven instructor assignment workflow

Flow:
1. Instructor sets general availability: "Q3 2026, Budapest+Budaörs"
2. Admin generates semesters for specific age groups
3. System shows admins which instructors are available
4. Admin sends assignment request to instructor
5. Instructor accepts/declines specific semester assignments
"""

from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session, joinedload
from typing import List, Optional
from datetime import datetime

from app.database import get_db
from app.models.instructor_assignment import (
    InstructorAvailabilityWindow,
    InstructorAssignmentRequest,
    AssignmentRequestStatus
)
from app.models.user import User, UserRole
from app.models.semester import Semester
from app.models.license import UserLicense
from app.schemas.instructor_assignment import (
    InstructorAvailabilityWindowCreate,
    InstructorAvailabilityWindowUpdate,
    InstructorAvailabilityWindowResponse,
    InstructorAssignmentRequestCreate,
    InstructorAssignmentRequestUpdate,
    InstructorAssignmentRequestAccept,
    InstructorAssignmentRequestDecline,
    InstructorAssignmentRequestResponse,
    AvailableInstructorInfo,
    InstructorLicenseInfo,
    AvailableInstructorsQuery
)
from app.dependencies import get_current_user

router = APIRouter()


# ============================================================================
# Instructor Availability Window Endpoints
# ============================================================================

@router.post("/availability", response_model=InstructorAvailabilityWindowResponse, status_code=status.HTTP_201_CREATED)
def create_availability_window(
    availability: InstructorAvailabilityWindowCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create a new availability window.

    Instructors can only create for themselves, admins can create for anyone.
    """
    # Authorization
    if current_user.role != UserRole.ADMIN:
        if current_user.id != availability.instructor_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only set your own availability"
            )

    # Verify instructor exists and has instructor role
    instructor = db.query(User).filter(
        User.id == availability.instructor_id,
        User.role == UserRole.INSTRUCTOR
    ).first()
    if not instructor:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Instructor not found"
        )

    # Check for duplicate
    existing = db.query(InstructorAvailabilityWindow).filter(
        InstructorAvailabilityWindow.instructor_id == availability.instructor_id,
        InstructorAvailabilityWindow.year == availability.year,
        InstructorAvailabilityWindow.time_period == availability.time_period
    ).first()

    if existing:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Availability window already exists for this instructor/year/period"
        )

    # Create
    db_availability = InstructorAvailabilityWindow(**availability.model_dump())
    db.add(db_availability)
    db.commit()
    db.refresh(db_availability)

    return db_availability


@router.get("/availability/instructor/{instructor_id}", response_model=List[InstructorAvailabilityWindowResponse])
def get_instructor_availability_windows(
    instructor_id: int,
    year: Optional[int] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get all availability windows for a specific instructor"""
    # Authorization
    if current_user.role != UserRole.ADMIN:
        if current_user.id != instructor_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only view your own availability"
            )

    query = db.query(InstructorAvailabilityWindow).filter(
        InstructorAvailabilityWindow.instructor_id == instructor_id
    )

    if year:
        query = query.filter(InstructorAvailabilityWindow.year == year)

    windows = query.order_by(
        InstructorAvailabilityWindow.year.desc(),
        InstructorAvailabilityWindow.time_period
    ).all()

    return windows


@router.patch("/availability/{window_id}", response_model=InstructorAvailabilityWindowResponse)
def update_availability_window(
    window_id: int,
    update_data: InstructorAvailabilityWindowUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Update an availability window"""
    # Get the window
    window = db.query(InstructorAvailabilityWindow).filter(
        InstructorAvailabilityWindow.id == window_id
    ).first()

    if not window:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Availability window not found"
        )

    # Authorization
    if current_user.role != UserRole.ADMIN:
        if current_user.id != window.instructor_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only update your own availability"
            )

    # Update
    for field, value in update_data.model_dump(exclude_unset=True).items():
        setattr(window, field, value)

    window.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(window)

    return window


@router.delete("/availability/{window_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_availability_window(
    window_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Delete an availability window"""
    # Get the window
    window = db.query(InstructorAvailabilityWindow).filter(
        InstructorAvailabilityWindow.id == window_id
    ).first()

    if not window:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Availability window not found"
        )

    # Authorization
    if current_user.role != UserRole.ADMIN:
        if current_user.id != window.instructor_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only delete your own availability"
            )

    db.delete(window)
    db.commit()

    return None


# ============================================================================
# Assignment Request Endpoints
# ============================================================================

@router.post("/requests", response_model=InstructorAssignmentRequestResponse, status_code=status.HTTP_201_CREATED)
def create_assignment_request(
    request_data: InstructorAssignmentRequestCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create a new assignment request (Admin only).

    Admin sends request to instructor asking them to teach a specific semester.
    """
    # Authorization - only admins can send requests
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can send assignment requests"
        )

    # Verify semester exists
    semester = db.query(Semester).filter(Semester.id == request_data.semester_id).first()
    if not semester:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Semester not found"
        )

    # Verify instructor exists
    instructor = db.query(User).filter(
        User.id == request_data.instructor_id,
        User.role == UserRole.INSTRUCTOR
    ).first()
    if not instructor:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Instructor not found"
        )

    # Check if there's already a pending request for this semester/instructor
    existing_pending = db.query(InstructorAssignmentRequest).filter(
        InstructorAssignmentRequest.semester_id == request_data.semester_id,
        InstructorAssignmentRequest.instructor_id == request_data.instructor_id,
        InstructorAssignmentRequest.status == AssignmentRequestStatus.PENDING
    ).first()

    if existing_pending:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="A pending request already exists for this semester and instructor"
        )

    # Create request
    db_request = InstructorAssignmentRequest(
        semester_id=request_data.semester_id,
        instructor_id=request_data.instructor_id,
        requested_by=current_user.id,
        request_message=request_data.request_message,
        priority=request_data.priority,
        expires_at=request_data.expires_at,
        status=AssignmentRequestStatus.PENDING
    )

    db.add(db_request)
    db.commit()
    db.refresh(db_request)

    return db_request


@router.get("/requests/instructor/{instructor_id}", response_model=List[InstructorAssignmentRequestResponse])
def get_instructor_assignment_requests(
    instructor_id: int,
    status_filter: Optional[str] = Query(None, description="Filter by status: PENDING, ACCEPTED, DECLINED, etc."),
    specialization_type: Optional[str] = Query(None, description="Filter by specialization: LFA_PLAYER, GANCUJU, INTERNSHIP, COACH"),
    age_group: Optional[str] = Query(None, description="Filter by age group: PRE, YOUTH, ADULT, etc."),
    location_city: Optional[str] = Query(None, description="Filter by city: Budapest, Budaörs, etc."),
    priority_min: Optional[int] = Query(None, ge=1, le=10, description="Minimum priority (1-10)"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get all assignment requests for a specific instructor with advanced filtering.

    Instructors can only see their own requests, admins can see all.

    Filters available:
    - status_filter: PENDING, ACCEPTED, DECLINED, CANCELLED
    - specialization_type: LFA_PLAYER, GANCUJU, INTERNSHIP, COACH
    - age_group: PRE, YOUTH, ADULT, etc.
    - location_city: Budapest, Budaörs, etc.
    - priority_min: Only show requests with priority >= this value (1-10)
    """
    # Authorization
    if current_user.role != UserRole.ADMIN:
        if current_user.id != instructor_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only view your own assignment requests"
            )

    # Join with Semester table to enable filtering by semester fields
    query = db.query(InstructorAssignmentRequest).join(
        Semester,
        InstructorAssignmentRequest.semester_id == Semester.id
    ).filter(
        InstructorAssignmentRequest.instructor_id == instructor_id
    )

    # Apply status filter
    if status_filter:
        try:
            status_enum = AssignmentRequestStatus[status_filter.upper()]
            query = query.filter(InstructorAssignmentRequest.status == status_enum)
        except KeyError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid status: {status_filter}"
            )

    # Apply specialization filter
    if specialization_type:
        query = query.filter(Semester.specialization_type == specialization_type)

    # Apply age group filter
    if age_group:
        query = query.filter(Semester.age_group == age_group)

    # Apply location city filter
    if location_city:
        query = query.filter(Semester.location_city == location_city)

    # Apply priority filter
    if priority_min:
        query = query.filter(InstructorAssignmentRequest.priority >= priority_min)

    requests = query.order_by(
        InstructorAssignmentRequest.created_at.desc()
    ).all()

    return requests


@router.get("/requests/semester/{semester_id}", response_model=List[InstructorAssignmentRequestResponse])
def get_semester_assignment_requests(
    semester_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get all assignment requests for a specific semester (Admin only)"""
    # Authorization - only admins
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can view semester assignment requests"
        )

    requests = db.query(InstructorAssignmentRequest).filter(
        InstructorAssignmentRequest.semester_id == semester_id
    ).order_by(
        InstructorAssignmentRequest.priority.desc(),
        InstructorAssignmentRequest.created_at.desc()
    ).all()

    return requests


@router.patch("/requests/{request_id}/accept", response_model=InstructorAssignmentRequestResponse)
def accept_assignment_request(
    request_id: int,
    accept_data: InstructorAssignmentRequestAccept,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Instructor accepts an assignment request.

    When accepted:
    1. Request status → ACCEPTED
    2. semester.master_instructor_id = instructor.id
    """
    # Get the request
    assignment_request = db.query(InstructorAssignmentRequest).filter(
        InstructorAssignmentRequest.id == request_id
    ).first()

    if not assignment_request:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Assignment request not found"
        )

    # Authorization - only the instructor who received the request can accept
    if current_user.id != assignment_request.instructor_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only accept requests sent to you"
        )

    # Check if already processed
    if assignment_request.status != AssignmentRequestStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Request already processed with status: {assignment_request.status.value}"
        )

    # Update request
    assignment_request.status = AssignmentRequestStatus.ACCEPTED
    assignment_request.responded_at = datetime.utcnow()
    assignment_request.response_message = accept_data.response_message

    # Assign instructor to semester
    semester = db.query(Semester).filter(Semester.id == assignment_request.semester_id).first()
    if semester:
        semester.master_instructor_id = assignment_request.instructor_id

    db.commit()
    db.refresh(assignment_request)

    return assignment_request


@router.patch("/requests/{request_id}/decline", response_model=InstructorAssignmentRequestResponse)
def decline_assignment_request(
    request_id: int,
    decline_data: InstructorAssignmentRequestDecline,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Instructor declines an assignment request"""
    # Get the request
    assignment_request = db.query(InstructorAssignmentRequest).filter(
        InstructorAssignmentRequest.id == request_id
    ).first()

    if not assignment_request:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Assignment request not found"
        )

    # Authorization - only the instructor who received the request can decline
    if current_user.id != assignment_request.instructor_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only decline requests sent to you"
        )

    # Check if already processed
    if assignment_request.status != AssignmentRequestStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Request already processed with status: {assignment_request.status.value}"
        )

    # Update request
    assignment_request.status = AssignmentRequestStatus.DECLINED
    assignment_request.responded_at = datetime.utcnow()
    assignment_request.response_message = decline_data.response_message

    db.commit()
    db.refresh(assignment_request)

    return assignment_request


@router.patch("/requests/{request_id}/cancel", response_model=InstructorAssignmentRequestResponse)
def cancel_assignment_request(
    request_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Admin cancels an assignment request (before instructor responds)"""
    # Authorization - only admins
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can cancel assignment requests"
        )

    # Get the request
    assignment_request = db.query(InstructorAssignmentRequest).filter(
        InstructorAssignmentRequest.id == request_id
    ).first()

    if not assignment_request:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Assignment request not found"
        )

    # Can only cancel pending requests
    if assignment_request.status != AssignmentRequestStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Cannot cancel request with status: {assignment_request.status.value}"
        )

    # Cancel
    assignment_request.status = AssignmentRequestStatus.CANCELLED
    assignment_request.responded_at = datetime.utcnow()

    db.commit()
    db.refresh(assignment_request)

    return assignment_request


# ============================================================================
# Helper Endpoints
# ============================================================================

@router.get("/available-instructors", response_model=List[AvailableInstructorInfo])
def get_available_instructors(
    year: int = Query(..., ge=2024, le=2100),
    time_period: str = Query(..., max_length=10),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Find instructors available for a specific time period (Admin only).

    Location is NOT part of availability - it comes from the assignment request!
    Used by admins when creating semesters to see which instructors can be assigned.
    """
    # Authorization - only admins
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can view available instructors"
        )

    # Find availability windows matching criteria (NO location filter!)
    windows = db.query(InstructorAvailabilityWindow).filter(
        InstructorAvailabilityWindow.year == year,
        InstructorAvailabilityWindow.time_period == time_period,
        InstructorAvailabilityWindow.is_available == True
    ).options(
        joinedload(InstructorAvailabilityWindow.instructor)
    ).all()

    # Group by instructor
    instructor_map = {}
    for window in windows:
        instructor_id = window.instructor_id
        if instructor_id not in instructor_map:
            # Get instructor's ACTIVE licenses only (is_active=True)
            user_licenses = db.query(UserLicense).filter(
                UserLicense.user_id == instructor_id,
                UserLicense.is_active == True
            ).all()

            # Convert to InstructorLicenseInfo objects
            license_infos = [
                InstructorLicenseInfo(
                    license_id=lic.id,
                    specialization_type=lic.specialization_type,
                    current_level=lic.current_level,
                    max_achieved_level=lic.max_achieved_level,
                    started_at=lic.started_at,
                    last_advanced_at=lic.last_advanced_at
                )
                for lic in user_licenses
            ]

            instructor_map[instructor_id] = AvailableInstructorInfo(
                instructor_id=instructor_id,
                instructor_name=window.instructor.name,
                instructor_email=window.instructor.email,
                availability_windows=[],
                licenses=license_infos
            )

        instructor_map[instructor_id].availability_windows.append(window)

    return list(instructor_map.values())

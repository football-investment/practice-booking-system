from typing import List
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from ....database import get_db
from ....dependencies import get_current_user
from ....models.user import User, UserRole
from ....models.quiz import QuizCategory, QuizDifficulty
from ....services.quiz_service import QuizService
from ....services.competency_service import CompetencyService
from ....services.adaptive_learning_service import AdaptiveLearningService
from ....schemas.quiz import (
    QuizCreate, QuizUpdate, QuizResponse, QuizListItem, QuizPublic,
    QuizAttemptStart, QuizAttemptSubmit, QuizAttemptResponse, QuizAttemptSummary,
    UserQuizStatistics, QuizStatistics, QuizDashboardOverview, QuizCategoryProgress
)

router = APIRouter()

def get_quiz_service(db: Session = Depends(get_db)) -> QuizService:
    return QuizService(db)

# Public quiz endpoints (for students)

@router.get("/available", response_model=List[QuizListItem])
def get_available_quizzes(
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service)
):
    """Get all quizzes available for the current user (not yet completed)"""
    if current_user.role != UserRole.STUDENT:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only students can access quizzes"
        )
    
    quizzes = quiz_service.get_available_quizzes(current_user.id)
    
    return [
        QuizListItem(
            id=quiz.id,
            title=quiz.title,
            description=quiz.description,
            category=quiz.category,
            difficulty=quiz.difficulty,
            time_limit_minutes=quiz.time_limit_minutes,
            xp_reward=quiz.xp_reward,
            question_count=len(quiz.questions),
            is_active=quiz.is_active,
            created_at=quiz.created_at
        )
        for quiz in quizzes
    ]

@router.get("/category/{category}", response_model=List[QuizListItem])
def get_quizzes_by_category(
    category: QuizCategory,
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service)
):
    """Get all quizzes in a specific category"""
    if current_user.role != UserRole.STUDENT:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only students can access quizzes"
        )
    
    quizzes = quiz_service.get_quizzes_by_category(category)
    
    return [
        QuizListItem(
            id=quiz.id,
            title=quiz.title,
            description=quiz.description,
            category=quiz.category,
            difficulty=quiz.difficulty,
            time_limit_minutes=quiz.time_limit_minutes,
            xp_reward=quiz.xp_reward,
            question_count=len(quiz.questions),
            is_active=quiz.is_active,
            created_at=quiz.created_at
        )
        for quiz in quizzes
    ]

@router.get("/{quiz_id}", response_model=QuizPublic)
def get_quiz_for_taking(
    quiz_id: int,
    session_id: int = None,  # Optional session_id for session-based quizzes
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service),
    db: Session = Depends(get_db)
):
    """
    Get quiz details for taking (without correct answers)

    üîí RULE #5: For hybrid/virtual sessions, quiz is only available during session time
    """
    if current_user.role != UserRole.STUDENT:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only students can take quizzes"
        )

    # üîí RULE #5: Validate session-based quiz access (hybrid/virtual only)
    if session_id:
        from ....models.session import SessionTypel
        from datetime import datetime, timezone

        session = db.query(SessionTypel).filter(SessionTypel.id == session_id).first()
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Session not found"
            )

        # Check if session is hybrid or virtual (quiz-enabled)
        if session.sport_type not in ["HYBRID", "VIRTUAL"]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Quizzes are only available for HYBRID and VIRTUAL sessions"
            )

        # Check if quiz is unlocked by instructor
        if not session.quiz_unlocked:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Quiz has not been unlocked by the instructor yet"
            )

        # Check if current time is within session time window
        current_time = datetime.now(timezone.utc).replace(tzinfo=None)
        session_start_naive = session.date_start.replace(tzinfo=None) if session.date_start.tzinfo else session.date_start
        session_end_naive = session.date_end.replace(tzinfo=None) if session.date_end.tzinfo else session.date_end

        if current_time < session_start_naive:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Quiz is not available yet. Session has not started."
            )

        if current_time > session_end_naive:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Quiz is no longer available. Session has ended."
            )

    # Check if quiz is already completed
    if quiz_service.is_quiz_completed_by_user(current_user.id, quiz_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Quiz already completed"
        )

    quiz = quiz_service.get_quiz_by_id(quiz_id)
    if not quiz or not quiz.is_active:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quiz not found or inactive"
        )

    # üîí ACCESS CONTROL: Check if quiz is linked to a session (HYBRID or VIRTUAL)
    from ....models.quiz import SessionQuiz
    from ....models.session import Session as SessionModel, SessionType
    from ....models.attendance import Attendance, AttendanceStatus
    from ....models.booking import Booking, BookingStatus
    from datetime import datetime, timezone

    session_quiz = db.query(SessionQuiz).filter(
        SessionQuiz.quiz_id == quiz_id,
        SessionQuiz.is_required == True
    ).first()

    if session_quiz:
        # Quiz is linked to a session - apply session-specific access control
        session = db.query(SessionModel).filter(
            SessionModel.id == session_quiz.session_id
        ).first()

        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Associated session not found"
            )

        # Check if user has a CONFIRMED booking for this session
        booking = db.query(Booking).filter(
            Booking.user_id == current_user.id,
            Booking.session_id == session.id,
            Booking.status == BookingStatus.CONFIRMED
        ).first()

        if not booking:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You must have a confirmed booking for this session to access the quiz"
            )

        # üéØ HYBRID Session: Check attendance + quiz unlock
        if session.session_type == SessionType.hybrid:
            # 1. Check if quiz is unlocked by instructor
            if not session.quiz_unlocked:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Quiz is not yet unlocked by the instructor. Please wait for the instructor to unlock it during the session."
                )

            # 2. Check if user is marked present on attendance sheet
            attendance = db.query(Attendance).filter(
                Attendance.user_id == current_user.id,
                Attendance.session_id == session.id,
                Attendance.status == AttendanceStatus.present
            ).first()

            if not attendance:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You must be marked present on the attendance sheet to access the quiz"
                )

        # üåê VIRTUAL Session: Check time window
        elif session.session_type == SessionType.virtual:
            current_time = datetime.now()

            # Session must be active (within date_start and date_end)
            if current_time < session.date_start:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Quiz is not yet available. Session starts at {session.date_start.isoformat()}"
                )

            if current_time > session.date_end:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Quiz is no longer available. Session has ended."
                )

    return quiz

@router.post("/start", response_model=QuizAttemptResponse)
def start_quiz_attempt(
    attempt_data: QuizAttemptStart,
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service),
    db: Session = Depends(get_db)
):
    """Start a new quiz attempt"""
    if current_user.role != UserRole.STUDENT:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only students can take quizzes"
        )

    # üîí ACCESS CONTROL: Same checks as get_quiz_for_taking
    from ....models.quiz import SessionQuiz
    from ....models.session import Session as SessionModel, SessionType
    from ....models.attendance import Attendance, AttendanceStatus
    from ....models.booking import Booking, BookingStatus
    from datetime import datetime, timezone

    session_quiz = db.query(SessionQuiz).filter(
        SessionQuiz.quiz_id == attempt_data.quiz_id,
        SessionQuiz.is_required == True
    ).first()

    if session_quiz:
        # Quiz is linked to a session - apply session-specific access control
        session = db.query(SessionModel).filter(
            SessionModel.id == session_quiz.session_id
        ).first()

        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Associated session not found"
            )

        # Check if user has a CONFIRMED booking for this session
        booking = db.query(Booking).filter(
            Booking.user_id == current_user.id,
            Booking.session_id == session.id,
            Booking.status == BookingStatus.CONFIRMED
        ).first()

        if not booking:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You must have a confirmed booking for this session to start the quiz"
            )

        # üéØ HYBRID Session: Check attendance + quiz unlock
        if session.session_type == SessionType.hybrid:
            # 1. Check if quiz is unlocked by instructor
            if not session.quiz_unlocked:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Quiz is not yet unlocked by the instructor. Please wait for the instructor to unlock it during the session."
                )

            # 2. Check if user is marked present on attendance sheet
            attendance = db.query(Attendance).filter(
                Attendance.user_id == current_user.id,
                Attendance.session_id == session.id,
                Attendance.status == AttendanceStatus.present
            ).first()

            if not attendance:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You must be marked present on the attendance sheet to start the quiz"
                )

        # üåê VIRTUAL Session: Check time window
        elif session.session_type == SessionType.virtual:
            current_time = datetime.now()

            # Session must be active (within date_start and date_end)
            if current_time < session.date_start:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Quiz is not yet available. Session starts at {session.date_start.isoformat()}"
                )

            if current_time > session.date_end:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Quiz is no longer available. Session has ended."
                )

    try:
        attempt = quiz_service.start_quiz_attempt(current_user.id, attempt_data.quiz_id)
        return attempt
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )

@router.post("/submit", response_model=QuizAttemptResponse)
def submit_quiz_attempt(
    submission: QuizAttemptSubmit,
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service),
    db: Session = Depends(get_db)
):
    """Submit quiz attempt with answers"""
    if current_user.role != UserRole.STUDENT:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only students can take quizzes"
        )

    try:
        # Submit quiz and get results
        attempt = quiz_service.submit_quiz_attempt(current_user.id, submission)

        # ==========================================
        # üÜï HOOK 1: AUTOMATIC COMPETENCY ASSESSMENT
        # ==========================================
        # Use SEPARATE session to avoid transaction conflicts
        from ....database import SessionLocal
        hook_db = None

        try:
            # Create new session for hooks
            hook_db = SessionLocal()

            # Initialize services with separate session
            comp_service = CompetencyService(hook_db)
            adapt_service = AdaptiveLearningService(hook_db)

            # Get quiz details for competency assessment
            quiz = quiz_service.get_quiz_by_id(attempt.quiz_id)

            # Assess competency from quiz (automatic based on quiz category/metadata)
            if quiz and attempt.score is not None:
                comp_service.assess_from_quiz(
                    user_id=current_user.id,
                    quiz_id=quiz.id,
                    quiz_attempt_id=attempt.id,
                    score=float(attempt.score)
                )

            # Update adaptive learning profile
            adapt_service.update_profile_metrics(current_user.id)

            # Generate new recommendations if score is low (struggling student)
            if attempt.score and attempt.score < 70:
                adapt_service.generate_recommendations(
                    user_id=current_user.id,
                    refresh=True
                )

            # Commit hook transaction
            hook_db.commit()

        except Exception as e:
            # Log error but don't fail quiz submission
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"Error in post-quiz hooks for user {current_user.id}: {e}")
            if hook_db:
                hook_db.rollback()
            # Continue with quiz result response

        finally:
            # Always close the hook session
            if hook_db:
                hook_db.close()

        # ==========================================
        # üèÜ GAMIFICATION: Check for achievement unlocks
        # ==========================================
        from ....services.gamification import GamificationService
        gamification_service = GamificationService(db)
        try:
            # Check for quiz completion achievement
            unlocked = gamification_service.check_and_unlock_achievements(
                user_id=current_user.id,
                trigger_action="complete_quiz"
            )

            # Check for perfect score achievement if score is 100%
            if attempt.score and attempt.score >= 100:
                perfect_score_unlocked = gamification_service.check_and_unlock_achievements(
                    user_id=current_user.id,
                    trigger_action="quiz_perfect_score",
                    context={"score": attempt.score}
                )
                unlocked.extend(perfect_score_unlocked)

            if unlocked:
                print(f"üéâ Unlocked {len(unlocked)} achievement(s) for user {current_user.id}")
        except Exception as e:
            # Don't fail quiz submission if achievement check fails
            print(f"‚ö†Ô∏è  Achievement check failed: {e}")

        # ==========================================
        # üÜï AUTOMATIC ATTENDANCE FOR VIRTUAL SESSIONS
        # ==========================================
        # If this quiz is linked to a VIRTUAL session, mark automatic attendance
        try:
            from ....models.quiz import SessionQuiz
            from ....models.session import Session as SessionModel
            from ....models.attendance import Attendance
            from datetime import datetime, timezone

            # Find if this quiz is linked to any session
            session_quiz = db.query(SessionQuiz).filter(
                SessionQuiz.quiz_id == attempt.quiz_id,
                SessionQuiz.is_required == True
            ).first()

            if session_quiz:
                # Get the session
                session = db.query(SessionModel).filter(
                    SessionModel.id == session_quiz.session_id
                ).first()

                # If VIRTUAL session ‚Üí automatic attendance
                if session and str(session.session_type).lower() == 'virtual':
                    # Check if attendance already exists
                    existing_attendance = db.query(Attendance).filter(
                        Attendance.user_id == current_user.id,
                        Attendance.session_id == session.id
                    ).first()

                    if existing_attendance:
                        # Update to present + auto-confirm (VIRTUAL sessions don't need manual confirmation)
                        from ....models.attendance import AttendanceStatus, ConfirmationStatus
                        existing_attendance.status = AttendanceStatus.present
                        existing_attendance.check_in_time = datetime.now(timezone.utc)
                        existing_attendance.confirmation_status = ConfirmationStatus.confirmed
                        existing_attendance.student_confirmed_at = datetime.now(timezone.utc)
                        existing_attendance.notes = f"Auto-marked: Quiz completed with {attempt.score}%"
                        db.commit()

                        # Award XP
                        gamification_service.award_attendance_xp(
                            attendance_id=existing_attendance.id,
                            quiz_score_percent=attempt.score
                        )

                        print(f"‚úÖ AUTO-ATTENDANCE: {current_user.email} marked present + auto-confirmed for VIRTUAL session: {session.title}")
                    else:
                        # Create new attendance record with auto-confirmation
                        from ....models.attendance import AttendanceStatus, ConfirmationStatus
                        new_attendance = Attendance(
                            user_id=current_user.id,
                            session_id=session.id,
                            status=AttendanceStatus.present,
                            check_in_time=datetime.now(timezone.utc),
                            confirmation_status=ConfirmationStatus.confirmed,
                            student_confirmed_at=datetime.now(timezone.utc),
                            notes=f"Auto-marked: Quiz completed with {attempt.score}%"
                        )
                        db.add(new_attendance)
                        db.commit()
                        db.refresh(new_attendance)

                        # Award XP
                        gamification_service.award_attendance_xp(
                            attendance_id=new_attendance.id,
                            quiz_score_percent=attempt.score
                        )

                        print(f"‚úÖ AUTO-ATTENDANCE: Created + auto-confirmed attendance for {current_user.email} for VIRTUAL session: {session.title}")

        except Exception as e:
            # Don't fail quiz submission if auto-attendance fails
            print(f"‚ö†Ô∏è  Auto-attendance failed: {e}")
            db.rollback()

        return attempt
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )

@router.get("/attempts/my", response_model=List[QuizAttemptSummary])
def get_my_quiz_attempts(
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service)
):
    """Get current user's quiz attempts"""
    attempts = quiz_service.get_user_quiz_attempts(current_user.id)
    
    return [
        QuizAttemptSummary(
            id=attempt.id,
            quiz_title=quiz_service.get_quiz_by_id(attempt.quiz_id).title,
            quiz_category=quiz_service.get_quiz_by_id(attempt.quiz_id).category,
            started_at=attempt.started_at,
            completed_at=attempt.completed_at,
            score=attempt.score,
            passed=attempt.passed,
            xp_awarded=attempt.xp_awarded,
            time_spent_minutes=attempt.time_spent_minutes
        )
        for attempt in attempts
    ]

@router.get("/statistics/my", response_model=UserQuizStatistics)
def get_my_quiz_statistics(
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service)
):
    """Get current user's quiz statistics"""
    return quiz_service.get_user_quiz_statistics(current_user.id)

@router.get("/dashboard/overview", response_model=QuizDashboardOverview)
def get_quiz_dashboard_overview(
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service)
):
    """Get quiz dashboard overview for student"""
    if current_user.role != UserRole.STUDENT:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only students can access quiz dashboard"
        )
    
    available_quizzes = quiz_service.get_available_quizzes(current_user.id)
    attempts = quiz_service.get_user_quiz_attempts(current_user.id)
    stats = quiz_service.get_user_quiz_statistics(current_user.id)
    
    completed_quizzes = len([a for a in attempts if a.completed_at])
    total_xp = sum([a.xp_awarded for a in attempts])
    
    recent_attempts = [
        QuizAttemptSummary(
            id=attempt.id,
            quiz_title=quiz_service.get_quiz_by_id(attempt.quiz_id).title,
            quiz_category=quiz_service.get_quiz_by_id(attempt.quiz_id).category,
            started_at=attempt.started_at,
            completed_at=attempt.completed_at,
            score=attempt.score,
            passed=attempt.passed,
            xp_awarded=attempt.xp_awarded,
            time_spent_minutes=attempt.time_spent_minutes
        )
        for attempt in attempts[:5]  # Last 5 attempts
    ]
    
    return QuizDashboardOverview(
        available_quizzes=len(available_quizzes),
        completed_quizzes=completed_quizzes,
        total_xp_from_quizzes=total_xp,
        best_category=stats.favorite_category,
        recent_attempts=recent_attempts
    )

# Admin/Instructor endpoints

@router.post("/", response_model=QuizResponse)
def create_quiz(
    quiz_data: QuizCreate,
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service)
):
    """Create a new quiz (instructors/admins only)"""
    if current_user.role not in [UserRole.INSTRUCTOR, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only instructors and admins can create quizzes"
        )
    
    quiz = quiz_service.create_quiz(quiz_data)
    return quiz

@router.get("/admin/{quiz_id}", response_model=QuizResponse)
def get_quiz_admin(
    quiz_id: int,
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service)
):
    """Get quiz with all details including correct answers (admin view)"""
    if current_user.role not in [UserRole.INSTRUCTOR, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only instructors and admins can view quiz details"
        )
    
    quiz = quiz_service.get_quiz_by_id(quiz_id)
    if not quiz:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quiz not found"
        )
    
    return quiz

@router.get("/admin/all", response_model=List[QuizListItem])
def get_all_quizzes_admin(
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service),
    db: Session = Depends(get_db)
):
    """Get all quizzes for admin/instructor management"""
    if current_user.role not in [UserRole.INSTRUCTOR, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only instructors and admins can manage quizzes"
        )
    
    from app.models.quiz import Quiz
    quizzes = db.query(Quiz).order_by(Quiz.category, Quiz.title).all()
    
    return [
        QuizListItem(
            id=quiz.id,
            title=quiz.title,
            description=quiz.description,
            category=quiz.category,
            difficulty=quiz.difficulty,
            time_limit_minutes=quiz.time_limit_minutes,
            xp_reward=quiz.xp_reward,
            question_count=len(quiz.questions),
            is_active=quiz.is_active,
            created_at=quiz.created_at
        )
        for quiz in quizzes
    ]

@router.get("/statistics/{quiz_id}", response_model=QuizStatistics)
def get_quiz_statistics(
    quiz_id: int,
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service)
):
    """Get statistics for a specific quiz"""
    if current_user.role not in [UserRole.INSTRUCTOR, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only instructors and admins can view quiz statistics"
        )
    
    return quiz_service.get_quiz_statistics(quiz_id)

@router.get("/leaderboard/{quiz_id}")
def get_quiz_leaderboard(
    quiz_id: int,
    current_user: User = Depends(get_current_user),
    quiz_service: QuizService = Depends(get_quiz_service)
):
    """Get leaderboard for a specific quiz"""
    if current_user.role not in [UserRole.INSTRUCTOR, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only instructors and admins can view leaderboards"
        )
    
    return quiz_service.get_quiz_leaderboard(quiz_id)
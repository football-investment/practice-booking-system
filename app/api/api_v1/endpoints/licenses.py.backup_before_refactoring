"""
üèÆ GƒÅnCuju‚Ñ¢Ô∏è¬©Ô∏è License API Endpoints
Marketing-oriented license progression system API
"""
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session
from typing import List, Dict, Any, Optional

from ....database import get_db
from ....services.license_service import LicenseService
from ....services.progress_license_sync_service import ProgressLicenseSyncService
from ....services.audit_service import AuditService
from ....dependencies import get_current_user, get_current_admin_user_web
from ....models.user import User, UserRole
from ....models.audit_log import AuditAction

router = APIRouter()


@router.get("/metadata", response_model=List[Dict[str, Any]])
async def get_license_metadata(
    specialization: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    Get license metadata for all specializations or a specific one

    - **specialization**: Optional filter by COACH, PLAYER, or INTERNSHIP
    """
    license_service = LicenseService(db)
    return license_service.get_all_license_metadata(specialization)


@router.get("/metadata/{specialization}", response_model=List[Dict[str, Any]])
async def get_license_metadata_by_specialization(
    specialization: str,
    db: Session = Depends(get_db)
):
    """
    Get license metadata for a specific specialization (path parameter)

    - **specialization**: COACH, PLAYER, or INTERNSHIP
    """
    license_service = LicenseService(db)
    return license_service.get_all_license_metadata(specialization)


@router.get("/metadata/{specialization}/{level}", response_model=Dict[str, Any])
async def get_license_level_metadata(
    specialization: str,
    level: int,
    db: Session = Depends(get_db)
):
    """
    Get specific license level metadata with marketing content
    
    - **specialization**: COACH, PLAYER, or INTERNSHIP
    - **level**: License level number (1-8 for Coach/Player, 1-5 for Internship)
    """
    license_service = LicenseService(db)
    metadata = license_service.get_license_metadata_by_level(specialization, level)
    
    if not metadata:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"License level {level} not found for {specialization}"
        )
    
    return metadata


@router.get("/progression/{specialization}", response_model=List[Dict[str, Any]])
async def get_specialization_progression(
    specialization: str,
    db: Session = Depends(get_db)
):
    """
    Get complete progression path for a specialization
    
    - **specialization**: COACH, PLAYER, or INTERNSHIP
    """
    license_service = LicenseService(db)
    return license_service.get_specialization_progression_path(specialization)


@router.get("/my-licenses", response_model=List[Dict[str, Any]])
async def get_my_licenses(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get all licenses for the current user
    """
    license_service = LicenseService(db)
    return license_service.get_user_licenses(current_user.id)


@router.get("/me", response_model=List[Dict[str, Any]])
async def get_my_licenses_short(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get all licenses for the current user (short URL)
    """
    license_service = LicenseService(db)
    return license_service.get_user_licenses(current_user.id)


@router.get("/dashboard", response_model=Dict[str, Any])
async def get_license_dashboard(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get comprehensive license dashboard for the current user
    """
    license_service = LicenseService(db)
    return license_service.get_user_license_dashboard(current_user.id)


@router.post("/advance", response_model=Dict[str, Any])
async def advance_license(
    data: Dict[str, Any],
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Request license advancement (requires instructor approval for actual advancement)
    
    Request body:
    - **specialization**: COACH, PLAYER, or INTERNSHIP
    - **target_level**: Desired level number
    - **reason**: Reason for advancement request
    """
    required_fields = ['specialization', 'target_level']
    for field in required_fields:
        if field not in data:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Missing required field: {field}"
            )
    
    license_service = LicenseService(db)
    
    # For now, allow self-advancement for testing
    # In production, this would create an advancement request
    result = license_service.advance_license(
        user_id=current_user.id,
        specialization=data['specialization'],
        target_level=data['target_level'],
        advanced_by=current_user.id,  # Would be instructor in production
        reason=data.get('reason', 'Self-advancement request'),
        requirements_met=data.get('requirements_met', 'Auto-approved for testing')
    )

    # üîç AUDIT: Log license advancement
    audit_service = AuditService(db)
    audit_service.log(
        action=AuditAction.LICENSE_UPGRADE_APPROVED,
        user_id=current_user.id,
        resource_type="license",
        resource_id=None,  # License progression doesn't have individual license IDs
        details={
            "specialization": data['specialization'],
            "target_level": data['target_level'],
            "reason": data.get('reason'),
            "success": result.get('success', False)
        }
    )

    # üèÜ GAMIFICATION: Check for achievement unlocks
    if result.get('success'):
        from app.services.gamification import GamificationService
        gamification_service = GamificationService(db)
        try:
            # Check for level-up achievements
            unlocked = gamification_service.check_and_unlock_achievements(
                user_id=current_user.id,
                trigger_action="reach_level",
                context={"level": data['target_level']}
            )

            # Also check for first license achievement (if level 1)
            if data['target_level'] == 1:
                first_license_unlocked = gamification_service.check_and_unlock_achievements(
                    user_id=current_user.id,
                    trigger_action="license_earned"
                )
                unlocked.extend(first_license_unlocked)

            if unlocked:
                print(f"üéâ Unlocked {len(unlocked)} achievement(s) for user {current_user.id}")
                # Optionally add to response
                result['achievements_unlocked'] = [
                    {"code": a.code, "name": a.name, "xp": a.xp_reward}
                    for a in unlocked
                ]
        except Exception as e:
            # Don't fail advancement if achievement check fails
            print(f"‚ö†Ô∏è  Achievement check failed: {e}")

    return result


@router.get("/requirements/{specialization}/{level}", response_model=Dict[str, Any])
async def check_advancement_requirements(
    specialization: str,
    level: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Check if user meets requirements for license advancement
    
    - **specialization**: COACH, PLAYER, or INTERNSHIP
    - **level**: Target level number
    """
    license_service = LicenseService(db)
    return license_service.get_license_requirements_check(
        current_user.id, specialization, level
    )


@router.get("/marketing/{specialization}", response_model=Dict[str, Any])
async def get_marketing_content(
    specialization: str,
    level: Optional[int] = None,
    db: Session = Depends(get_db)
):
    """
    Get marketing content for license levels
    
    - **specialization**: COACH, PLAYER, or INTERNSHIP
    - **level**: Optional specific level, if omitted returns all levels
    """
    license_service = LicenseService(db)
    return license_service.get_marketing_content(specialization, level)


# Instructor-only endpoints
@router.post("/instructor/advance", response_model=Dict[str, Any])
async def instructor_advance_license(
    data: Dict[str, Any],
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Instructor-approved license advancement
    
    Request body:
    - **user_id**: ID of user to advance
    - **specialization**: COACH, PLAYER, or INTERNSHIP
    - **target_level**: Desired level number
    - **reason**: Reason for advancement
    - **requirements_met**: Description of requirements satisfied
    """
    # Check instructor permissions
    if current_user.role != UserRole.INSTRUCTOR:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only instructors can approve license advancements"
        )
    
    required_fields = ['user_id', 'specialization', 'target_level']
    for field in required_fields:
        if field not in data:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Missing required field: {field}"
            )
    
    license_service = LicenseService(db)
    result = license_service.advance_license(
        user_id=data['user_id'],
        specialization=data['specialization'],
        target_level=data['target_level'],
        advanced_by=current_user.id,
        reason=data.get('reason', 'Instructor approved advancement'),
        requirements_met=data.get('requirements_met', 'Requirements verified by instructor')
    )
    
    return result


@router.get("/instructor/users/{user_id}/licenses", response_model=List[Dict[str, Any]])
async def get_user_licenses_by_instructor(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get license information for a specific user (instructor only)
    """
    if current_user.role != UserRole.INSTRUCTOR:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only instructors can view other users' licenses"
        )
    
    license_service = LicenseService(db)
    return license_service.get_user_licenses(user_id)


@router.get("/instructor/dashboard/{user_id}", response_model=Dict[str, Any])
async def get_user_license_dashboard_by_instructor(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get license dashboard for a specific user (instructor only)
    """
    if current_user.role != UserRole.INSTRUCTOR:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only instructors can view other users' license dashboards"
        )

    license_service = LicenseService(db)
    return license_service.get_user_license_dashboard(user_id)


@router.get("/instructor/{instructor_id}/teachable-specializations", response_model=List[str])
async def get_instructor_teachable_specializations(
    instructor_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get list of semester specialization types that an instructor can teach based on their licenses

    Returns list of specialization types like:
    - LFA_PLAYER_PRE, LFA_PLAYER_YOUTH (if has COACH license)
    - INTERNSHIP (if has INTERNSHIP license)
    - GANCUJU_PLAYER (if has PLAYER license with GANCUJU specialization)
    """
    # Authorization: instructors can only view their own, admins can view anyone's
    if current_user.role != UserRole.ADMIN and current_user.id != instructor_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only view your own teachable specializations"
        )

    # Get instructor's active licenses
    from ....models.license import UserLicense
    licenses = db.query(UserLicense).filter(
        UserLicense.user_id == instructor_id,
        UserLicense.is_active == True
    ).all()

    if not licenses:
        return []

    # Map licenses to semester specialization types they can teach
    teachable_specs = set()

    for license in licenses:
        if license.specialization_type == "COACH":
            # COACH license ‚Üí can teach all LFA_PLAYER_* semesters
            teachable_specs.add("LFA_PLAYER_PRE")
            teachable_specs.add("LFA_PLAYER_YOUTH")
            teachable_specs.add("LFA_PLAYER_AMATEUR")
            teachable_specs.add("LFA_PLAYER_PRO")

        elif license.specialization_type == "INTERNSHIP":
            # INTERNSHIP license ‚Üí can teach INTERNSHIP semesters
            teachable_specs.add("INTERNSHIP")

        elif license.specialization_type == "PLAYER":
            # PLAYER license ‚Üí can teach GANCUJU_PLAYER semesters (?)
            # Note: Need to clarify this mapping
            teachable_specs.add("GANCUJU_PLAYER")

    return sorted(list(teachable_specs))


# üîÑ P0 CRITICAL: Progress-License Synchronization Endpoints

@router.get("/admin/sync/desync-issues", response_model=List[Dict[str, Any]])
async def get_desync_issues(
    specialization: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Find all users with desync issues between SpecializationProgress and UserLicense

    **Admin/Instructor only**

    - **specialization**: Optional filter for COACH, PLAYER, or INTERNSHIP

    Returns list of users with:
    - Different levels between Progress and License
    - Progress without License
    - License without Progress
    """
    if current_user.role not in [UserRole.ADMIN, UserRole.INSTRUCTOR]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins and instructors can view sync issues"
        )

    sync_service = ProgressLicenseSyncService(db)
    return sync_service.find_desync_issues(specialization)


@router.post("/admin/sync/user/{user_id}", response_model=Dict[str, Any])
async def sync_user_progress_license(
    user_id: int,
    data: Dict[str, Any],
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Sync Progress and License for a specific user

    **Admin/Instructor only**

    Request body:
    - **specialization**: COACH, PLAYER, or INTERNSHIP
    - **direction**: "progress_to_license" or "license_to_progress"

    Use cases:
    - **progress_to_license**: Student leveled up via gameplay, sync license
    - **license_to_progress**: Admin manually advanced license, sync progress
    """
    if current_user.role not in [UserRole.ADMIN, UserRole.INSTRUCTOR]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins and instructors can sync progress"
        )

    if 'specialization' not in data:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Missing required field: specialization"
        )

    direction = data.get('direction', 'progress_to_license')
    if direction not in ['progress_to_license', 'license_to_progress']:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Direction must be 'progress_to_license' or 'license_to_progress'"
        )

    sync_service = ProgressLicenseSyncService(db)

    if direction == 'progress_to_license':
        result = sync_service.sync_progress_to_license(
            user_id=user_id,
            specialization=data['specialization'],
            synced_by=current_user.id
        )
    else:
        result = sync_service.sync_license_to_progress(
            user_id=user_id,
            specialization=data['specialization']
        )

    return result


@router.post("/admin/sync/user/{user_id}/all", response_model=Dict[str, Any])
async def sync_user_all_specializations(
    user_id: int,
    data: Dict[str, Any],
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Sync all specializations for a specific user

    **Admin/Instructor only**

    Request body:
    - **direction**: "progress_to_license" or "license_to_progress" (default: progress_to_license)
    """
    if current_user.role not in [UserRole.ADMIN, UserRole.INSTRUCTOR]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins and instructors can sync progress"
        )

    direction = data.get('direction', 'progress_to_license')
    if direction not in ['progress_to_license', 'license_to_progress']:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Direction must be 'progress_to_license' or 'license_to_progress'"
        )

    sync_service = ProgressLicenseSyncService(db)
    return sync_service.sync_user_all_specializations(user_id, direction)


@router.post("/admin/sync/all", response_model=Dict[str, Any])
async def sync_all_users(
    data: Dict[str, Any],
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Auto-sync all users with desync issues

    **Admin only - Use with caution!**

    Request body:
    - **direction**: "progress_to_license" or "license_to_progress" (default: progress_to_license)
    - **dry_run**: If true, only report what would be synced (default: true)

    This endpoint is intended for:
    - Background job execution
    - Manual admin-triggered bulk sync
    - Data migration/cleanup
    """
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can perform bulk sync"
        )

    direction = data.get('direction', 'progress_to_license')
    dry_run = data.get('dry_run', True)  # Default to dry_run for safety

    if direction not in ['progress_to_license', 'license_to_progress']:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Direction must be 'progress_to_license' or 'license_to_progress'"
        )

    sync_service = ProgressLicenseSyncService(db)
    return sync_service.auto_sync_all(sync_direction=direction, dry_run=dry_run)


# üí≥ ADMIN: Payment Verification for UserLicenses

@router.post("/{license_id}/verify-payment", response_model=Dict[str, Any])
async def verify_license_payment(
    license_id: int,
    request: Request,
    db: Session = Depends(get_db),
    admin_user: User = Depends(get_current_admin_user_web)
):
    """
    Mark UserLicense payment as verified (Admin only - Web cookie auth)

    This is used when admin verifies that payment was received for a license
    BEFORE student creates a SemesterEnrollment request.
    """

    from ....models.license import UserLicense
    from datetime import datetime

    license = db.query(UserLicense).filter(UserLicense.id == license_id).first()

    if not license:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="License not found"
        )

    if license.payment_verified:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Payment already verified"
        )

    # Mark as verified
    license.payment_verified = True
    license.payment_verified_at = datetime.now()
    db.commit()

    # Log audit
    audit_service = AuditService(db)
    audit_service.log(
        action=AuditAction.PAYMENT_VERIFIED,
        user_id=admin_user.id,
        resource_type="user_license",
        resource_id=license_id,
        details={
            "payment_reference_code": license.payment_reference_code,
            "user_id": license.user_id,
            "specialization": license.specialization_type
        }
    )

    return {
        "success": True,
        "message": "Payment verified successfully",
        "license_id": license_id,
        "payment_verified_at": license.payment_verified_at.isoformat()
    }


@router.post("/{license_id}/unverify-payment", response_model=Dict[str, Any])
async def unverify_license_payment(
    license_id: int,
    request: Request,
    db: Session = Depends(get_db),
    admin_user: User = Depends(get_current_admin_user_web)
):
    """
    Remove payment verification from UserLicense (Admin only - Web cookie auth)

    This is used when admin needs to revert a payment verification.
    """

    from ....models.license import UserLicense

    license = db.query(UserLicense).filter(UserLicense.id == license_id).first()

    if not license:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="License not found"
        )

    if not license.payment_verified:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Payment is not verified"
        )

    # Remove verification
    license.payment_verified = False
    license.payment_verified_at = None
    db.commit()

    # Log audit
    audit_service = AuditService(db)
    audit_service.log(
        action=AuditAction.PAYMENT_UNVERIFIED,
        user_id=admin_user.id,
        resource_type="user_license",
        resource_id=license_id,
        details={
            "payment_reference_code": license.payment_reference_code,
            "user_id": license.user_id,
            "specialization": license.specialization_type
        }
    )

    return {
        "success": True,
        "message": "Payment verification removed",
        "license_id": license_id
    }


# ‚öΩ FOOTBALL SKILLS ENDPOINTS (LFA Player Specializations)

@router.get("/{license_id}/football-skills", response_model=Dict[str, Any])
async def get_football_skills(
    license_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get football skills for a specific license (LFA Player specializations only)

    Returns 6 skill percentages: heading, shooting, crossing, passing, dribbling, ball_control

    - **license_id**: UserLicense ID
    """
    from ....models.license import UserLicense
    from ....schemas.license import FootballSkillsResponse

    license = db.query(UserLicense).filter(UserLicense.id == license_id).first()

    if not license:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="License not found"
        )

    # Check permissions - user can view their own, instructors can view anyone's
    if license.user_id != current_user.id and current_user.role not in [UserRole.INSTRUCTOR, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only view your own skills"
        )

    # Check if this is an LFA Player specialization
    if not license.specialization_type.startswith("LFA_PLAYER_"):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Football skills are only available for LFA Player specializations, not {license.specialization_type}"
        )

    # Return skills or null if not yet set
    if not license.football_skills:
        return {
            "license_id": license_id,
            "specialization_type": license.specialization_type,
            "skills": None,
            "message": "Skills not yet assessed"
        }

    # Get instructor name who last updated
    updated_by_name = None
    if license.skills_updated_by:
        updater = db.query(User).filter(User.id == license.skills_updated_by).first()
        if updater:
            updated_by_name = updater.name

    return {
        "license_id": license_id,
        "specialization_type": license.specialization_type,
        "skills": license.football_skills,
        "skills_last_updated_at": license.skills_last_updated_at.isoformat() if license.skills_last_updated_at else None,
        "skills_updated_by_id": license.skills_updated_by,
        "skills_updated_by_name": updated_by_name
    }


@router.put("/{license_id}/football-skills", response_model=Dict[str, Any])
async def update_football_skills(
    license_id: int,
    skills_data: Dict[str, Any],
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Update football skills for a student (INSTRUCTOR ONLY)

    Updates 6 skill percentages (0-100): heading, shooting, crossing, passing, dribbling, ball_control

    Request body:
    - **heading**: 0-100
    - **shooting**: 0-100
    - **crossing**: 0-100
    - **passing**: 0-100
    - **dribbling**: 0-100
    - **ball_control**: 0-100
    - **instructor_notes**: Optional notes about the assessment
    """
    # Only instructors can update skills
    if current_user.role not in [UserRole.INSTRUCTOR, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only instructors can update football skills"
        )

    from ....models.license import UserLicense
    from ....schemas.license import FootballSkillsUpdate
    from datetime import datetime, timezone

    license = db.query(UserLicense).filter(UserLicense.id == license_id).first()

    if not license:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="License not found"
        )

    # Check if this is an LFA Player specialization
    if not license.specialization_type.startswith("LFA_PLAYER_"):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Football skills are only available for LFA Player specializations, not {license.specialization_type}"
        )

    # Validate all 6 skills are provided
    required_skills = ['heading', 'shooting', 'crossing', 'passing', 'dribbling', 'ball_control']
    for skill in required_skills:
        if skill not in skills_data:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Missing required skill: {skill}"
            )

        # Validate range 0-100
        value = skills_data[skill]
        if not isinstance(value, (int, float)) or value < 0 or value > 100:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Skill '{skill}' must be between 0 and 100, got {value}"
            )

    # Round to 1 decimal place and build skills dict
    skills_dict = {
        skill: round(float(skills_data[skill]), 1)
        for skill in required_skills
    }

    # Update license
    license.football_skills = skills_dict
    license.skills_last_updated_at = datetime.now(timezone.utc)
    license.skills_updated_by = current_user.id

    # Optional: update instructor_notes if provided
    if 'instructor_notes' in skills_data:
        license.instructor_notes = skills_data['instructor_notes']

    db.commit()
    db.refresh(license)

    # Log audit
    audit_service = AuditService(db)
    audit_service.log(
        action=AuditAction.UPDATE,
        user_id=current_user.id,
        resource_type="football_skills",
        resource_id=license_id,
        details={
            "student_id": license.user_id,
            "specialization": license.specialization_type,
            "skills": skills_dict,
            "instructor_notes": skills_data.get('instructor_notes')
        }
    )

    return {
        "success": True,
        "message": "Football skills updated successfully",
        "license_id": license_id,
        "skills": skills_dict,
        "updated_at": license.skills_last_updated_at.isoformat(),
        "updated_by": current_user.name
    }


@router.get("/user/{user_id}/football-skills", response_model=List[Dict[str, Any]])
async def get_user_all_football_skills(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get all football skills for a user across all their LFA Player licenses

    Returns array of licenses with skills for each LFA Player specialization
    """
    # Check permissions
    if user_id != current_user.id and current_user.role not in [UserRole.INSTRUCTOR, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only view your own skills"
        )

    from ....models.license import UserLicense

    # Get all LFA Player licenses for this user
    licenses = db.query(UserLicense).filter(
        UserLicense.user_id == user_id,
        UserLicense.specialization_type.like("LFA_PLAYER_%")
    ).all()

    # OPTIMIZED: Batch fetch all updaters to avoid N+1 query pattern (reduces N queries to 1)
    updater_ids = [lic.skills_updated_by for lic in licenses if lic.skills_updated_by]
    updaters = db.query(User).filter(User.id.in_(updater_ids)).all() if updater_ids else []
    updater_dict = {u.id: u for u in updaters}

    result = []
    for license in licenses:
        # OPTIMIZED: Use pre-fetched updater dictionary (no query in loop)
        updated_by_name = None
        if license.skills_updated_by:
            updater = updater_dict.get(license.skills_updated_by)
            if updater:
                updated_by_name = updater.name

        result.append({
            "license_id": license.id,
            "specialization_type": license.specialization_type,
            "current_level": license.current_level,
            "skills": license.football_skills,
            "skills_last_updated_at": license.skills_last_updated_at.isoformat() if license.skills_last_updated_at else None,
            "skills_updated_by_id": license.skills_updated_by,
            "skills_updated_by_name": updated_by_name
        })

    return result
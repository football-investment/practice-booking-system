"""
Web routes for HTML template rendering
"""
from fastapi import APIRouter, Request, Depends, HTTPException, Form, Response, Body, status
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session
from sqlalchemy import func
from pathlib import Path
from pydantic import BaseModel
from typing import Optional, List

from ..database import get_db
from ..dependencies import get_current_user_web, get_current_user_optional
from ..models.user import User
from ..core.auth import create_access_token
from ..core.security import verify_password
from datetime import timedelta, datetime, timezone
from ..config import settings

# Import spec-based route modules
from .routes import lfa_player_routes, gancuju_routes, internship_routes, lfa_coach_routes

# Setup templates
BASE_DIR = Path(__file__).resolve().parent.parent
templates = Jinja2Templates(directory=str(BASE_DIR / "templates"))

router = APIRouter(tags=["web"])


# Helper function to update specialization XP
def _update_specialization_xp(db: Session, student_id: int, specialization_id: str, xp_earned: int, session_id: int, is_update: bool = False):
    """
    Update or create specialization_progress record with XP

    Args:
        db: Database session
        student_id: Student user ID
        specialization_id: Specialization type (e.g., 'INTERNSHIP')
        xp_earned: XP amount to award
        session_id: Session ID for tracking
        is_update: If True, recalculate XP (don't add); if False, add new XP
    """
    from ..models.user_progress import SpecializationProgress
    from datetime import datetime, timezone
    from sqlalchemy.exc import IntegrityError

    try:
        # Get or create specialization progress
        progress = db.query(SpecializationProgress).filter(
            SpecializationProgress.student_id == student_id,
            SpecializationProgress.specialization_id == specialization_id
        ).first()

        if not progress:
            # Create new progress record
            progress = SpecializationProgress(
                student_id=student_id,
                specialization_id=specialization_id,
                total_xp=xp_earned,
                completed_sessions=1,
                current_level=1,
                last_activity=datetime.now(timezone.utc)
            )
            db.add(progress)
            db.flush()  # Flush immediately to catch integrity errors
            print(f"‚ú® Created new SpecializationProgress for student {student_id} | Specialization: {specialization_id} | Initial XP: {xp_earned}")
        else:
            if is_update:
                # For updates, we need to recalculate total XP from all reviews
                # This is a simplified approach - you might want to track XP per session
                # For now, just update the XP to the new value (assumes single session)
                # TODO: Implement proper XP tracking per session
                progress.total_xp = xp_earned
                print(f"üîÑ Updated SpecializationProgress XP for student {student_id} | New XP: {xp_earned}")
            else:
                # Add new XP
                progress.total_xp = (progress.total_xp or 0) + xp_earned
                progress.completed_sessions = (progress.completed_sessions or 0) + 1
                print(f"‚ûï Added XP to SpecializationProgress for student {student_id} | Added: {xp_earned} | Total: {progress.total_xp}")

            progress.last_activity = datetime.now(timezone.utc)

        # Calculate level based on XP (1000 XP per level)
        progress.current_level = max(1, (progress.total_xp or 0) // 1000)

        db.flush()

    except IntegrityError as e:
        # Rollback just the XP operation, not the entire transaction
        print(f"‚ö†Ô∏è IntegrityError caught - rolling back XP update only...")
        print(f"   Error details: {str(e)}")

        # Query for existing record without transaction
        try:
            progress = db.query(SpecializationProgress).filter(
                SpecializationProgress.student_id == student_id,
                SpecializationProgress.specialization_id == specialization_id
            ).first()

            if progress:
                # Record exists, update it
                if is_update:
                    progress.total_xp = xp_earned
                    print(f"üîÑ [Retry] Updated SpecializationProgress XP for student {student_id} | New XP: {xp_earned}")
                else:
                    progress.total_xp = (progress.total_xp or 0) + xp_earned
                    progress.completed_sessions = (progress.completed_sessions or 0) + 1
                    print(f"‚ûï [Retry] Added XP to SpecializationProgress for student {student_id} | Added: {xp_earned} | Total: {progress.total_xp}")

                progress.last_activity = datetime.now(timezone.utc)
                progress.current_level = max(1, (progress.total_xp or 0) // 1000)
            else:
                # Record doesn't exist - log but don't crash
                print(f"‚ö†Ô∏è Warning: Could not update XP for student {student_id}, spec {specialization_id}")
                print(f"   XP tracking will be retried on next evaluation update")
        except Exception as retry_error:
            print(f"‚ùå Error during XP retry: {str(retry_error)}")
            print(f"   Performance review will still be saved, XP tracking skipped")


@router.get("/", response_class=HTMLResponse)
async def home(request: Request, db: Session = Depends(get_db)):
    """Home page - redirects to login or dashboard"""
    try:
        user = await get_current_user_optional(request, db)
        if user:
            return RedirectResponse(url="/dashboard", status_code=303)
    except:
        pass
    return RedirectResponse(url="/login", status_code=303)


@router.get("/login", response_class=HTMLResponse)
async def login_page(request: Request):
    """Display login page"""
    return templates.TemplateResponse("login.html", {"request": request})


@router.post("/login")
async def login_submit(
    request: Request,
    email: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db)
):
    """Process login form"""
    # Find user
    user = db.query(User).filter(User.email == email).first()

    if not user or not verify_password(password, user.password_hash):
        return templates.TemplateResponse(
            "login.html",
            {"request": request, "error": "Invalid email or password"}
        )

    if not user.is_active:
        return templates.TemplateResponse(
            "login.html",
            {"request": request, "error": "Account is inactive"}
        )

    # Create access token
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email}, expires_delta=access_token_expires
    )

    # üéÇ NEW: Check if student needs age verification (first time login)
    from ..models.user import UserRole
    redirect_url = "/dashboard"

    if user.role == UserRole.STUDENT and user.date_of_birth is None:
        # First time login - redirect to age verification
        redirect_url = "/age-verification"
        print(f"üéÇ First-time student login: {user.email} ‚Üí redirecting to age verification")

    # Redirect with token in cookie
    response = RedirectResponse(url=redirect_url, status_code=303)
    response.set_cookie(
        key="access_token",
        value=f"Bearer {access_token}",
        httponly=True,
        max_age=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        secure=False,  # Set to True in production with HTTPS
        samesite="lax",  # Allow cookie to be sent with form POSTs
        path="/"  # Make cookie available across all paths
    )
    return response


@router.get("/logout")
async def logout():
    """Logout user"""
    response = RedirectResponse(url="/login", status_code=303)
    response.delete_cookie(key="access_token")
    return response


# üéÇ AGE VERIFICATION ROUTES

@router.get("/age-verification", response_class=HTMLResponse)
async def age_verification_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Age verification page for first-time students"""
    from ..models.user import UserRole

    # Only students need age verification
    if user.role != UserRole.STUDENT:
        return RedirectResponse(url="/dashboard", status_code=303)

    # If already verified, redirect to dashboard
    if user.date_of_birth is not None:
        return RedirectResponse(url="/dashboard", status_code=303)

    return templates.TemplateResponse(
        "age_verification.html",
        {
            "request": request,
            "user": user,
            "today": datetime.now().date().isoformat()
        }
    )


@router.post("/age-verification")
async def age_verification_submit(
    request: Request,
    date_of_birth: str = Form(...),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Process age verification form"""
    from ..models.user import UserRole
    from datetime import date

    # Only students need age verification
    if user.role != UserRole.STUDENT:
        return RedirectResponse(url="/dashboard", status_code=303)

    try:
        # Parse date
        dob = datetime.strptime(date_of_birth, "%Y-%m-%d").date()

        # Validate date (not in future, reasonable age)
        today = date.today()
        if dob > today:
            return templates.TemplateResponse(
                "age_verification.html",
                {
                    "request": request,
                    "user": user,
                    "today": today.isoformat(),
                    "error": "Date of birth cannot be in the future",
                    "date_of_birth": date_of_birth
                }
            )

        # Calculate age
        age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))

        if age < 5:
            return templates.TemplateResponse(
                "age_verification.html",
                {
                    "request": request,
                    "user": user,
                    "today": today.isoformat(),
                    "error": "You must be at least 5 years old to use this platform",
                    "date_of_birth": date_of_birth
                }
            )

        if age > 120:
            return templates.TemplateResponse(
                "age_verification.html",
                {
                    "request": request,
                    "user": user,
                    "today": today.isoformat(),
                    "error": "Please enter a valid date of birth",
                    "date_of_birth": date_of_birth
                }
            )

        # Save date of birth
        user.date_of_birth = dob
        db.commit()
        db.refresh(user)

        print(f"‚úÖ Age verified for {user.email}: {age} years old (born {dob})")

        # Redirect to dashboard
        return RedirectResponse(url="/dashboard", status_code=303)

    except ValueError as e:
        return templates.TemplateResponse(
            "age_verification.html",
            {
                "request": request,
                "user": user,
                "today": date.today().isoformat(),
                "error": "Invalid date format. Please use the date picker.",
                "date_of_birth": date_of_birth
            }
        )
    except Exception as e:
        print(f"‚ùå Error during age verification: {e}")
        import traceback
        traceback.print_exc()
        return templates.TemplateResponse(
            "age_verification.html",
            {
                "request": request,
                "user": user,
                "today": date.today().isoformat(),
                "error": f"An error occurred: {str(e)}"
            }
        )


@router.get("/dashboard", response_class=HTMLResponse)
@router.get("/dashboard-fresh", response_class=HTMLResponse)  # CACHE BYPASS ROUTE
async def dashboard(
    request: Request,
    spec: str = None,  # Query param for spec switching
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Dashboard page with multi-spec support"""
    from ..models.user import UserRole

    # üÜï STUDENT DASHBOARD: Unified hub showing ALL specializations (locked + unlocked)
    if user.role == UserRole.STUDENT:
        from ..models.license import UserLicense
        from ..utils.age_requirements import get_available_specializations
        from datetime import date

        # Calculate user age
        user_age = None
        if user.date_of_birth:
            today = date.today()
            user_age = today.year - user.date_of_birth.year - ((today.month, today.day) < (user.date_of_birth.month, user.date_of_birth.day))

        # Get user's existing licenses (unlocked specializations)
        user_licenses = db.query(UserLicense).filter(UserLicense.user_id == user.id).all()
        unlocked_specs = {lic.specialization_type for lic in user_licenses}

        # Get age-appropriate specializations
        available_specs_list = get_available_specializations(user_age)

        # Build specialization data with unlock status (ALWAYS SHOW ALL)
        specializations_data = []
        for spec_item in available_specs_list:
            is_unlocked = spec_item["type"] in unlocked_specs
            specializations_data.append({
                "type": spec_item["type"],
                "name": spec_item["name"],
                "icon": spec_item["icon"],
                "color": spec_item["color"],
                "description": spec_item["description"],
                "age_requirement": spec_item["age_requirement"],
                "is_unlocked": is_unlocked,  # ‚úÖ NEW: Mark as unlocked if user has license
                "is_available": True
            })

        print(f"üéì Dashboard for {user.email}: {len(unlocked_specs)} unlocked, {len(specializations_data)} total specs")

        # ALWAYS show specialization hub (no auto-redirect)
        return templates.TemplateResponse(
            "hub_specializations.html",  # SPECIALIZATIONS HUB
            {
                "request": request,
                "user": user,
                "user_age": user_age or "N/A",
                "available_specializations": specializations_data,
                "unlocked_count": len(unlocked_specs)  # For displaying stats
            }
        )
    else:
        # Not a student or no special multi-spec handling needed
        specialization = None

    # üìÖ Get active semesters (for ADMIN dashboard)
    active_semesters = []
    if user.role == UserRole.ADMIN:
        from ..models.semester import Semester
        from datetime import date
        import re

        today = date.today()
        active_semesters = db.query(Semester).filter(
            Semester.is_active == True,
            Semester.start_date <= today,
            Semester.end_date >= today
        ).order_by(Semester.code, Semester.start_date.desc()).all()

        # Add specialization_type and extract location from code
        for semester in active_semesters:
            code = semester.code

            # Extract location suffix (BUDA, PEST, BUDAPEST, city names)
            location_match = re.search(r'_(BUDA|PEST|BUDAPEST|DEBRECEN|SZEGED|MISKOLC|GYOR)$', code, re.IGNORECASE)
            if location_match:
                location_suffix = location_match.group(1)
                # Set location_venue if not already set in DB
                if not semester.location_venue:
                    if location_suffix.upper() in ['BUDA', 'PEST']:
                        semester.location_venue = f"{location_suffix.capitalize()} Campus"
                        semester.location_city = "Budapest"
                    else:
                        semester.location_city = location_suffix.capitalize()

                # Remove location suffix for specialization extraction
                code_without_location = code[:location_match.start()]
            else:
                code_without_location = code

            # Remove year patterns
            code_clean = re.sub(r'_\d{4}(-\d{2})?(_[A-Z]{3,6})?$', '', code_without_location)
            code_clean = re.sub(r'_\d{4}_Q\d$', '', code_clean)

            # Special case: GANCUJU should become GANCUJU_PLAYER
            if code_clean.startswith('GANCUJU'):
                semester.specialization_type = 'GANCUJU_PLAYER'
            else:
                semester.specialization_type = code_clean if code_clean else None

    # Get user's specialization (if not already set by multi-spec logic above)
    if user.role != UserRole.STUDENT or not specialization:
        specialization = user.specialization if hasattr(user, 'specialization') and user.specialization else None

    # üîÑ REDIRECT: Check if student has incomplete onboarding on any UserLicense
    if user.role == UserRole.STUDENT:
        from ..models.license import UserLicense

        # Check all user licenses for incomplete onboarding
        incomplete_license = db.query(UserLicense).filter(
            UserLicense.user_id == user.id,
            UserLicense.onboarding_completed == False
        ).first()

        if incomplete_license:
            print(f"‚ö†Ô∏è Student {user.email} has incomplete onboarding for {incomplete_license.specialization_type} - redirecting to onboarding")

            # Redirect to specialization-specific onboarding page
            if incomplete_license.specialization_type == "LFA_FOOTBALL_PLAYER":
                return RedirectResponse(url="/specialization/lfa-player/onboarding", status_code=303)
            elif incomplete_license.specialization_type == "GANCUJU_PLAYER":
                return RedirectResponse(url="/specialization/gancuju-player/onboarding", status_code=303)
            elif incomplete_license.specialization_type == "LFA_COACH":
                return RedirectResponse(url="/specialization/lfa-coach/onboarding", status_code=303)
            else:
                # For INTERNSHIP and others without specialized onboarding, mark as completed
                incomplete_license.onboarding_completed = True
                db.commit()

    # REDIRECT: If student has specialization but hasn't completed onboarding (motivation questionnaire)
    if user.role == UserRole.STUDENT and specialization and not user.onboarding_completed:
        print(f"‚ö†Ô∏è Student {user.email} has specialization {specialization.value} but onboarding incomplete - redirecting to motivation questionnaire")
        return RedirectResponse(url=f"/specialization/motivation?spec={specialization.value}", status_code=303)

    # Check if user is instructor
    is_instructor = user.role == UserRole.INSTRUCTOR

    # Get instructor teaching qualifications
    teaching_specializations = []
    all_teaching_specializations = []
    if is_instructor:
        teaching_specializations = user.get_teaching_specializations()  # Active only
        all_teaching_specializations = user.get_all_teaching_specializations()  # Active + Inactive

    # Get XP data from user_stats (ONLY for students)
    xp_data = {
        "total_xp": 0,
        "level": 1,
        "level_progress": 0
    }

    # Get user licenses and specialization color (for students)
    user_licenses = []
    specialization_color = None
    pending_enrollments = []
    has_active_enrollment = False  # Default to False for non-students
    current_license = None  # Initialize for all users
    available_semesters = []
    current_semester = None
    next_semester = None

    if user.role == UserRole.STUDENT:
        from ..models.gamification import UserStats
        from ..models.license import UserLicense
        from ..models.semester_enrollment import SemesterEnrollment, EnrollmentStatus
        from sqlalchemy.orm import joinedload

        user_stats = db.query(UserStats).filter(UserStats.user_id == user.id).first()
        if user_stats:
            xp_data = {
                "total_xp": user_stats.total_xp or 0,
                "level": user_stats.level or 1,
                "level_progress": ((user_stats.total_xp or 0) % 1000) / 10  # % to next level
            }

        # Get all user licenses for the specialization switcher
        user_licenses = db.query(UserLicense).filter(UserLicense.user_id == user.id).all()

        # Generate payment codes for any licenses that don't have them
        from datetime import datetime
        import secrets
        for lic in user_licenses:
            if not lic.payment_reference_code:
                spec_short = {
                    'INTERNSHIP': 'INT',
                    'GANCUJU_PLAYER': 'GCJ',
                    'LFA_FOOTBALL_PLAYER': 'FBL',
                    'LFA_COACH': 'COA'
                }.get(lic.specialization_type, 'LIC')
                year = datetime.now().year
                random_code = secrets.token_hex(2).upper()
                lic.payment_reference_code = f"{spec_short}-{year}-{user.id:03d}-{random_code}"
                print(f"‚úÖ Generated payment code for {user.email} ‚Üí {lic.specialization_type}: {lic.payment_reference_code}")
        if user_licenses:
            db.commit()

        # Get all enrollments for this user (to show enrollment status)
        pending_enrollments = (
            db.query(SemesterEnrollment)
            .options(
                joinedload(SemesterEnrollment.semester),
                joinedload(SemesterEnrollment.user_license)
            )
            .filter(
                SemesterEnrollment.user_id == user.id
            )
            .order_by(SemesterEnrollment.requested_at.desc())
            .all()
        )

        # Generate payment codes for any enrollments that don't have them
        for enrollment in pending_enrollments:
            if not enrollment.payment_reference_code:
                enrollment.set_payment_code()
        if pending_enrollments:
            db.commit()

        print(f"üìã DEBUG: User {user.email} has {len(pending_enrollments)} pending enrollments:")
        for enr in pending_enrollments:
            print(f"   - {enr.semester.name} (Status: {enr.request_status.value}, License: {enr.user_license.specialization_type})")

        print(f"üîç DEBUG: User {user.email} has {len(user_licenses)} licenses:")
        for lic in user_licenses:
            print(f"   - {lic.specialization_type} (level {lic.current_level})")
        print(f"üîç DEBUG: user_licenses type: {type(user_licenses)}")
        print(f"üîç DEBUG: user_licenses bool: {bool(user_licenses)}")
        print(f"üîç DEBUG: user_licenses len: {len(user_licenses)}")

        # Get color for current specialization (for welcome box gradient)
        specialization_colors = {
            "GANCUJU_PLAYER": "#8e44ad",       # Purple (unique purple for GƒÅnCuju)
            "LFA_PLAYER_PRE": "#f1c40f",       # Yellow (for LFA Player PRE)
            "LFA_PLAYER_YOUTH": "#f1c40f",     # Yellow (for LFA Player Youth)
            "LFA_PLAYER_AMATEUR": "#f1c40f",   # Yellow (for LFA Player Amateur)
            "LFA_PLAYER_PRO": "#f1c40f",       # Yellow (for LFA Player PRO)
            "LFA_FOOTBALL_PLAYER": "#f1c40f",  # Yellow (Legacy)
            "LFA_COACH": "#27ae60",            # Green (for LFA Coach)
            "INTERNSHIP": "#e74c3c"            # Red (keep as is)
        }
        if specialization:
            specialization_color = specialization_colors.get(specialization.value, "#3498db")

        # Check if user has an ACTIVE, APPROVED enrollment
        has_active_enrollment = False
        if specialization:
            active_enrollment = (
                db.query(SemesterEnrollment)
                .filter(
                    SemesterEnrollment.user_id == user.id,
                    SemesterEnrollment.user_license_id.in_([lic.id for lic in user_licenses if lic.specialization_type == specialization.value]),
                    SemesterEnrollment.is_active == True,
                    SemesterEnrollment.request_status == EnrollmentStatus.APPROVED
                )
                .first()
            )
            has_active_enrollment = active_enrollment is not None
            print(f"üîç User {user.email} has active enrollment: {has_active_enrollment}")

        # Get upcoming sessions from APPROVED semesters (for "Next Session" card)
        upcoming_sessions = []
        if has_active_enrollment:
            from ..models.session import Session as SessionModel
            approved_enrollments = db.query(SemesterEnrollment).filter(
                SemesterEnrollment.user_id == user.id,
                SemesterEnrollment.request_status == EnrollmentStatus.APPROVED,
                SemesterEnrollment.is_active == True
            ).all()

            approved_semester_ids = [e.semester_id for e in approved_enrollments]
            print(f"üîç DEBUG: Approved semester IDs: {approved_semester_ids}")

            if approved_semester_ids:
                from datetime import datetime as dt
                now = dt.now()
                upcoming_sessions = db.query(SessionModel).filter(
                    SessionModel.semester_id.in_(approved_semester_ids),
                    SessionModel.date_start >= now
                ).order_by(SessionModel.date_start.asc()).limit(3).all()
                print(f"üîç DEBUG: Found {len(upcoming_sessions)} upcoming sessions for {user.email}")

        # Get active semesters and check which ones user can enroll in
        from ..models.semester import Semester
        from datetime import date

        # Get current license for current specialization (to check payment_verified)
        if specialization:
            current_license = next((lic for lic in user_licenses if lic.specialization_type == specialization.value), None)

        # Check which semesters user already enrolled in
        existing_enrollments = (
            db.query(SemesterEnrollment)
            .filter(SemesterEnrollment.user_id == user.id)
            .all()
        )
        enrolled_semester_ids = {e.semester_id for e in existing_enrollments}

        # üí∞ Get credit balance from User (centralized, spec-independent)
        credit_balance = user.credit_balance
        credit_purchased = user.credit_purchased

        # Get relevant semesters based on specialization
        if specialization:
            today = date.today()

            # Map specialization to semester code prefix
            semester_code_prefix = {
                'LFA_PLAYER_PRE': 'LFA_PLAYER_PRE',
                'LFA_PLAYER_YOUTH': 'LFA_PLAYER_YOUTH',
                'LFA_PLAYER_AMATEUR': 'LFA_PLAYER_AMATEUR',
                'LFA_PLAYER_PRO': 'LFA_PLAYER_PRO',
                'LFA_FOOTBALL_PLAYER': 'LFA_PLAYER',  # Legacy: Match ALL LFA_PLAYER_* semesters
                'GANCUJU_PLAYER': 'GANCUJU',  # GANCUJU_PLAYER ‚Üí GANCUJU_*
                'LFA_COACH': 'LFA_COACH',
                'INTERNSHIP': 'INTERNSHIP'
            }.get(specialization.value, specialization.value)

            # Get all semesters for this track
            track_semesters = (
                db.query(Semester)
                .filter(
                    Semester.code.like(f'{semester_code_prefix}_%'),
                    Semester.is_active == True
                )
                .order_by(Semester.start_date)
                .all()
            )

            # Find current and next semester
            for sem in track_semesters:
                if sem.start_date <= today <= sem.end_date:
                    current_semester = sem
                elif sem.start_date > today and not next_semester:
                    next_semester = sem

            # Available semesters are those not yet enrolled and payment is verified
            # Show NEXT 6 semesters for advance booking (user can plan ahead)
            if current_license and current_license.payment_verified:
                available_semesters = [
                    sem for sem in track_semesters
                    if sem.id not in enrolled_semester_ids and sem.start_date >= today
                ][:6]  # Show max 6 upcoming semesters for advance booking

            print(f"üîç DEBUG: current_license={current_license}, payment_verified={current_license.payment_verified if current_license else None}")
            print(f"üîç DEBUG: track_semesters count={len(track_semesters)}")
            print(f"üîç DEBUG: available_semesters count={len(available_semesters)}")

    # ‚öΩ Get football skills for LFA Player specializations
    football_skills = None
    skills_updated_by_name = None
    if user.role == UserRole.STUDENT and specialization and current_license:
        if specialization.value.startswith("LFA_PLAYER_"):
            football_skills = current_license.football_skills
            if current_license.skills_updated_by:
                updater = db.query(User).filter(User.id == current_license.skills_updated_by).first()
                if updater:
                    skills_updated_by_name = updater.name

    # ========================================
    # ROLE-BASED TEMPLATE ROUTING (3 Separate Templates)
    # ========================================

    if user.role == UserRole.ADMIN:
        # ADMIN Dashboard
        print(f"üéØ ROUTING: Using dashboard_admin.html for {user.email}")
        from ..models.user import User as UserModel
        stats = {
            "total_users": db.query(UserModel).count(),
            "active_students": db.query(UserModel).filter(UserModel.role == UserRole.STUDENT).count(),
            "instructors": db.query(UserModel).filter(UserModel.role == UserRole.INSTRUCTOR).count(),
        }

        response = templates.TemplateResponse(
            "dashboard_admin.html",
            {
                "request": request,
                "user": user,
                "active_semesters": active_semesters,
                "stats": stats
            }
        )
    elif user.role == UserRole.INSTRUCTOR:
        # INSTRUCTOR Dashboard
        print(f"üéØ ROUTING: Using dashboard_instructor.html for {user.email}")
        response = templates.TemplateResponse(
            "dashboard_instructor.html",
            {
                "request": request,
                "user": user,
                "teaching_specializations": teaching_specializations,
                "all_teaching_specializations": all_teaching_specializations,
            }
        )
    else:
        # STUDENT Dashboard
        print(f"üéØ ROUTING: Using dashboard_student_new.html for {user.email}")
        response = templates.TemplateResponse(
            "dashboard_student_new.html",
            {
                "request": request,
                "user": user,
                "specialization": specialization,
                "xp_data": xp_data,
                "user_licenses": user_licenses,
                "specialization_color": specialization_color,
                "pending_enrollments": pending_enrollments,
                "has_active_enrollment": has_active_enrollment,
                "current_license": current_license,
                "available_semesters": available_semesters,
                "current_semester": current_semester,
                "next_semester": next_semester,
                "football_skills": football_skills,
                "skills_updated_by_name": skills_updated_by_name,
                "upcoming_sessions": upcoming_sessions,
                "credit_balance": credit_balance,
                "credit_purchased": credit_purchased
            }
        )
    # Disable caching to ensure fresh data
    response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
    response.headers["Pragma"] = "no-cache"
    response.headers["Expires"] = "0"
    return response


def get_lfa_age_category(date_of_birth):
    """
    Determine LFA Player age category based on date of birth.

    Returns tuple: (category_code, category_name, age_range, description)

    Categories:
    - PRE (5-8 years): Foundation Years - Monthly semesters
    - YOUTH (9-14 years): Technical Development - Quarterly semesters
    - AMATEUR (14+ years): Competitive Play - Bi-annual semesters
    - PRO (16+ years): Professional Track - Annual semesters
    """
    from datetime import date

    if not date_of_birth:
        return None, None, None, "Date of birth not set"

    today = date.today()
    age = today.year - date_of_birth.year - ((today.month, today.day) < (date_of_birth.month, date_of_birth.day))

    if 5 <= age <= 8:
        return "PRE", "PRE (Foundation Years)", "5-8 years", f"Age {age} - Monthly training blocks"
    elif 9 <= age <= 14:
        return "YOUTH", "YOUTH (Technical Development)", "9-14 years", f"Age {age} - Quarterly programs"
    elif age >= 16:
        return "PRO", "PRO (Professional Track)", "16+ years", f"Age {age} - Annual season"
    elif age >= 14:
        return "AMATEUR", "AMATEUR (Competitive Play)", "14+ years", f"Age {age} - Bi-annual semesters"
    else:
        return None, None, None, f"Age {age} - Below minimum age requirement (5 years)"


@router.get("/dashboard/{spec_type}", response_class=HTMLResponse)
async def spec_dashboard(
    request: Request,
    spec_type: str,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Spec-specific dashboard for unlocked specializations"""
    from ..models.user import UserRole
    from ..models.license import UserLicense
    from ..models.semester_enrollment import SemesterEnrollment
    from ..models.semester import Semester
    from datetime import date, timezone

    # Convert URL format to enum format (e.g., "lfa-football-player" ‚Üí "LFA_FOOTBALL_PLAYER")
    spec_enum = spec_type.upper().replace("-", "_")

    # Verify user has access to this specialization
    user_license = db.query(UserLicense).filter(
        UserLicense.user_id == user.id,
        UserLicense.specialization_type == spec_enum
    ).first()

    if not user_license:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"You don't have access to {spec_type}. Please unlock it first."
        )

    # Simple spec config (no external config file needed)
    spec_configs = {
        "LFA_FOOTBALL_PLAYER": {"name": "LFA Football Player", "icon": "‚öΩ", "color": "#2ecc71"},
        "GANCUJU_PLAYER": {"name": "GanCuju Player", "icon": "ü•ã", "color": "#e74c3c"},
        "JUNIOR_INTERNSHIP": {"name": "Junior Internship", "icon": "üíº", "color": "#3498db"},
        "SENIOR_INTERNSHIP": {"name": "Senior Internship", "icon": "üéì", "color": "#9b59b6"},
    }

    spec_config = spec_configs.get(spec_enum, {
        "name": spec_type.replace("-", " ").title(),
        "icon": "üéì",
        "color": "#667eea"
    })

    # Get active enrollment for this spec
    has_active_enrollment = db.query(SemesterEnrollment).filter(
        SemesterEnrollment.user_id == user.id,
        SemesterEnrollment.user_license_id == user_license.id,
        SemesterEnrollment.is_active == True
    ).first() is not None

    # Get available semesters for this spec
    today = date.today()

    # For LFA_FOOTBALL_PLAYER, determine age-based category
    age_category = None
    age_category_name = None
    age_range = None
    age_description = None
    user_age = None

    if spec_enum == 'LFA_FOOTBALL_PLAYER':
        age_category, age_category_name, age_range, age_description = get_lfa_age_category(user.date_of_birth)

        # Calculate user_age for template display
        if user.date_of_birth:
            user_age = today.year - user.date_of_birth.year - ((today.month, today.day) < (user.date_of_birth.month, user.date_of_birth.day))

        print(f"‚öΩ LFA PLAYER AGE CHECK: {user.email} ‚Üí {age_category} ({age_description}) - Age: {user_age}")

        if not age_category:
            # User doesn't meet age requirements
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=age_description
            )

    # Map specialization to semester code prefix
    semester_code_prefix = {
        'LFA_PLAYER_PRE': 'LFA_PLAYER_PRE',
        'LFA_PLAYER_YOUTH': 'LFA_PLAYER_YOUTH',
        'LFA_PLAYER_AMATEUR': 'LFA_PLAYER_AMATEUR',
        'LFA_PLAYER_PRO': 'LFA_PLAYER_PRO',
        'LFA_FOOTBALL_PLAYER': f'LFA_PLAYER_{age_category}' if age_category else 'LFA_PLAYER',  # Age-based filtering!
        'GANCUJU_PLAYER': 'GANCUJU',  # GANCUJU_PLAYER ‚Üí GANCUJU_*
        'LFA_COACH': 'LFA_COACH',
        'INTERNSHIP': 'INTERNSHIP'
    }.get(spec_enum, spec_enum)

    print(f"üîç SEMESTER PREFIX: {semester_code_prefix} (searching for: {semester_code_prefix}_*)")

    # Get all track semesters
    track_semesters = db.query(Semester).filter(
        Semester.code.like(f'{semester_code_prefix}_%'),
        Semester.is_active == True
    ).order_by(Semester.start_date).all()

    print(f"üìö FOUND {len(track_semesters)} semesters for prefix '{semester_code_prefix}'")
    if track_semesters:
        for sem in track_semesters[:3]:  # Show first 3
            print(f"  - {sem.code} ({sem.start_date} to {sem.end_date})")

    # Check which semesters user already enrolled in
    existing_enrollments = db.query(SemesterEnrollment).filter(
        SemesterEnrollment.user_id == user.id
    ).all()
    enrolled_semester_ids = {e.semester_id for e in existing_enrollments}

    # Available semesters = all semesters not yet enrolled (show upcoming and current, max 6)
    # Filter: not enrolled AND (current semester OR future semester)
    available_semesters = [
        sem for sem in track_semesters
        if sem.id not in enrolled_semester_ids and sem.end_date >= today
    ][:6]

    print(f"‚úÖ AVAILABLE SEMESTERS: {len(available_semesters)} (after filtering enrolled + ended)")

    # Get current semester if enrolled
    current_semester = None
    if has_active_enrollment:
        enrollment = db.query(SemesterEnrollment).filter(
            SemesterEnrollment.user_id == user.id,
            SemesterEnrollment.user_license_id == user_license.id,
            SemesterEnrollment.is_active == True
        ).first()
        if enrollment:
            current_semester = enrollment.semester

    # Get all pending enrollments for this user
    pending_enrollments = db.query(SemesterEnrollment).filter(
        SemesterEnrollment.user_id == user.id
    ).order_by(SemesterEnrollment.requested_at.desc()).all()

    # Get user credit balance
    credit_balance = user.credit_balance if hasattr(user, 'credit_balance') else 0

    return templates.TemplateResponse(
        "dashboard_student_new.html",
        {
            "request": request,
            "user": user,
            "specialization": spec_enum,
            "spec_config": spec_config,
            "user_license": user_license,
            "current_license": user_license,  # For payment_verified check
            "has_active_enrollment": has_active_enrollment,
            "available_semesters": available_semesters,
            "current_semester": current_semester,
            "specialization_color": spec_config.get("color", "#667eea"),
            "pending_enrollments": pending_enrollments,
            "credit_balance": credit_balance,
            "credit_purchased": user.credit_purchased if hasattr(user, 'credit_purchased') else 0,
            # LFA Player age category info
            "age_category": age_category,
            "age_category_name": age_category_name,
            "age_range": age_range,
            "age_description": age_description,
            "user_age": user_age
        }
    )


@router.get("/specialization/select", response_class=HTMLResponse)
async def specialization_select_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Display specialization selection page - only show active specializations"""
    from ..models.license import UserLicense

    # All available specializations (hardcoded for now since semester_specializations doesn't exist)
    active_specializations = {
        "INTERNSHIP": {"has_instructor": True, "max_students": 30},
        "LFA_FOOTBALL_PLAYER": {"has_instructor": True, "max_students": 25},
        "LFA_COACH": {"has_instructor": True, "max_students": 20},
        "GANCUJU_PLAYER": {"has_instructor": True, "max_students": 25}
    }

    # Get user's existing licenses
    user_licenses = db.query(UserLicense).filter(UserLicense.user_id == user.id).all()
    user_specialization_types = [license.specialization_type for license in user_licenses]

    return templates.TemplateResponse(
        "specialization_select.html",
        {
            "request": request,
            "user": user,
            "active_specializations": active_specializations,
            "user_specialization_types": user_specialization_types
        }
    )


@router.post("/specialization/select")
async def specialization_select_submit(
    request: Request,
    specialization: str = Form(...),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Process specialization selection and complete onboarding"""
    from ..models.specialization import SpecializationType
    from ..models.license import UserLicense
    from datetime import datetime

    try:
        # Validate specialization type
        try:
            spec_type = SpecializationType[specialization]
        except KeyError:
            print(f"‚ùå Invalid specialization value: {specialization}")
            return templates.TemplateResponse(
                "specialization_select.html",
                {"request": request, "user": user, "error": f"Invalid specialization: {specialization}"}
            )

        # üí∞ NEW LOGIC: Check if user already has a license (already unlocked)
        user_license = db.query(UserLicense).filter(
            UserLicense.user_id == user.id,
            UserLicense.specialization_type == spec_type.value
        ).first()

        # If NO license exists, this is a NEW unlock ‚Üí costs 100 credits
        if not user_license:
            SPEC_UNLOCK_COST = 100  # üí∞ Cost to unlock a new specialization

            # Check if user has enough credits
            if user.credit_balance < SPEC_UNLOCK_COST:
                print(f"‚ùå User {user.email} has insufficient credits ({user.credit_balance}) to unlock {spec_type.value} (needs {SPEC_UNLOCK_COST})")
                # Redirect back to dashboard with error message
                error_msg = f"Insufficient credits! Unlocking {spec_type.value.replace('_', ' ')} requires {SPEC_UNLOCK_COST} credits. You have {user.credit_balance} credits."
                return RedirectResponse(url=f"/dashboard?error={error_msg}", status_code=303)

            # üí∞ DEDUCT credits and create the license
            print(f"üí∞ Deducting {SPEC_UNLOCK_COST} credits from user {user.email} (balance: {user.credit_balance} ‚Üí {user.credit_balance - SPEC_UNLOCK_COST})")
            user.credit_balance -= SPEC_UNLOCK_COST

            # Create the UserLicense (unlock specialization)
            from ..models.credit_transaction import CreditTransaction, TransactionType

            user_license = UserLicense(
                user_id=user.id,
                specialization_type=spec_type.value,
                current_level=1,
                started_at=datetime.now(),  # ‚úÖ Required field!
                payment_verified=True,  # Paid via credits
                payment_verified_at=datetime.now(),
                created_at=datetime.now()
            )
            db.add(user_license)
            db.flush()  # Flush to get the user_license.id

            # Log credit transaction
            credit_transaction = CreditTransaction(
                user_license_id=user_license.id,  # ‚úÖ Fixed: use user_license_id, not user_id
                amount=-SPEC_UNLOCK_COST,
                transaction_type=TransactionType.PURCHASE.value,  # ‚úÖ Fixed: use .value for enum
                description=f"Unlocked specialization: {spec_type.value.replace('_', ' ')}",
                balance_after=user.credit_balance,
                created_at=datetime.now()
            )
            db.add(credit_transaction)

            print(f"‚úÖ User {user.email} unlocked {spec_type.value} for {SPEC_UNLOCK_COST} credits")

        print(f"üîç Setting specialization {spec_type} for user {user.email}")

        # Update user's specialization BUT DO NOT mark onboarding as completed yet
        # Student needs to fill out motivation questionnaire first
        user.specialization = spec_type
        # onboarding_completed will be set to True AFTER motivation questionnaire

        db.flush()  # Flush to catch any DB errors before commit
        db.commit()
        db.refresh(user)  # Refresh to get updated values

        print(f"‚úÖ User {user.email} selected specialization: {spec_type.value}, redirecting to onboarding")

        # Redirect based on specialization type
        if spec_type == SpecializationType.LFA_FOOTBALL_PLAYER:
            # LFA Player gets specialized onboarding questionnaire
            return RedirectResponse(url=f"/specialization/lfa-player/onboarding", status_code=303)
        else:
            # Other specializations get standard motivation questionnaire
            return RedirectResponse(url=f"/specialization/motivation?spec={spec_type.value}", status_code=303)

    except Exception as e:
        db.rollback()
        import traceback
        print(f"‚ùå Error during specialization selection: {e}")
        print(traceback.format_exc())
        # Redirect back to dashboard with error message (instead of showing old 4-card page)
        return RedirectResponse(url=f"/dashboard?error={str(e)}", status_code=303)


# üîì SPECIALIZATION UNLOCK ROUTE (from dashboard cards)
@router.get("/specialization/unlock", response_class=HTMLResponse)
async def specialization_unlock_get(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    GET handler for /specialization/unlock - redirects to dashboard
    (The actual unlock happens via POST)
    """
    print(f"‚ÑπÔ∏è User {user.email} accessed /specialization/unlock via GET, redirecting to dashboard")
    return RedirectResponse(url="/dashboard", status_code=303)


@router.post("/specialization/unlock")
async def specialization_unlock(
    request: Request,
    specialization: str = Form(...),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Unlock a specialization from the dashboard (costs 100 credits)
    This is the NEW flow - credit-based unlock system
    """
    # Delegate to the existing specialization_select_submit function
    # which already handles the credit deduction and license creation
    return await specialization_select_submit(request, specialization, db, user)


@router.get("/specialization/motivation", response_class=HTMLResponse)
async def student_motivation_questionnaire_page(
    request: Request,
    spec: str,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Student self-assessment motivation questionnaire (part of onboarding)"""
    from ..models.specialization import SpecializationType

    # Validate specialization parameter
    try:
        spec_type = SpecializationType(spec)
    except ValueError:
        return RedirectResponse(url="/specialization/select", status_code=303)

    # Create display name
    spec_display_map = {
        SpecializationType.GANCUJU_PLAYER: "GƒÅnCuju Player",
        SpecializationType.LFA_FOOTBALL_PLAYER: "LFA Football Player",
        SpecializationType.LFA_COACH: "LFA Coach",
        SpecializationType.INTERNSHIP: "Internship"
    }
    specialization_display = spec_display_map.get(spec_type, spec_type.value.replace('_', ' '))

    print(f"üìä Student {user.email} accessing motivation questionnaire for {spec_type.value}")

    return templates.TemplateResponse(
        "student_motivation_questionnaire.html",
        {
            "request": request,
            "user": user,
            "specialization": spec_type.value,
            "specialization_display": specialization_display
        }
    )


@router.post("/specialization/motivation-submit")
async def student_motivation_questionnaire_submit(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Process student's motivation self-assessment and complete onboarding"""
    from ..models.specialization import SpecializationType
    from ..models.license import UserLicense

    try:
        # Parse form data
        form = await request.form()
        specialization = form.get("specialization")

        # Validate specialization
        try:
            spec_type = SpecializationType(specialization)
        except ValueError:
            return RedirectResponse(url="/specialization/select", status_code=303)

        # Get the 5 motivation scores
        goal_clarity = int(form.get("goal_clarity", 0))
        commitment_level = int(form.get("commitment_level", 0))
        engagement = int(form.get("engagement", 0))
        progress_mindset = int(form.get("progress_mindset", 0))
        initiative = int(form.get("initiative", 0))
        notes = form.get("notes", "").strip()

        # Validate scores (must be 1-5)
        scores = [goal_clarity, commitment_level, engagement, progress_mindset, initiative]
        if any(score < 1 or score > 5 for score in scores):
            return templates.TemplateResponse(
                "student_motivation_questionnaire.html",
                {
                    "request": request,
                    "user": user,
                    "specialization": spec_type.value,
                    "specialization_display": spec_type.value.replace('_', ' '),
                    "error": "All scores must be between 1 and 5"
                }
            )

        # Calculate average
        average_score = sum(scores) / len(scores)

        # Create motivation data object (student self-assessment)
        motivation_data = {
            "self_assessment": {
                "goal_clarity": goal_clarity,
                "commitment_level": commitment_level,
                "engagement": engagement,
                "progress_mindset": progress_mindset,
                "initiative": initiative,
                "average": round(average_score, 2),
                "notes": notes,
                "assessed_at": datetime.now(timezone.utc).isoformat(),
                "assessed_by": "student"
            }
        }

        # Find or create UserLicense for this specialization
        license = db.query(UserLicense).filter(
            UserLicense.user_id == user.id,
            UserLicense.specialization_type == spec_type.value
        ).first()

        if not license:
            # Should not happen if admin verified payment properly, but create if missing
            license = UserLicense(
                user_id=user.id,
                specialization_type=spec_type.value,
                current_level=1,
                max_achieved_level=1,
                started_at=datetime.now(timezone.utc)
            )
            db.add(license)

        # Update motivation scores
        license.motivation_scores = motivation_data
        license.average_motivation_score = average_score
        license.motivation_last_assessed_at = datetime.now(timezone.utc)
        license.motivation_assessed_by = user.id  # Student self-assessment

        # Mark onboarding as completed (BOTH user AND license)
        user.onboarding_completed = True  # User-level: "has completed at least ONE specialization onboarding"
        license.onboarding_completed = True  # License-level: "THIS specialization onboarding completed"
        license.onboarding_completed_at = datetime.now(timezone.utc)

        db.commit()
        db.refresh(user)
        db.refresh(license)

        print(f"‚úÖ Student {user.email} completed motivation questionnaire for {spec_type.value} - Average: {average_score:.2f}")

        # Redirect to dashboard - onboarding complete!
        return RedirectResponse(url="/dashboard", status_code=303)

    except Exception as e:
        db.rollback()
        import traceback
        print(f"‚ùå Error processing motivation questionnaire: {e}")
        print(traceback.format_exc())
        return templates.TemplateResponse(
            "student_motivation_questionnaire.html",
            {
                "request": request,
                "user": user,
                "specialization": specialization if 'specialization' in locals() else "",
                "specialization_display": "",
                "error": f"An error occurred: {str(e)}"
            }
        )


# ==================== LFA PLAYER ONBOARDING ====================

@router.get("/specialization/lfa-player/onboarding", response_class=HTMLResponse)
async def lfa_player_onboarding_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    LFA Player specialized onboarding questionnaire
    Multi-step: Position ‚Üí Self-Assessment ‚Üí Motivation
    """
    from ..models.license import UserLicense

    # Verify user has LFA_FOOTBALL_PLAYER license
    license = db.query(UserLicense).filter(
        UserLicense.user_id == user.id,
        UserLicense.specialization_type == "LFA_FOOTBALL_PLAYER"
    ).first()

    if not license:
        print(f"‚ùå User {user.email} tried to access LFA Player onboarding without license")
        return RedirectResponse(url="/dashboard", status_code=303)

    # If already completed onboarding, redirect to dashboard
    if license.onboarding_completed:
        print(f"‚ÑπÔ∏è User {user.email} already completed LFA Player onboarding")
        return RedirectResponse(url="/dashboard", status_code=303)

    print(f"‚öΩ User {user.email} starting LFA Player onboarding questionnaire")

    return templates.TemplateResponse(
        "lfa_player_onboarding.html",
        {
            "request": request,
            "user": user,
            "license": license
        }
    )


@router.get("/specialization/lfa-player/onboarding-cancel")
async def lfa_player_onboarding_cancel(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Cancel LFA Player onboarding and refund credits
    """
    from ..models.license import UserLicense
    from ..models.credit_transaction import CreditTransaction, TransactionType

    # Find the license
    license = db.query(UserLicense).filter(
        UserLicense.user_id == user.id,
        UserLicense.specialization_type == "LFA_FOOTBALL_PLAYER",
        UserLicense.onboarding_completed == False  # Only incomplete onboarding
    ).first()

    if license:
        REFUND_AMOUNT = 100

        # Refund the credits
        user.credit_balance += REFUND_AMOUNT

        # Log the refund transaction
        refund_transaction = CreditTransaction(
            user_license_id=license.id,
            amount=REFUND_AMOUNT,
            transaction_type=TransactionType.REFUND.value,
            description=f"Refund for cancelled LFA Football Player onboarding",
            balance_after=user.credit_balance,
            created_at=datetime.now()
        )
        db.add(refund_transaction)

        # Delete the license
        db.delete(license)

        # Reset user's specialization
        user.specialization = None

        db.commit()

        print(f"üí∞ Refunded {REFUND_AMOUNT} credits to {user.email} (cancelled onboarding)")
        return RedirectResponse(url="/dashboard?success=Onboarding cancelled. 100 credits refunded.", status_code=303)
    else:
        return RedirectResponse(url="/dashboard", status_code=303)


@router.post("/specialization/lfa-player/onboarding-submit")
async def lfa_player_onboarding_submit(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Process LFA Player onboarding questionnaire
    Saves: position, self-assessment skills, motivation
    """
    from ..models.license import UserLicense

    try:
        form = await request.form()

        # Get form data
        position = form.get("position")
        motivation = form.get("motivation", "")
        goals = form.get("goals", "")

        # Self-assessment scores (0-10)
        skills = {
            "heading": int(form.get("skill_heading", 5)),
            "shooting": int(form.get("skill_shooting", 5)),
            "passing": int(form.get("skill_passing", 5)),
            "dribbling": int(form.get("skill_dribbling", 5)),
            "defending": int(form.get("skill_defending", 5)),
            "physical": int(form.get("skill_physical", 5))
        }

        # Validate position
        valid_positions = ["STRIKER", "MIDFIELDER", "DEFENDER", "GOALKEEPER"]
        if position not in valid_positions:
            raise ValueError(f"Invalid position: {position}")

        # Get user's LFA Player license
        license = db.query(UserLicense).filter(
            UserLicense.user_id == user.id,
            UserLicense.specialization_type == "LFA_FOOTBALL_PLAYER"
        ).first()

        if not license:
            raise ValueError("LFA Player license not found")

        # Calculate initial average skill level (convert to percentage)
        average_skill = sum(skills.values()) / len(skills) / 10 * 100  # Convert 0-10 to 0-100%

        # Store position, goals, and initial self-assessment in motivation_scores JSON field
        license.motivation_scores = {
            "position": position,
            "goals": goals,
            "motivation": motivation,
            "initial_self_assessment": skills,
            "average_skill_level": round(average_skill, 1),
            "onboarding_completed_at": datetime.now(timezone.utc).isoformat()
        }
        license.average_motivation_score = average_skill
        license.motivation_last_assessed_at = datetime.now(timezone.utc)
        license.motivation_assessed_by = user.id

        # Mark onboarding as completed
        user.onboarding_completed = True
        license.onboarding_completed = True
        license.onboarding_completed_at = datetime.now(timezone.utc)

        db.commit()
        db.refresh(user)
        db.refresh(license)

        print(f"‚úÖ LFA Player onboarding completed for {user.email}: Position={position}, Avg Skill={average_skill:.1f}%")

        # Redirect to dashboard
        return RedirectResponse(url="/dashboard", status_code=303)

    except Exception as e:
        db.rollback()
        import traceback
        print(f"‚ùå Error processing LFA Player onboarding: {e}")
        print(traceback.format_exc())
        return templates.TemplateResponse(
            "lfa_player_onboarding.html",
            {
                "request": request,
                "user": user,
                "error": f"An error occurred: {str(e)}"
            }
        )


@router.post("/specialization/switch")
async def specialization_switch(
    request: Request,
    specialization: str = Form(...),
    return_url: str = Form(None),  # üîÑ NEW: Optional return URL
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Switch student's active specialization (with onboarding check for new specs)"""
    from ..models.specialization import SpecializationType
    from ..models.license import UserLicense

    # Default redirect URL
    redirect_url = return_url if return_url else "/dashboard"

    try:
        # Validate specialization type
        try:
            spec_type = SpecializationType(specialization)
        except ValueError:
            return RedirectResponse(url=redirect_url, status_code=303)

        # SECURITY: Check if user has a license for this specialization
        license = db.query(UserLicense).filter(
            UserLicense.user_id == user.id,
            UserLicense.specialization_type == spec_type.value
        ).first()

        if not license:
            print(f"‚ùå User {user.email} attempted to switch to UNAUTHORIZED specialization: {spec_type.value}")
            return RedirectResponse(url=redirect_url, status_code=303)

        print(f"üîÑ User {user.email} switching to {spec_type.value}")

        # Update user's current specialization
        user.specialization = spec_type
        db.commit()
        db.refresh(user)

        # Redirect back to the page they came from (or dashboard)
        print(f"‚úÖ Switched to {spec_type.value}, redirecting to {redirect_url}")
        return RedirectResponse(url=redirect_url, status_code=303)

    except Exception as e:
        db.rollback()
        import traceback
        print(f"‚ùå Error during specialization switch: {e}")
        print(traceback.format_exc())
        return RedirectResponse(url=redirect_url, status_code=303)


@router.post("/enrollment/request")
async def enrollment_request(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Student requests enrollment in a semester (creates SemesterEnrollment with PENDING status)"""
    from ..models.user import UserRole
    from ..models.semester import Semester
    from ..models.semester_enrollment import SemesterEnrollment, EnrollmentStatus
    from ..models.license import UserLicense
    from datetime import datetime, timezone

    # SECURITY: Only students can request enrollment
    if user.role != UserRole.STUDENT:
        return JSONResponse(
            status_code=403,
            content={"detail": "Only students can request enrollment"}
        )

    # Parse JSON body
    try:
        body = await request.json()
        semester_id = body.get("semester_id")

        if not semester_id:
            return JSONResponse(
                status_code=400,
                content={"detail": "semester_id is required"}
            )
    except Exception as e:
        return JSONResponse(
            status_code=400,
            content={"detail": "Invalid JSON body"}
        )

    # Get semester
    semester = db.query(Semester).filter(Semester.id == semester_id).first()
    if not semester:
        return JSONResponse(
            status_code=404,
            content={"detail": "Semester not found"}
        )

    # Check if student has paid license for this specialization
    if not user.specialization:
        return JSONResponse(
            status_code=400,
            content={"detail": "No active specialization selected"}
        )

    user_license = db.query(UserLicense).filter(
        UserLicense.user_id == user.id,
        UserLicense.specialization_type == user.specialization.value
    ).first()

    if not user_license:
        return JSONResponse(
            status_code=400,
            content={"detail": "No license found for current specialization"}
        )

    if not user_license.payment_verified:
        return JSONResponse(
            status_code=400,
            content={"detail": "License payment not verified. Please wait for admin to verify your payment."}
        )

    # üí∞ CREDIT SYSTEM CHECK: Verify sufficient credit balance (centralized)
    enrollment_cost = semester.enrollment_cost

    if user.credit_balance < enrollment_cost:
        return JSONResponse(
            status_code=400,
            content={
                "detail": f"‚ö†Ô∏è Insufficient credits! This semester costs {enrollment_cost} credits, but you only have {user.credit_balance} credits. Please purchase more credits."
            }
        )

    # Check if student already enrolled in this semester
    existing_enrollment = db.query(SemesterEnrollment).filter(
        SemesterEnrollment.user_id == user.id,
        SemesterEnrollment.semester_id == semester_id
    ).first()

    if existing_enrollment:
        return JSONResponse(
            status_code=400,
            content={"detail": f"Already enrolled in this semester (Status: {existing_enrollment.request_status.value})"}
        )

    # Create enrollment request
    enrollment = SemesterEnrollment(
        user_id=user.id,
        user_license_id=user_license.id,
        semester_id=semester_id,
        request_status=EnrollmentStatus.PENDING,
        requested_at=datetime.now(timezone.utc),
        is_active=False  # Will be activated when admin approves
    )

    db.add(enrollment)
    db.flush()  # Get enrollment ID before committing

    # üí∞ DEDUCT CREDITS from User (centralized, spec-independent)
    from ..models.credit_transaction import CreditTransaction, TransactionType

    user.credit_balance -= enrollment_cost
    new_balance = user.credit_balance

    # Create audit trail
    transaction = CreditTransaction(
        user_license_id=user_license.id,
        transaction_type=TransactionType.ENROLLMENT.value,
        amount=-enrollment_cost,  # Negative for deduction
        balance_after=new_balance,
        description=f"Enrolled in {semester.name}",
        semester_id=semester_id,
        enrollment_id=enrollment.id
    )

    db.add(transaction)
    db.commit()
    db.refresh(enrollment)

    print(f"üí∞ Student {user.email} enrolled in {semester.name} (Cost: {enrollment_cost} credits, Balance: {new_balance})")

    return JSONResponse(
        status_code=200,
        content={
            "success": True,
            "message": f"Enrollment request submitted successfully! {enrollment_cost} credits deducted.",
            "enrollment_id": enrollment.id,
            "semester_name": semester.name,
            "status": enrollment.request_status.value,
            "credits_deducted": enrollment_cost,
            "new_balance": new_balance
        }
    )


@router.get("/profile", response_class=HTMLResponse)
async def profile_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Display user profile page"""
    from ..models.user import UserRole
    from ..models.license import UserLicense
    from ..models.semester_enrollment import SemesterEnrollment, EnrollmentStatus
    from ..models.semester import Semester

    # Get user licenses for specialization switcher (students only)
    # üéØ Initialize variables at top level to prevent 500 errors
    user_licenses = []
    active_license = None
    active_enrollment = None
    current_semester = None
    available_semesters = []
    enrollment_map = {}
    credit_balance = 0
    credit_purchased = 0

    if user.role == UserRole.STUDENT:
        user_licenses = db.query(UserLicense).filter(UserLicense.user_id == user.id).all()

        # Get ACTIVE semester enrollment for CURRENT specialization
        if user.specialization:
            active_license = db.query(UserLicense).filter(
                UserLicense.user_id == user.id,
                UserLicense.specialization_type == user.specialization.value
            ).first()

            if active_license:
                # Get active enrollment for this spec
                active_enrollment = db.query(SemesterEnrollment).filter(
                    SemesterEnrollment.user_id == user.id,
                    SemesterEnrollment.user_license_id == active_license.id,
                    SemesterEnrollment.is_active == True,
                    SemesterEnrollment.payment_verified == True
                ).first()

                if active_enrollment:
                    current_semester = db.query(Semester).filter(
                        Semester.id == active_enrollment.semester_id
                    ).first()

                # Get available semesters for enrollment request (SPEC-SPECIFIC)
                # Map specialization to semester code prefix
                semester_code_prefix = {
                    'LFA_PLAYER_PRE': 'LFA_PLAYER_PRE',
                    'LFA_PLAYER_YOUTH': 'LFA_PLAYER_YOUTH',
                    'LFA_PLAYER_AMATEUR': 'LFA_PLAYER_AMATEUR',
                    'LFA_PLAYER_PRO': 'LFA_PLAYER_PRO',
                    'GANCUJU_PLAYER': 'GANCUJU',  # GANCUJU_PLAYER ‚Üí GANCUJU_*
                    'LFA_COACH': 'LFA_COACH',
                    'INTERNSHIP': 'INTERNSHIP'
                }.get(user.specialization.value, user.specialization.value)

                # Show NEXT 6 semesters for advance booking (payment verified = 1 semester enrollment right)
                from datetime import date
                today = date.today()
                available_semesters = db.query(Semester).filter(
                    Semester.code.like(f'{semester_code_prefix}_%'),
                    Semester.is_active == True,
                    Semester.start_date >= today  # Only future semesters
                ).order_by(Semester.start_date).limit(6).all()  # Show max 6 upcoming semesters

                # Get all enrollments for current license
                enrollments = db.query(SemesterEnrollment).filter(
                    SemesterEnrollment.user_id == user.id,
                    SemesterEnrollment.user_license_id == active_license.id
                ).all()

                # Build enrollment status map
                enrollment_map = {e.semester_id: e for e in enrollments}

                # üí∞ Get credit balance from User (centralized, spec-independent)
                credit_balance = user.credit_balance
                credit_purchased = user.credit_purchased

    # Get specialization color
    specialization_color = None
    if user.specialization:
        if user.specialization.value == 'INTERNSHIP':
            specialization_color = '#e74c3c'
        elif user.specialization.value == 'GANCUJU_PLAYER':
            specialization_color = '#8e44ad'
        elif user.specialization.value == 'LFA_FOOTBALL_PLAYER':
            specialization_color = '#f1c40f'
        elif user.specialization.value == 'LFA_COACH':
            specialization_color = '#27ae60'

    return templates.TemplateResponse(
        "profile.html",
        {
            "request": request,
            "user": user,
            "user_licenses": user_licenses,
            "active_license": active_license,
            "specialization_color": specialization_color,
            "active_enrollment": active_enrollment,
            "current_semester": current_semester,
            "available_semesters": available_semesters,
            "enrollment_map": enrollment_map,
            "credit_balance": credit_balance,
            "credit_purchased": credit_purchased,
            "today": datetime.now(timezone.utc).date()
        }
    )


@router.get("/profile/edit", response_class=HTMLResponse)
async def profile_edit_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Display profile edit page"""
    from datetime import date

    # Calculate user age
    user_age = None
    if user.date_of_birth:
        today = date.today()
        user_age = today.year - user.date_of_birth.year - ((today.month, today.day) < (user.date_of_birth.month, user.date_of_birth.day))

    return templates.TemplateResponse(
        "profile_edit.html",
        {
            "request": request,
            "user": user,
            "user_age": user_age
        }
    )


@router.post("/profile/edit")
async def profile_edit_submit(
    request: Request,
    name: str = Form(...),
    nickname: str = Form(None),
    date_of_birth: str = Form(...),
    phone: str = Form(None),
    nationality: str = Form(None),
    gender: str = Form(None),
    current_location: str = Form(None),
    emergency_contact: str = Form(None),
    emergency_phone: str = Form(None),
    medical_notes: str = Form(None),
    interests: str = Form(None),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Update user profile"""
    from datetime import date, datetime
    from ..utils.age_requirements import validate_specialization_for_age
    from ..models.license import UserLicense

    try:
        # Parse date of birth
        try:
            dob = datetime.strptime(date_of_birth, '%Y-%m-%d').date()
        except ValueError:
            return templates.TemplateResponse(
                "profile_edit.html",
                {
                    "request": request,
                    "user": user,
                    "error": "Invalid date format. Please use YYYY-MM-DD format."
                }
            )

        # Validate age (5-120 years)
        today = date.today()
        age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))

        if age < 5:
            return templates.TemplateResponse(
                "profile_edit.html",
                {
                    "request": request,
                    "user": user,
                    "error": "‚ö†Ô∏è You must be at least 5 years old to use this platform."
                }
            )

        if age > 120:
            return templates.TemplateResponse(
                "profile_edit.html",
                {
                    "request": request,
                    "user": user,
                    "error": "‚ö†Ô∏è Please enter a valid date of birth."
                }
            )

        # Check if age change affects existing specializations
        old_dob = user.date_of_birth
        age_changed = old_dob != dob

        if age_changed:
            # Check if user has any unlocked specializations that are no longer valid for new age
            user_licenses = db.query(UserLicense).filter(UserLicense.user_id == user.id).all()

            blocked_specs = []
            for license in user_licenses:
                if not validate_specialization_for_age(license.specialization_type, age):
                    blocked_specs.append(license.specialization_type)

            if blocked_specs:
                spec_names = []
                for spec in blocked_specs:
                    if spec == "INTERNSHIP":
                        spec_names.append("üíº Internship")
                    elif spec == "GANCUJU_PLAYER":
                        spec_names.append("ü•ã GƒÅnCuju Player")
                    elif spec == "LFA_FOOTBALL_PLAYER":
                        spec_names.append("‚öΩ LFA Football Player")
                    elif spec == "LFA_COACH":
                        spec_names.append("üë®‚Äçüè´ LFA Coach")
                    else:
                        spec_names.append(spec.replace('_', ' ').title())

                return templates.TemplateResponse(
                    "profile_edit.html",
                    {
                        "request": request,
                        "user": user,
                        "user_age": age,
                        "error": f"‚ö†Ô∏è Cannot change age: You currently have specializations that require a different age. Affected: {', '.join(spec_names)}. Please contact support if you need to update your age."
                    }
                )

        # Update user profile
        user.name = name
        user.nickname = nickname if nickname else None
        user.date_of_birth = dob
        user.phone = phone if phone else None
        user.nationality = nationality if nationality else None
        user.gender = gender if gender else None
        user.current_location = current_location if current_location else None
        user.emergency_contact = emergency_contact if emergency_contact else None
        user.emergency_phone = emergency_phone if emergency_phone else None
        user.medical_notes = medical_notes if medical_notes else None
        user.interests = interests if interests else None

        db.commit()
        db.refresh(user)

        print(f"‚úÖ Profile updated for {user.email} (Age: {age})")

        # Redirect to profile page with success message
        return RedirectResponse(url="/profile?updated=true", status_code=303)

    except Exception as e:
        db.rollback()
        print(f"‚ùå Error updating profile: {e}")
        import traceback
        traceback.print_exc()

        return templates.TemplateResponse(
            "profile_edit.html",
            {
                "request": request,
                "user": user,
                "error": f"Failed to update profile: {str(e)}"
            }
        )


@router.get("/about-specializations", response_class=HTMLResponse)
async def about_specializations_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """About specializations information page"""
    from datetime import date

    # Calculate user age
    user_age = None
    if user.date_of_birth:
        today = date.today()
        user_age = today.year - user.date_of_birth.year - ((today.month, today.day) < (user.date_of_birth.month, user.date_of_birth.day))

    return templates.TemplateResponse(
        "about_specializations.html",
        {
            "request": request,
            "user": user,
            "user_age": user_age
        }
    )


@router.get("/credits", response_class=HTMLResponse)
async def credits_page(
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user_optional)
):
    """
    Credits management page - view balance, purchase credits, transaction history
    """
    if not current_user:
        return RedirectResponse(url="/login", status_code=302)

    # Get all user licenses (all specializations)
    from app.models.license import UserLicense
    from app.models.semester_enrollment import SemesterEnrollment
    from app.models.semester import Semester
    from app.models.audit_log import AuditLog

    user_licenses = db.query(UserLicense).filter(
        UserLicense.user_id == current_user.id
    ).all()

    # Use centralized credit balance from User model (spec-independent)
    total_credit_balance = current_user.credit_balance
    total_credit_purchased = current_user.credit_purchased
    # Credits used = purchased - balance (but never negative, since user might have bonus credits)
    total_credit_used = max(0, total_credit_purchased - total_credit_balance)

    # Get all semester enrollments with credit spending
    enrollments = db.query(SemesterEnrollment).filter(
        SemesterEnrollment.user_id == current_user.id
    ).order_by(SemesterEnrollment.created_at.desc()).all()

    # Build transaction history
    transactions = []

    # Get all invoice requests from invoice_requests table (NEW centralized credit system)
    from app.models.invoice_request import InvoiceRequest
    invoice_requests = db.query(InvoiceRequest).filter(
        InvoiceRequest.user_id == current_user.id
    ).order_by(InvoiceRequest.created_at.desc()).all()

    # Add verified invoice requests as PURCHASE transactions
    for invoice in invoice_requests:
        if invoice.status == 'verified':  # Only show verified invoices as completed purchases
            transactions.append({
                'date': invoice.verified_at or invoice.created_at,
                'type': 'purchase',
                'amount': invoice.credit_amount,
                'specialization': invoice.specialization or 'All Specializations',
                'description': f'Credit purchase via invoice ({invoice.amount_eur} EUR)',
                'status': 'verified',
                'payment_reference': invoice.payment_reference
            })

    # Add credit purchases from licenses (OLD system - for backward compatibility)
    for license in user_licenses:
        if license.credit_purchased > 0:
            # Handle specialization_type (could be enum or string)
            spec_name = 'N/A'
            if license.specialization_type:
                spec_name = license.specialization_type.value if hasattr(license.specialization_type, 'value') else str(license.specialization_type)

            transactions.append({
                'date': license.created_at,
                'type': 'purchase',
                'amount': license.credit_purchased,
                'specialization': spec_name,
                'description': f'Credit purchase for {spec_name}',
                'status': 'verified' if license.payment_verified else 'pending',
                'payment_reference': license.payment_reference_code  # Show old license-specific payment code
            })

    # Add semester enrollments (credit spending)
    for enrollment in enrollments:
        semester = db.query(Semester).filter(Semester.id == enrollment.semester_id).first()
        if semester:
            transactions.append({
                'date': enrollment.created_at,
                'type': 'enrollment',
                'amount': -semester.enrollment_cost,
                'specialization': semester.code.split('_')[0] if '_' in semester.code else semester.code,
                'description': f'Enrolled in {semester.name}',
                'status': enrollment.request_status.value
            })

    # Sort by date descending (handle None and timezone issues)
    from datetime import timezone as tz
    def safe_date_key(transaction):
        date = transaction['date']
        if date is None:
            return datetime.min.replace(tzinfo=tz.utc)
        # Ensure timezone aware
        if date.tzinfo is None:
            return date.replace(tzinfo=tz.utc)
        return date

    transactions.sort(key=safe_date_key, reverse=True)

    # Get specialization color
    specialization_color = None
    if current_user.specialization:
        if current_user.specialization.value == 'INTERNSHIP':
            specialization_color = '#e74c3c'
        elif current_user.specialization.value == 'GANCUJU_PLAYER':
            specialization_color = '#8e44ad'
        elif current_user.specialization.value == 'LFA_FOOTBALL_PLAYER':
            specialization_color = '#f1c40f'
        elif current_user.specialization.value == 'LFA_COACH':
            specialization_color = '#27ae60'
        elif 'LFA_PLAYER' in current_user.specialization.value:
            specialization_color = '#3498db'

    # Check for active enrollment (for navbar navigation)
    has_active_enrollment = db.query(SemesterEnrollment).filter(
        SemesterEnrollment.user_id == current_user.id,
        SemesterEnrollment.is_active == True
    ).first() is not None

    return templates.TemplateResponse(
        "credits.html",
        {
            "request": request,
            "user": current_user,  # FIXED: base.html navbar needs 'user' not 'current_user'
            "current_user": current_user,
            "specialization": current_user.specialization,  # FIXED: navbar needs specialization
            "has_active_enrollment": has_active_enrollment,  # FIXED: navbar needs this for spec menu
            "total_credit_balance": total_credit_balance,
            "total_credit_purchased": total_credit_purchased,
            "total_credit_used": total_credit_used,
            "user_licenses": user_licenses,
            "transactions": transactions,
            "invoice_requests": invoice_requests,
            "specialization_color": specialization_color or '#667eea',
            "today": datetime.now(timezone.utc).date()
        }
    )


@router.get("/progress", response_class=HTMLResponse)
async def progress_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Display student academic progress page with XP, level, and semester completion"""
    from ..services.gamification import GamificationService
    from ..models.session import Session as SessionModel
    from ..models.attendance import Attendance
    from ..models.semester import Semester
    from ..models.user import UserRole

    # ONLY STUDENTS can view progress - instructors TEACH, they don't learn!
    if user.role != UserRole.STUDENT:
        return RedirectResponse(url="/dashboard", status_code=303)

    gamification = GamificationService(db)

    # Get user stats
    stats = gamification.get_or_create_user_stats(user.id)

    # Get current semester info (SPEC-SPECIFIC)
    current_semester = None
    if user.specialization:
        # Map specialization to semester code prefix
        semester_code_prefix = {
            'LFA_PLAYER_PRE': 'LFA_PLAYER_PRE',
            'LFA_PLAYER_YOUTH': 'LFA_PLAYER_YOUTH',
            'LFA_PLAYER_AMATEUR': 'LFA_PLAYER_AMATEUR',
            'LFA_PLAYER_PRO': 'LFA_PLAYER_PRO',
            'GANCUJU_PLAYER': 'GANCUJU',  # GANCUJU_PLAYER ‚Üí GANCUJU_*
            'LFA_COACH': 'LFA_COACH',
            'INTERNSHIP': 'INTERNSHIP'
        }.get(user.specialization.value, user.specialization.value)

        current_semester = db.query(Semester).filter(
            Semester.code.like(f'{semester_code_prefix}_%'),
            Semester.start_date <= datetime.now(timezone.utc),
            Semester.end_date >= datetime.now(timezone.utc)
        ).first()

    # Calculate semester progress
    semester_data = None
    if current_semester:
        # Get all sessions in semester
        all_sessions = db.query(SessionModel).filter(
            SessionModel.semester_id == current_semester.id
        ).all()

        # Get student's attended sessions with XP earned
        attended_sessions = db.query(Attendance).filter(
            Attendance.user_id == user.id
        ).join(
            SessionModel, Attendance.session_id == SessionModel.id
        ).filter(
            SessionModel.semester_id == current_semester.id
        ).all()

        # Calculate XP from session completions
        total_available_xp = sum(s.base_xp or 50 for s in all_sessions)
        earned_session_xp = sum(a.xp_earned or 0 for a in attended_sessions)

        # Add bonus XP from Adaptive Learning sessions
        from ..models.quiz import AdaptiveLearningSession
        adaptive_xp = db.query(func.sum(AdaptiveLearningSession.xp_earned)).filter(
            AdaptiveLearningSession.user_id == user.id,
            AdaptiveLearningSession.started_at >= current_semester.start_date,
            AdaptiveLearningSession.started_at <= current_semester.end_date
        ).scalar() or 0

        # Total XP = session XP + adaptive learning bonus
        earned_xp = earned_session_xp + adaptive_xp

        # Progress calculation (can exceed 100% with bonus XP)
        progress_percent = (earned_xp / total_available_xp * 100) if total_available_xp > 0 else 0

        semester_data = {
            'name': current_semester.name,
            'start_date': current_semester.start_date,
            'end_date': current_semester.end_date,
            'total_sessions': len(all_sessions),
            'attended_sessions': len(attended_sessions),
            'total_available_xp': total_available_xp,
            'earned_xp': earned_xp,
            'earned_session_xp': earned_session_xp,
            'earned_bonus_xp': adaptive_xp,
            'progress_percent': progress_percent,
            'pass_xp': int(total_available_xp * 0.7),
            'good_xp': int(total_available_xp * 0.83),
            'excellence_xp': int(total_available_xp * 0.92),
            'status': 'EXCELLENCE' if progress_percent >= 92 else 'GOOD' if progress_percent >= 83 else 'PASS' if progress_percent >= 70 else 'INCOMPLETE'
        }

    # Calculate level progress to next level
    current_level = stats.level
    xp_for_current_level = (current_level - 1) * 500
    xp_for_next_level = current_level * 500
    xp_progress_in_level = stats.total_xp - xp_for_current_level
    xp_needed_for_next = xp_for_next_level - stats.total_xp
    level_progress_percent = (xp_progress_in_level / 500 * 100) if stats.total_xp < xp_for_next_level else 100

    # üéì REFACTORED: Get ONLY the active specialization's UserLicense
    from ..models.license import UserLicense

    # Get ALL user licenses for the switcher dropdown
    user_licenses = db.query(UserLicense).filter(
        UserLicense.user_id == user.id
    ).all()

    # Filter by user's currently active specialization (from switcher)
    active_license = None
    if user.specialization:
        active_license = db.query(UserLicense).filter(
            UserLicense.user_id == user.id,
            UserLicense.specialization_type == user.specialization.value
        ).first()

    # Build specialization progress data for ACTIVE specialization only
    specialization_progress = None
    if active_license:
        license = active_license
        # Determine level names based on specialization type
        if license.specialization_type == 'INTERNSHIP':
            level_names = ['Junior', 'Mid-Level', 'Senior', 'Lead', 'Principal']
            max_levels = 5
            level_emojis = ['üî∞', 'üìà', 'üéØ', 'üëë', 'üöÄ']
            color = '#e74c3c'
        elif license.specialization_type == 'GANCUJU_PLAYER':
            level_names = [
                'Bamboo Disciple (White)', 'Dawn Dew (Yellow)', 'Flexible Reed (Green)',
                'Celestial River (Blue)', 'Strong Root (Brown)', 'Winter Moon (Grey)',
                'Midnight Guardian (Black)', 'Dragon Wisdom (Red)'
            ]
            max_levels = 8
            level_emojis = ['‚ö™', 'üü°', 'üü¢', 'üîµ', 'üü§', '‚ö´', '‚ö´', 'üî¥']
            color = '#8e44ad'
        elif license.specialization_type == 'LFA_FOOTBALL_PLAYER':
            level_names = [
                'PRE Level 1', 'PRE Level 2', 'Youth Level 1', 'Youth Level 2',
                'Amateur Level 1', 'Amateur Level 2', 'PRO Level 1', 'PRO Level 2'
            ]
            max_levels = 8
            level_emojis = ['‚öΩ', '‚öΩ', '‚öΩ', '‚öΩ', '‚öΩ', '‚öΩ', '‚öΩ', '‚öΩ']
            color = '#f1c40f'
        elif license.specialization_type == 'LFA_COACH':
            level_names = [
                'PRE Assistant Coach', 'PRE Head Coach', 'Youth Assistant Coach', 'Youth Head Coach',
                'Amateur Assistant Coach', 'Amateur Head Coach', 'PRO Assistant Coach', 'PRO Head Coach'
            ]
            max_levels = 8
            level_emojis = ['üìã', 'üìã', 'üìã', 'üìã', 'üìã', 'üìã', 'üìã', 'üìã']
            color = '#27ae60'
        else:
            level_names = [f'Level {i}' for i in range(1, 9)]
            max_levels = 8
            level_emojis = ['‚Ä¢'] * 8
            color = '#95a5a6'

        # Build roadmap data
        roadmap = []
        current_level_idx = license.current_level - 1
        for i in range(max_levels):
            status = 'completed' if i < license.max_achieved_level else ('current' if i == current_level_idx else 'locked')
            roadmap.append({
                'level': i + 1,
                'name': level_names[i] if i < len(level_names) else f'Level {i+1}',
                'emoji': level_emojis[i] if i < len(level_emojis) else '‚Ä¢',
                'status': status
            })

        # Store as single object (not array) since we only show one spec at a time
        specialization_progress = {
            'type': license.specialization_type,
            'current_level': license.current_level,
            'max_achieved_level': license.max_achieved_level,
            'max_levels': max_levels,
            'progress_percent': (license.current_level / max_levels * 100),
            'started_at': license.started_at,
            'last_advanced_at': license.last_advanced_at,
            'color': color,
            'roadmap': roadmap,
            'onboarding_completed': license.onboarding_completed
        }

    return templates.TemplateResponse(
        "progress.html",
        {
            "request": request,
            "user": user,
            "stats": stats,
            "semester": semester_data,
            "level_progress": {
                'current_level': current_level,
                'next_level': current_level + 1,
                'xp_progress': xp_progress_in_level,
                'xp_needed': xp_needed_for_next,
                'progress_percent': level_progress_percent
            },
            "specialization_progress": specialization_progress,
            "user_licenses": user_licenses  # üîÑ NEW: For switcher dropdown
        }
    )


@router.get("/achievements", response_class=HTMLResponse)
async def achievements_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Display achievements page - using REAL database data"""
    from ..models.achievement import Achievement
    from ..models.gamification import UserAchievement

    # Get all achievements from database
    all_achievements_query = db.query(Achievement).filter(
        Achievement.is_active == True
    ).all()

    # Get user's unlocked achievements
    user_achievements = db.query(UserAchievement).filter(
        UserAchievement.user_id == user.id
    ).all()

    # Create a set of unlocked achievement IDs
    unlocked_ids = {ua.achievement_id for ua in user_achievements if ua.achievement_id}

    # Build achievements list with unlocked status
    all_achievements_list = []
    for ach in all_achievements_query:
        user_ach = next((ua for ua in user_achievements if ua.achievement_id == ach.id), None)
        all_achievements_list.append({
            'id': ach.id,
            'name': ach.name,
            'description': ach.description,
            'icon': ach.icon,
            'xp_reward': ach.xp_reward,
            'category': ach.category,
            'unlocked': ach.id in unlocked_ids,
            'earned_at': user_ach.earned_at if user_ach else None
        })

    # Get recent achievements (last 3)
    recent = [a for a in all_achievements_list if a['unlocked']]
    recent.sort(key=lambda x: x['earned_at'] or '', reverse=True)
    recent_achievements = recent[:3]

    # Calculate stats
    unlocked_count = len([a for a in all_achievements_list if a['unlocked']])
    total_achievements = len(all_achievements_list)
    total_xp = sum(a['xp_reward'] for a in all_achievements_list if a['unlocked'])
    completion_rate = int((unlocked_count / total_achievements * 100)) if total_achievements > 0 else 0

    return templates.TemplateResponse(
        "achievements.html",
        {
            "request": request,
            "user": user,
            "all_achievements": all_achievements_list,
            "recent_achievements": recent_achievements,
            "unlocked_count": unlocked_count,
            "total_achievements": total_achievements,
            "total_xp": total_xp,
            "completion_rate": completion_rate
        }
    )


@router.get("/calendar", response_class=HTMLResponse)
async def calendar_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Display calendar page with all sessions"""
    from ..models.user import UserRole

    # ONLY students with completed onboarding can access calendar
    if user.role == UserRole.STUDENT and not user.onboarding_completed:
        return RedirectResponse(url="/dashboard", status_code=303)

    return templates.TemplateResponse(
        "calendar.html",
        {
            "request": request,
            "user": user
        }
    )


@router.get("/sessions", response_class=HTMLResponse)
async def sessions_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Display sessions page - role-based UI for Instructor vs Student"""
    from ..models.session import Session as SessionModel, SessionType
    from ..models.user import UserRole
    from datetime import datetime

    # ONLY students with completed onboarding can access sessions
    if user.role == UserRole.STUDENT and not user.onboarding_completed:
        return RedirectResponse(url="/dashboard", status_code=303)

    is_instructor = user.role == UserRole.INSTRUCTOR

    if is_instructor:
        # INSTRUCTOR VIEW: Show ALL sessions they are teaching (past, ongoing, and upcoming)
        my_sessions = db.query(SessionModel).filter(
            SessionModel.instructor_id == user.id
        ).order_by(SessionModel.date_start.asc()).all()  # Chronological order (earliest first)

        # Add enrolled count and student reviews for each session
        from ..models.booking import Booking
        from ..models.performance_review import InstructorSessionReview

        for session in my_sessions:
            enrolled_count = db.query(Booking).filter(
                Booking.session_id == session.id
            ).count()
            session.enrolled_count = enrolled_count
            session.instructor_name = user.name

            # Get all instructor reviews from students for this session
            student_reviews = db.query(InstructorSessionReview).filter(
                InstructorSessionReview.session_id == session.id
            ).all()
            session.student_reviews = student_reviews

        return templates.TemplateResponse(
            "sessions.html",
            {
                "request": request,
                "user": user,
                "is_instructor": True,
                "my_teaching_sessions": my_sessions,
                "upcoming_sessions": [],
            }
        )
    else:
        # STUDENT VIEW: Show ONLY sessions from APPROVED semesters
        from ..models.semester_enrollment import SemesterEnrollment, EnrollmentStatus

        # Get user's APPROVED semester enrollments
        approved_enrollments = db.query(SemesterEnrollment).filter(
            SemesterEnrollment.user_id == user.id,
            SemesterEnrollment.request_status == EnrollmentStatus.APPROVED,
            SemesterEnrollment.is_active == True
        ).all()

        approved_semester_ids = [e.semester_id for e in approved_enrollments]

        # Only show sessions from APPROVED semesters
        if approved_semester_ids:
            upcoming_sessions = db.query(SessionModel).filter(
                SessionModel.semester_id.in_(approved_semester_ids)
            ).order_by(
                SessionModel.date_start.asc()  # Chronological order (earliest first)
            ).limit(50).all()  # Show last 50 sessions
        else:
            # No approved enrollments = no sessions visible
            upcoming_sessions = []

        # Get user's bookings
        from ..models.booking import Booking
        my_bookings = db.query(Booking).filter(
            Booking.user_id == user.id
        ).all()
        enrolled_session_ids = {b.session_id for b in my_bookings}

        # Add enrolled status and instructor name to sessions
        from datetime import timedelta
        from zoneinfo import ZoneInfo
        from ..models.attendance import Attendance
        from ..models.performance_review import InstructorSessionReview

        budapest_tz = ZoneInfo("Europe/Budapest")
        now = datetime.now(budapest_tz).replace(tzinfo=None)  # CRITICAL: Make naive for comparison

        for session in upcoming_sessions:
            session.is_enrolled = session.id in enrolled_session_ids

            # Calculate if booking can be cancelled (12-hour deadline + no attendance/review)
            session_start = session.date_start  # Stored as naive Budapest time
            cancellation_deadline = session_start - timedelta(hours=12)  # Also naive

            # Check attendance and review for this student
            my_attendance = None
            my_instructor_review = None
            if session.is_enrolled:
                my_attendance = db.query(Attendance).filter(
                    Attendance.session_id == session.id,
                    Attendance.user_id == user.id
                ).first()

                my_instructor_review = db.query(InstructorSessionReview).filter(
                    InstructorSessionReview.session_id == session.id,
                    InstructorSessionReview.student_id == user.id
                ).first()

            # Attach attendance info to session for template use
            session.my_attendance = my_attendance
            session.my_instructor_review = my_instructor_review

            # VIRTUAL session: Check if student completed quiz (for "COMPLETED" badge)
            session.quiz_completed = False
            if session.is_enrolled and session.session_type == SessionType.virtual:
                from ..models.quiz import Quiz, QuizAttempt, SessionQuiz

                # Get quizzes for this session
                session_quizzes = db.query(SessionQuiz).filter(
                    SessionQuiz.session_id == session.id
                ).all()

                # Check if student passed ANY required quiz
                for sq in session_quizzes:
                    if sq.is_required:
                        passed_attempt = db.query(QuizAttempt).filter(
                            QuizAttempt.quiz_id == sq.quiz_id,
                            QuizAttempt.user_id == user.id,
                            QuizAttempt.passed == True
                        ).first()

                        if passed_attempt:
                            session.quiz_completed = True
                            break

            session.can_cancel = session.is_enrolled and now < cancellation_deadline and not my_attendance and not my_instructor_review
            session.can_book = not session.is_enrolled and now < cancellation_deadline  # Can only book if 12+ hours before session start

            # Get instructor name
            if session.instructor_id:
                instructor = db.query(User).filter(User.id == session.instructor_id).first()
                session.instructor_name = instructor.name if instructor else "TBA"
            else:
                session.instructor_name = "TBA"

            # Get enrolled count
            enrolled_count = db.query(Booking).filter(
                Booking.session_id == session.id
            ).count()
            session.enrolled_count = enrolled_count

            # Get performance review from instructor (if exists)
            from ..models.performance_review import StudentPerformanceReview
            session.performance_review = None
            if session.is_enrolled:
                performance_review = db.query(StudentPerformanceReview).filter(
                    StudentPerformanceReview.session_id == session.id,
                    StudentPerformanceReview.student_id == user.id
                ).first()
                session.performance_review = performance_review

        return templates.TemplateResponse(
            "sessions.html",
            {
                "request": request,
                "user": user,
                "is_instructor": False,
                "upcoming_sessions": upcoming_sessions,
                "my_teaching_sessions": [],
            }
        )


@router.post("/sessions/book/{session_id}")
async def book_session(
    request: Request,
    session_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Book a session"""
    from ..models.session import Session as SessionTypel
    from ..models.booking import Booking, BookingStatus
    from datetime import datetime, timedelta, timezone

    # Check if session exists
    session = db.query(SessionTypel).filter(SessionTypel.id == session_id).first()
    if not session:
        # Redirect back with error
        return RedirectResponse(url="/sessions?error=session_not_found", status_code=303)

    # CRITICAL: Cannot book within 12 hours before session start
    # Use Budapest timezone for comparison (sessions are stored in Budapest time)
    from zoneinfo import ZoneInfo
    budapest_tz = ZoneInfo("Europe/Budapest")
    now = datetime.now(budapest_tz).replace(tzinfo=None)  # Budapest time, naive
    session_start = session.date_start  # Stored as naive Budapest time
    booking_deadline = session_start - timedelta(hours=12)

    # DEBUG PRINT
    print(f"üîç BOOKING CHECK:")
    print(f"   Now (Budapest, naive): {now}")
    print(f"   Session start (naive): {session_start}")
    print(f"   Booking deadline: {booking_deadline}")
    print(f"   now >= booking_deadline? {now >= booking_deadline}")

    if now >= booking_deadline:
        print(f"‚ùå BOOKING BLOCKED - deadline passed!")
        return RedirectResponse(url="/sessions?error=booking_deadline_passed", status_code=303)

    # Check if already booked
    existing_booking = db.query(Booking).filter(
        Booking.user_id == user.id,
        Booking.session_id == session_id
    ).first()

    if existing_booking:
        # Already booked
        return RedirectResponse(url="/sessions?info=already_booked", status_code=303)

    # Create booking
    booking = Booking(
        user_id=user.id,
        session_id=session_id,
        status=BookingStatus.CONFIRMED
    )
    db.add(booking)
    db.commit()

    print(f"‚úÖ User {user.email} booked session {session.title}")

    # Redirect back to sessions
    return RedirectResponse(url="/sessions?success=booked", status_code=303)


@router.post("/sessions/cancel/{session_id}")
async def cancel_booking(
    request: Request,
    session_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Cancel a booking"""
    from ..models.booking import Booking
    from ..models.session import Session as SessionTypel
    from ..models.attendance import Attendance

    # Find the booking
    booking = db.query(Booking).filter(
        Booking.user_id == user.id,
        Booking.session_id == session_id
    ).first()

    if not booking:
        return RedirectResponse(url="/sessions?error=booking_not_found", status_code=303)

    # Get the session to check if it has started
    session = db.query(SessionTypel).filter(SessionTypel.id == session_id).first()
    if not session:
        return RedirectResponse(url="/sessions?error=session_not_found", status_code=303)

    # Check cancellation deadline - Use Budapest timezone (database stores naive timestamps in local time)
    from datetime import datetime, timezone, timedelta
    from zoneinfo import ZoneInfo

    budapest_tz = ZoneInfo("Europe/Budapest")
    now = datetime.now(budapest_tz)

    # Database stores timestamps WITHOUT timezone (interpreted as Budapest time)
    session_start = session.date_start
    if session_start.tzinfo is None:
        session_start = session_start.replace(tzinfo=budapest_tz)

    # CRITICAL: Cannot cancel if session has ended
    if session.actual_end_time:
        return RedirectResponse(url=f"/sessions/{session_id}?error=session_already_ended", status_code=303)

    # 12-hour cancellation deadline - cannot cancel within 12 hours of session start
    cancellation_deadline = session_start - timedelta(hours=12)

    if now >= cancellation_deadline:
        return RedirectResponse(url=f"/sessions/{session_id}?error=cancellation_deadline_passed", status_code=303)

    # Check if attendance has been marked for this booking
    attendance = db.query(Attendance).filter(Attendance.booking_id == booking.id).first()
    if attendance:
        return RedirectResponse(url=f"/sessions/{session_id}?error=attendance_already_marked", status_code=303)

    # Check if student has submitted an instructor review (CRITICAL: cannot cancel after evaluation!)
    from ..models.performance_review import InstructorSessionReview
    instructor_review = db.query(InstructorSessionReview).filter(
        InstructorSessionReview.session_id == session_id,
        InstructorSessionReview.student_id == user.id
    ).first()
    if instructor_review:
        return RedirectResponse(url=f"/sessions/{session_id}?error=evaluation_already_submitted", status_code=303)

    # Delete the booking
    db.delete(booking)
    db.commit()

    print(f"‚úÖ User {user.email} cancelled booking for session {session_id}")

    return RedirectResponse(url="/sessions?success=cancelled", status_code=303)


@router.get("/sessions/{session_id}", response_class=HTMLResponse)
async def session_details(
    request: Request,
    session_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Session details page"""
    from ..models.session import Session as SessionModel
    from ..models.booking import Booking
    from ..models.user import UserRole

    session = db.query(SessionModel).filter(SessionModel.id == session_id).first()
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")

    # Get instructor info
    instructor = db.query(User).filter(User.id == session.instructor_id).first()
    session.instructor_name = instructor.name if instructor else "TBA"

    # Get enrolled students with attendance status
    from ..models.attendance import Attendance
    bookings = db.query(Booking).filter(Booking.session_id == session_id).all()
    enrolled_students = []
    for booking in bookings:
        student = db.query(User).filter(User.id == booking.user_id).first()
        if student:
            # Check if attendance has been marked
            attendance = db.query(Attendance).filter(
                Attendance.session_id == session_id,
                Attendance.user_id == student.id
            ).first()

            # Get attendance history
            from ..models.attendance import AttendanceHistory
            history = []
            if attendance:
                history_records = db.query(AttendanceHistory).filter(
                    AttendanceHistory.attendance_id == attendance.id
                ).order_by(AttendanceHistory.created_at.desc()).all()

                for h in history_records:
                    changer = db.query(User).filter(User.id == h.changed_by).first()
                    history.append({
                        'change_type': h.change_type,
                        'old_value': h.old_value,
                        'new_value': h.new_value,
                        'reason': h.reason,
                        'created_at': h.created_at,
                        'changed_by_name': changer.name if changer else 'Unknown'
                    })

            # Get existing performance review (if any)
            from ..models.performance_review import StudentPerformanceReview
            student_review = None
            if attendance:
                student_review = db.query(StudentPerformanceReview).filter(
                    StudentPerformanceReview.session_id == session_id,
                    StudentPerformanceReview.student_id == student.id
                ).first()

            # CRITICAL FIX: Build performance_review dict ONLY if student_review exists
            performance_review_dict = None
            if student_review:
                performance_review_dict = {
                    'punctuality': student_review.punctuality,
                    'engagement': student_review.engagement,
                    'focus': student_review.focus,
                    'collaboration': student_review.collaboration,
                    'attitude': student_review.attitude,
                    'comments': student_review.comments,
                    'average_score': student_review.average_score
                }

            enrolled_students.append({
                'id': student.id,
                'name': student.name,
                'email': student.email,
                'booking_id': booking.id,
                'status': booking.status,
                'attendance_status': attendance.status.value if attendance else None,
                'attendance_id': attendance.id if attendance else None,
                'confirmation_status': attendance.confirmation_status.value if (attendance and attendance.confirmation_status) else None,
                'dispute_reason': attendance.dispute_reason if attendance else None,
                'pending_change_to': attendance.pending_change_to if attendance else None,
                'change_request_reason': attendance.change_request_reason if attendance else None,
                'history': history,
                'performance_review': performance_review_dict
            })

    # Check if current user is enrolled and get their attendance
    is_enrolled = any(b.user_id == user.id for b in bookings)
    is_instructor = user.role == UserRole.INSTRUCTOR and session.instructor_id == user.id

    # Get current user's attendance status (for students)
    my_attendance = None
    my_instructor_review = None
    if is_enrolled and not is_instructor:
        my_attendance = db.query(Attendance).filter(
            Attendance.session_id == session_id,
            Attendance.user_id == user.id
        ).first()

        # Get student's review of instructor/session (if exists)
        # IMPORTANT: Instructor reviews are ONLY for ON-SITE and HYBRID sessions
        # - ON-SITE/HYBRID: Student evaluates instructor after attending (present/late status)
        # - VIRTUAL: NO instructor evaluation (students evaluate quiz/content instead)
        from ..models.performance_review import InstructorSessionReview
        if my_attendance:
            my_instructor_review = db.query(InstructorSessionReview).filter(
                InstructorSessionReview.session_id == session_id,
                InstructorSessionReview.student_id == user.id
            ).first()

    # Check if attendance can be marked (only during or after session time)
    from datetime import datetime, timezone, timedelta
    from zoneinfo import ZoneInfo

    # IMPORTANT: Database stores timestamps WITHOUT timezone (naive timestamps in local time = Budapest CET/CEST)
    # We must compare in the same timezone as the database stores (Europe/Budapest)
    budapest_tz = ZoneInfo("Europe/Budapest")
    now = datetime.now(budapest_tz).replace(tzinfo=None)  # CRITICAL: Naive Budapest time for comparison

    # Session dates are stored as naive timestamps (Budapest time)
    session_start = session.date_start  # Already naive

    # Allow marking 15 minutes before session starts
    can_mark_attendance = is_instructor and (session_start - timedelta(minutes=15)) <= now

    # Check if booking can be cancelled (12-hour deadline)
    # CANNOT cancel if: attendance exists OR instructor review exists OR past 12-hour deadline
    cancellation_deadline = session_start - timedelta(hours=12)
    can_cancel_booking = is_enrolled and not is_instructor and now < cancellation_deadline and not my_attendance and not my_instructor_review
    can_book_session = not is_enrolled and not is_instructor and now < cancellation_deadline  # Can only book if 12+ hours before session start

    # Load quiz data for HYBRID and VIRTUAL sessions
    session_quizzes = []
    if session.session_type.value in ['hybrid', 'virtual']:
        from ..models import SessionQuiz, Quiz, QuizQuestion, QuizAttempt

        # Get all quizzes linked to this session
        sq_records = db.query(SessionQuiz).filter(SessionQuiz.session_id == session_id).all()

        for sq in sq_records:
            quiz = db.query(Quiz).filter(Quiz.id == sq.quiz_id).first()
            if quiz:
                # Count questions
                question_count = db.query(QuizQuestion).filter(QuizQuestion.quiz_id == quiz.id).count()

                # Get user's quiz attempts (for students)
                user_attempts = []
                if not is_instructor and is_enrolled:
                    attempts = db.query(QuizAttempt).filter(
                        QuizAttempt.quiz_id == quiz.id,
                        QuizAttempt.user_id == user.id
                    ).order_by(QuizAttempt.started_at.desc()).all()

                    for attempt in attempts:
                        user_attempts.append({
                            'score': attempt.score,
                            'passed': attempt.passed,
                            'completed_at': attempt.completed_at,
                            'correct_answers': attempt.correct_answers,
                            'total_questions': attempt.total_questions
                        })

                # Get all student results (for instructors)
                student_results = []
                if is_instructor:
                    # Get all enrolled students
                    for booking in bookings:
                        student = db.query(User).filter(User.id == booking.user_id).first()
                        if student:
                            # Get all attempts for this student
                            attempts = db.query(QuizAttempt).filter(
                                QuizAttempt.quiz_id == quiz.id,
                                QuizAttempt.user_id == student.id
                            ).order_by(QuizAttempt.started_at.desc()).all()

                            # Calculate best score and passed status
                            best_score = None
                            best_passed = False
                            best_correct = 0
                            last_attempt_date = None
                            all_attempts = []

                            for attempt in attempts:
                                all_attempts.append({
                                    'score': attempt.score,
                                    'passed': attempt.passed,
                                    'completed_at': attempt.completed_at,
                                    'correct_answers': attempt.correct_answers,
                                    'total_questions': attempt.total_questions,
                                    'time_spent_minutes': attempt.time_spent_minutes
                                })

                                if best_score is None or (attempt.score and attempt.score > best_score):
                                    best_score = attempt.score
                                    best_passed = attempt.passed
                                    best_correct = attempt.correct_answers

                                if attempt.completed_at and (last_attempt_date is None or attempt.completed_at > last_attempt_date):
                                    last_attempt_date = attempt.completed_at

                            student_results.append({
                                'student_id': student.id,
                                'student_name': student.name,
                                'student_email': student.email,
                                'attempts_count': len(attempts),
                                'best_score': best_score,
                                'best_passed': best_passed,
                                'best_correct': best_correct,
                                'total_questions': question_count,
                                'last_attempt_date': last_attempt_date,
                                'all_attempts': all_attempts
                            })

                session_quizzes.append({
                    'quiz': {
                        'id': quiz.id,
                        'title': quiz.title,
                        'description': quiz.description,
                        'passing_score': quiz.passing_score,
                        'time_limit_minutes': quiz.time_limit_minutes,
                        'question_count': question_count,
                        'user_attempts': user_attempts
                    },
                    'max_attempts': sq.max_attempts,
                    'is_required': sq.is_required,
                    'student_results': student_results
                })

    return templates.TemplateResponse(
        "session_details.html",
        {
            "request": request,
            "user": user,
            "session": session,
            "enrolled_students": enrolled_students,
            "is_enrolled": is_enrolled,
            "is_instructor": is_instructor,
            "can_mark_attendance": can_mark_attendance,
            "can_cancel_booking": can_cancel_booking,
            "can_book_session": can_book_session,
            "my_attendance": my_attendance,
            "my_instructor_review": my_instructor_review,
            "session_quizzes": session_quizzes,
            "now": now
        }
    )


@router.post("/sessions/{session_id}/attendance/mark")
async def mark_attendance(
    request: Request,
    session_id: int,
    student_id: int = Form(...),
    status: str = Form(...),
    notes: str = Form(None),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Mark attendance for a student (instructor only)"""
    from ..models.session import Session as SessionTypel
    from ..models.attendance import Attendance, AttendanceStatus
    from ..models.booking import Booking
    from ..models.user import UserRole
    from datetime import datetime, timezone

    # Verify user is an instructor
    if user.role != UserRole.INSTRUCTOR:
        return RedirectResponse(url=f"/sessions/{session_id}?error=unauthorized", status_code=303)

    # Verify session exists and instructor owns it
    session = db.query(SessionTypel).filter(SessionTypel.id == session_id).first()
    if not session or session.instructor_id != user.id:
        return RedirectResponse(url=f"/sessions/{session_id}?error=unauthorized", status_code=303)

    # Check if attendance can be marked (only from 15 min before start until session end)
    from zoneinfo import ZoneInfo
    budapest_tz = ZoneInfo("Europe/Budapest")
    now = datetime.now(budapest_tz)

    # Database stores timestamps WITHOUT timezone (interpreted as Budapest time)
    session_start = session.date_start
    session_end = session.date_end
    if session_start.tzinfo is None:
        session_start = session_start.replace(tzinfo=budapest_tz)
    if session_end.tzinfo is None:
        session_end = session_end.replace(tzinfo=budapest_tz)

    # Allow marking 15 minutes before session starts
    if (session_start - timedelta(minutes=15)) > now:
        return RedirectResponse(url=f"/sessions/{session_id}?error=too_early", status_code=303)

    # Cannot mark attendance after session has ended
    if now > session_end:
        return RedirectResponse(url=f"/sessions/{session_id}?error=session_ended", status_code=303)

    # Verify student is enrolled
    booking = db.query(Booking).filter(
        Booking.session_id == session_id,
        Booking.user_id == student_id
    ).first()

    if not booking:
        return RedirectResponse(url=f"/sessions/{session_id}?error=student_not_enrolled", status_code=303)

    # Convert status string to enum
    try:
        attendance_status = AttendanceStatus[status.lower()]
    except KeyError:
        return RedirectResponse(url=f"/sessions/{session_id}?error=invalid_status", status_code=303)

    # Check if attendance already exists
    attendance = db.query(Attendance).filter(
        Attendance.session_id == session_id,
        Attendance.user_id == student_id
    ).first()

    if attendance:
        # Update existing attendance
        from ..models.attendance import ConfirmationStatus, AttendanceHistory

        # CRITICAL ETHICAL REQUIREMENT: If student has confirmed, instructor can only REQUEST a change
        # Student must approve the change before it takes effect
        if attendance.confirmation_status == ConfirmationStatus.confirmed:
            # Create change request instead of directly changing
            attendance.pending_change_to = attendance_status.value
            attendance.change_requested_by = user.id
            attendance.change_requested_at = datetime.now(timezone.utc)
            attendance.change_request_reason = notes
            db.commit()

            print(f"üìù Instructor requested change from {attendance.status.value} to {attendance_status.value} - awaiting student approval")

            return RedirectResponse(
                url=f"/sessions/{session_id}?success=change_requested",
                status_code=303
            )

        old_status = attendance.status.value

        # Only log if status actually changed
        if attendance.status != attendance_status:
            # Create history entry
            history_entry = AttendanceHistory(
                attendance_id=attendance.id,
                changed_by=user.id,
                change_type='status_change',
                old_value=old_status,
                new_value=attendance_status.value,
                reason=notes
            )
            db.add(history_entry)

        attendance.status = attendance_status
        attendance.notes = notes
        attendance.updated_at = datetime.now(timezone.utc)
        attendance.marked_by = user.id

        # Update check-in time if marking as present
        if attendance_status == AttendanceStatus.present and not attendance.check_in_time:
            attendance.check_in_time = datetime.now(timezone.utc)
    else:
        # Create new attendance record
        from ..models.attendance import ConfirmationStatus, AttendanceHistory
        attendance = Attendance(
            user_id=student_id,
            session_id=session_id,
            booking_id=booking.id,
            status=attendance_status,
            notes=notes,
            marked_by=user.id,
            confirmation_status=ConfirmationStatus.pending_confirmation,
            check_in_time=datetime.now(timezone.utc) if attendance_status == AttendanceStatus.present else None
        )
        db.add(attendance)
        db.flush()  # Get attendance.id

        # Create initial history entry
        history_entry = AttendanceHistory(
            attendance_id=attendance.id,
            changed_by=user.id,
            change_type='status_change',
            old_value=None,
            new_value=attendance_status.value,
            reason=notes
        )
        db.add(history_entry)

    db.commit()

    return RedirectResponse(url=f"/sessions/{session_id}?success=attendance_marked", status_code=303)


@router.post("/sessions/{session_id}/attendance/confirm")
async def confirm_attendance(
    request: Request,
    session_id: int,
    action: str = Form(...),  # "confirm" or "dispute"
    dispute_reason: str = Form(None),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Student confirms or disputes attendance marked by instructor"""
    from ..models.session import Session as SessionTypel
    from ..models.attendance import Attendance, ConfirmationStatus
    from ..models.user import UserRole
    from datetime import datetime, timezone
    from zoneinfo import ZoneInfo

    # Verify user is a student
    if user.role != UserRole.STUDENT:
        return RedirectResponse(url=f"/sessions/{session_id}?error=unauthorized", status_code=303)

    # Get attendance record for this student
    attendance = db.query(Attendance).filter(
        Attendance.session_id == session_id,
        Attendance.user_id == user.id
    ).first()

    if not attendance:
        return RedirectResponse(url=f"/sessions/{session_id}?error=no_attendance", status_code=303)

    # Check if session has ended - student can only confirm/dispute until session end
    session = db.query(SessionTypel).filter(SessionTypel.id == session_id).first()
    if session:
        budapest_tz = ZoneInfo("Europe/Budapest")
        now = datetime.now(budapest_tz)
        session_end = session.date_end
        if session_end.tzinfo is None:
            session_end = session_end.replace(tzinfo=budapest_tz)

        if now > session_end:
            return RedirectResponse(url=f"/sessions/{session_id}?error=session_ended", status_code=303)

    # Update confirmation status
    from ..models.attendance import AttendanceHistory

    if action == "confirm":
        attendance.confirmation_status = ConfirmationStatus.confirmed
        attendance.student_confirmed_at = datetime.now(timezone.utc)
        attendance.dispute_reason = None
        message = "confirmed"

        # Log confirmation
        history_entry = AttendanceHistory(
            attendance_id=attendance.id,
            changed_by=user.id,
            change_type='confirmation',
            old_value='pending_confirmation',
            new_value='confirmed',
            reason='Student confirmed attendance'
        )
        db.add(history_entry)

    elif action == "dispute":
        attendance.confirmation_status = ConfirmationStatus.disputed
        attendance.student_confirmed_at = datetime.now(timezone.utc)
        attendance.dispute_reason = dispute_reason
        message = "disputed"

        # Log dispute
        history_entry = AttendanceHistory(
            attendance_id=attendance.id,
            changed_by=user.id,
            change_type='dispute',
            old_value='pending_confirmation',
            new_value='disputed',
            reason=dispute_reason
        )
        db.add(history_entry)

    else:
        return RedirectResponse(url=f"/sessions/{session_id}?error=invalid_action", status_code=303)

    attendance.updated_at = datetime.now(timezone.utc)
    db.commit()

    return RedirectResponse(url=f"/sessions/{session_id}?success=attendance_{message}", status_code=303)


@router.post("/sessions/{session_id}/attendance/change-request")
async def handle_change_request(
    request: Request,
    session_id: int,
    action: str = Form(...),  # "approve" or "reject"
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Student approves or rejects instructor's change request"""
    from ..models.session import Session as SessionTypel
    from ..models.attendance import Attendance, AttendanceStatus, AttendanceHistory
    from ..models.user import UserRole
    from datetime import datetime, timezone

    # Verify user is a student
    if user.role != UserRole.STUDENT:
        return RedirectResponse(url=f"/sessions/{session_id}?error=unauthorized", status_code=303)

    # Get attendance record for this student
    attendance = db.query(Attendance).filter(
        Attendance.session_id == session_id,
        Attendance.user_id == user.id
    ).first()

    if not attendance or not attendance.pending_change_to:
        return RedirectResponse(url=f"/sessions/{session_id}?error=no_change_request", status_code=303)

    if action == "approve":
        # Student approved the change - apply it
        old_status = attendance.status.value
        new_status = attendance.pending_change_to

        # Log the approved change
        history_entry = AttendanceHistory(
            attendance_id=attendance.id,
            changed_by=user.id,
            change_type='change_approved',
            old_value=old_status,
            new_value=new_status,
            reason=f"Student approved instructor's change request. Reason: {attendance.change_request_reason or 'N/A'}"
        )
        db.add(history_entry)

        # Apply the change
        attendance.status = AttendanceStatus[new_status]
        attendance.notes = attendance.change_request_reason

        # Clear change request fields
        attendance.pending_change_to = None
        attendance.change_requested_by = None
        attendance.change_requested_at = None
        attendance.change_request_reason = None

        # Keep confirmation status as confirmed
        attendance.updated_at = datetime.now(timezone.utc)

        message = "change_approved"
        print(f"‚úÖ Student approved change from {old_status} to {new_status}")

    elif action == "reject":
        # Student rejected the change - clear the request
        old_value = attendance.pending_change_to

        # Log the rejection
        history_entry = AttendanceHistory(
            attendance_id=attendance.id,
            changed_by=user.id,
            change_type='change_rejected',
            old_value=attendance.status.value,
            new_value=old_value,
            reason=f"Student rejected instructor's change request to {old_value}"
        )
        db.add(history_entry)

        # Clear change request
        attendance.pending_change_to = None
        attendance.change_requested_by = None
        attendance.change_requested_at = None
        attendance.change_request_reason = None
        attendance.updated_at = datetime.now(timezone.utc)

        message = "change_rejected"
        print(f"‚ùå Student rejected change request to {old_value}")

    else:
        return RedirectResponse(url=f"/sessions/{session_id}?error=invalid_action", status_code=303)

    db.commit()

    return RedirectResponse(url=f"/sessions/{session_id}?success={message}", status_code=303)


# Pydantic model for toggle request
class ToggleSpecializationRequest(BaseModel):
    specialization: str
    is_active: bool


@router.post("/instructor/specialization/toggle")
async def toggle_instructor_specialization(
    request: Request,
    toggle_data: ToggleSpecializationRequest,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Toggle instructor specialization active/inactive"""
    from ..models.user import UserRole
    from ..models.instructor_specialization import InstructorSpecialization

    # Only instructors can toggle
    if user.role != UserRole.INSTRUCTOR:
        raise HTTPException(status_code=403, detail="Only instructors can manage teaching specializations")

    # Find the specialization record
    spec_record = db.query(InstructorSpecialization).filter(
        InstructorSpecialization.user_id == user.id,
        InstructorSpecialization.specialization == toggle_data.specialization
    ).first()

    if not spec_record:
        raise HTTPException(status_code=404, detail="Specialization not found")

    # Update is_active status
    spec_record.is_active = toggle_data.is_active
    db.commit()

    return JSONResponse(content={"success": True, "specialization": toggle_data.specialization, "is_active": toggle_data.is_active})

# ==========================================
# SESSION TIMER/TRACKER ENDPOINTS (On-Site & Hybrid Sessions Only)
# Instructor can start/stop sessions to track actual duration
# ==========================================

@router.post("/sessions/{session_id}/start")
async def start_session(
    request: Request,
    session_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Instructor starts the session - records actual start time

    Requirements:
    - User must be instructor
    - Session must be On-Site or Hybrid type
    - Instructor must own this session
    - Session must not be already started
    """
    from datetime import datetime
    from zoneinfo import ZoneInfo
    from ..models.session import Session as SessionModel, SessionType
    from ..models.user import UserRole

    # Verify user is instructor
    if user.role != UserRole.INSTRUCTOR:
        return RedirectResponse(url=f"/sessions/{session_id}?error=unauthorized", status_code=303)

    # Get session
    session = db.query(SessionModel).filter(SessionModel.id == session_id).first()
    if not session:
        return RedirectResponse(url="/sessions?error=session_not_found", status_code=303)

    # Verify session is On-Site or Hybrid
    if session.session_type not in [SessionType.on_site, SessionType.hybrid]:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=timer_only_onsite_hybrid",
            status_code=303
        )

    # Verify instructor owns this session
    if session.instructor_id != user.id:
        return RedirectResponse(url=f"/sessions/{session_id}?error=not_your_session", status_code=303)

    # Verify session not already started
    if session.actual_start_time is not None:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=session_already_started",
            status_code=303
        )

    # Record actual start time (Budapest timezone)
    budapest_tz = ZoneInfo("Europe/Budapest")
    session.actual_start_time = datetime.now(budapest_tz)
    session.session_status = "in_progress"
    session.updated_at = datetime.now(budapest_tz)

    db.commit()

    print(f"‚úÖ Session {session_id} started by instructor {user.id} at {session.actual_start_time}")

    return RedirectResponse(
        url=f"/sessions/{session_id}?success=session_started",
        status_code=303
    )


@router.post("/sessions/{session_id}/stop")
async def stop_session(
    request: Request,
    session_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Instructor stops the session - records actual end time

    Requirements:
    - User must be instructor
    - Session must be On-Site or Hybrid type
    - Instructor must own this session
    - Session must be started first
    - Session must not be already stopped
    """
    from datetime import datetime
    from zoneinfo import ZoneInfo
    from ..models.session import Session as SessionModel, SessionType
    from ..models.user import UserRole

    # Verify user is instructor
    if user.role != UserRole.INSTRUCTOR:
        return RedirectResponse(url=f"/sessions/{session_id}?error=unauthorized", status_code=303)

    # Get session
    session = db.query(SessionModel).filter(SessionModel.id == session_id).first()
    if not session:
        return RedirectResponse(url="/sessions?error=session_not_found", status_code=303)

    # Verify session is On-Site or Hybrid
    if session.session_type not in [SessionType.on_site, SessionType.hybrid]:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=timer_only_onsite_hybrid",
            status_code=303
        )

    # Verify instructor owns this session
    if session.instructor_id != user.id:
        return RedirectResponse(url=f"/sessions/{session_id}?error=not_your_session", status_code=303)

    # Verify session was started
    if session.actual_start_time is None:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=session_not_started",
            status_code=303
        )

    # Verify session not already stopped
    if session.actual_end_time is not None:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=session_already_stopped",
            status_code=303
        )

    # Record actual end time (Budapest timezone)
    budapest_tz = ZoneInfo("Europe/Budapest")
    session.actual_end_time = datetime.now(budapest_tz)
    session.session_status = "completed"
    session.updated_at = datetime.now(budapest_tz)

    db.commit()

    # Calculate actual duration
    duration = session.actual_end_time - session.actual_start_time
    print(f"‚úÖ Session {session_id} stopped by instructor {user.id} at {session.actual_end_time}")
    print(f"   Actual duration: {duration}")

    return RedirectResponse(
        url=f"/sessions/{session_id}?success=session_stopped",
        status_code=303
    )


@router.post("/sessions/{session_id}/unlock-quiz")
async def unlock_quiz(
    request: Request,
    session_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Instructor unlocks the quiz for HYBRID sessions

    Requirements:
    - User must be instructor
    - Session must be HYBRID type
    - Instructor must own this session
    - Session must be started (in progress)
    """
    from ..models.session import Session as SessionModel, SessionType
    from ..models.user import UserRole

    # Verify user is instructor
    if user.role != UserRole.INSTRUCTOR:
        return RedirectResponse(url=f"/sessions/{session_id}?error=unauthorized", status_code=303)

    # Get session
    session = db.query(SessionModel).filter(SessionModel.id == session_id).first()
    if not session:
        return RedirectResponse(url="/sessions?error=session_not_found", status_code=303)

    # Verify session is HYBRID
    if session.session_type != SessionType.hybrid:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=unlock_only_hybrid",
            status_code=303
        )

    # Verify instructor owns this session
    if session.instructor_id != user.id:
        return RedirectResponse(url=f"/sessions/{session_id}?error=not_your_session", status_code=303)

    # Verify session was started
    if session.actual_start_time is None:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=session_not_started_unlock",
            status_code=303
        )

    # Unlock quiz
    session.quiz_unlocked = True
    db.commit()

    print(f"üîì Quiz unlocked for HYBRID session {session_id} by instructor {user.id}")

    return RedirectResponse(
        url=f"/sessions/{session_id}?success=quiz_unlocked",
        status_code=303
    )


# ==========================================
# QUIZ TAKING ROUTES (Web Interface)
# ==========================================

@router.get("/quizzes/{quiz_id}/take")
async def take_quiz(
    request: Request,
    quiz_id: int,
    session_id: Optional[int] = None,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Quiz taking page for students

    This is a web interface for quiz-taking linked from sessions.
    Students can take quizzes through this interface.
    """
    from ..models.quiz import Quiz, QuizQuestion, QuizAnswerOption, QuizAttempt
    from ..models.session import Session as SessionModel
    from sqlalchemy.orm import joinedload
    from datetime import datetime, timezone

    # Get quiz with questions and answer options
    quiz = db.query(Quiz).options(
        joinedload(Quiz.questions).joinedload(QuizQuestion.answer_options)
    ).filter(Quiz.id == quiz_id).first()

    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")

    # CRITICAL: Check if this quiz is linked to a session, and if so, verify the user is BOOKED
    if session_id:
        from ..models.booking import Booking
        from ..models.quiz import SessionQuiz
        from zoneinfo import ZoneInfo

        # Verify the quiz is actually linked to this session
        session_quiz = db.query(SessionQuiz).filter(
            SessionQuiz.session_id == session_id,
            SessionQuiz.quiz_id == quiz_id
        ).first()

        if not session_quiz:
            raise HTTPException(status_code=404, detail="Quiz not found for this session")

        # Get the session to check start time
        session = db.query(SessionModel).filter(SessionModel.id == session_id).first()
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")

        # Check if session has started (quiz only available after session start time)
        budapest_tz = ZoneInfo("Europe/Budapest")
        now = datetime.now(budapest_tz)
        session_start = session.date_start
        if session_start.tzinfo is None:
            session_start = session_start.replace(tzinfo=budapest_tz)

        if now < session_start:
            raise HTTPException(
                status_code=403,
                detail=f"Quiz not available yet. Session starts at {session_start.strftime('%Y-%m-%d %H:%M')}."
            )

        # Check if user is BOOKED for this session
        booking = db.query(Booking).filter(
            Booking.session_id == session_id,
            Booking.user_id == user.id,
            Booking.status == 'CONFIRMED'
        ).first()

        if not booking:
            raise HTTPException(
                status_code=403,
                detail="You must book this session before taking the quiz. Please enroll first!"
            )

    # Check if user already has an active (incomplete) attempt
    active_attempt = db.query(QuizAttempt).filter(
        QuizAttempt.user_id == user.id,
        QuizAttempt.quiz_id == quiz_id,
        QuizAttempt.completed_at == None
    ).first()

    # If no active attempt, create one
    if not active_attempt:
        active_attempt = QuizAttempt(
            user_id=user.id,
            quiz_id=quiz_id,
            started_at=datetime.now(timezone.utc),
            total_questions=len(quiz.questions)
        )
        db.add(active_attempt)
        db.commit()
        db.refresh(active_attempt)

    # Calculate remaining time
    elapsed_seconds = (datetime.now(timezone.utc) - active_attempt.started_at).total_seconds()
    time_limit_seconds = quiz.time_limit_minutes * 60
    remaining_seconds = max(0, int(time_limit_seconds - elapsed_seconds))

    # If time expired, auto-submit with 0 score
    if remaining_seconds == 0:
        active_attempt.completed_at = datetime.now(timezone.utc)
        active_attempt.score = 0.0
        active_attempt.correct_answers = 0
        active_attempt.passed = False
        active_attempt.xp_awarded = 0
        active_attempt.time_spent_minutes = quiz.time_limit_minutes
        db.commit()

        return templates.TemplateResponse("quiz_result.html", {
            "request": request,
            "user": user,
            "quiz": quiz,
            "session": None,
            "session_id": session_id,
            "score": 0.0,
            "passed": False,
            "correct_count": 0,
            "total_questions": len(quiz.questions),
            "xp_awarded": 0,
            "time_spent": quiz.time_limit_minutes
        })

    # Get session if provided
    session = None
    if session_id:
        session = db.query(SessionModel).filter(SessionModel.id == session_id).first()

    return templates.TemplateResponse("quiz_take.html", {
        "request": request,
        "user": user,
        "quiz": quiz,
        "session": session,
        "session_id": session_id,
        "attempt_id": active_attempt.id,
        "remaining_seconds": remaining_seconds
    })


@router.post("/quizzes/{quiz_id}/submit")
async def submit_quiz(
    request: Request,
    quiz_id: int,
    session_id: Optional[str] = Form(None),
    attempt_id: int = Form(...),
    time_spent: float = Form(...),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Submit quiz answers and calculate score
    Simple scoring system: Understood (pass) / Needs Review (fail)
    """
    from ..models.quiz import Quiz, QuizAttempt, QuizUserAnswer, QuizAnswerOption
    from ..models.session import Session as SessionModel
    from datetime import datetime, timezone

    # Get quiz
    quiz = db.query(Quiz).filter(Quiz.id == quiz_id).first()
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")

    # CRITICAL: Check if this quiz is linked to a session, and if so, verify the user is BOOKED
    if session_id and session_id != "None":
        session_id_int = int(session_id)
        from ..models.booking import Booking
        from ..models.quiz import SessionQuiz
        from zoneinfo import ZoneInfo

        # Verify the quiz is actually linked to this session
        session_quiz = db.query(SessionQuiz).filter(
            SessionQuiz.session_id == session_id_int,
            SessionQuiz.quiz_id == quiz_id
        ).first()

        if not session_quiz:
            raise HTTPException(status_code=404, detail="Quiz not found for this session")

        # Get the session to check start time
        session = db.query(SessionModel).filter(SessionModel.id == session_id_int).first()
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")

        # Check if session has started (quiz only available after session start time)
        budapest_tz = ZoneInfo("Europe/Budapest")
        now = datetime.now(budapest_tz)
        session_start = session.date_start
        if session_start.tzinfo is None:
            session_start = session_start.replace(tzinfo=budapest_tz)

        if now < session_start:
            raise HTTPException(
                status_code=403,
                detail=f"Quiz not available yet. Session starts at {session_start.strftime('%Y-%m-%d %H:%M')}."
            )

        # Check if user is BOOKED for this session
        booking = db.query(Booking).filter(
            Booking.session_id == session_id_int,
            Booking.user_id == user.id,
            Booking.status == 'CONFIRMED'
        ).first()

        if not booking:
            raise HTTPException(
                status_code=403,
                detail="You must book this session before submitting the quiz!"
            )

    # Get the active attempt
    attempt = db.query(QuizAttempt).filter(
        QuizAttempt.id == attempt_id,
        QuizAttempt.user_id == user.id,
        QuizAttempt.quiz_id == quiz_id
    ).first()

    if not attempt:
        raise HTTPException(status_code=404, detail="Quiz attempt not found")

    # Check if already completed
    if attempt.completed_at:
        raise HTTPException(status_code=400, detail="Quiz already submitted")

    # Get form data
    form_data = await request.form()

    # Calculate score
    correct_count = 0
    total_points = 0
    earned_points = 0

    for question in quiz.questions:
        total_points += question.points
        field_name = f"question_{question.id}"
        selected_option_id = form_data.get(field_name)

        if selected_option_id:
            selected_option_id = int(selected_option_id)
            option = db.query(QuizAnswerOption).filter(QuizAnswerOption.id == selected_option_id).first()

            if option and option.is_correct:
                correct_count += 1
                earned_points += question.points

            # Save user answer
            user_answer = QuizUserAnswer(
                attempt_id=attempt.id,
                question_id=question.id,
                selected_option_id=selected_option_id,
                is_correct=option.is_correct if option else False
            )
            db.add(user_answer)

    # Calculate percentage score
    score = (earned_points / total_points * 100) if total_points > 0 else 0
    # CRITICAL: passing_score is stored as decimal (0.75 = 75%), score is percentage (75)
    passed = score >= (quiz.passing_score * 100)

    # Update attempt with completion
    attempt.completed_at = datetime.now(timezone.utc)
    attempt.time_spent_minutes = time_spent
    attempt.score = score
    attempt.correct_answers = correct_count
    attempt.passed = passed
    attempt.xp_awarded = quiz.xp_reward if passed else 0

    # Update user_stats with earned XP (GAMIFICATION SYNC)
    if attempt.xp_awarded > 0:
        from ..models.gamification import UserStats
        user_stats = db.query(UserStats).filter(UserStats.user_id == user.id).first()

        if not user_stats:
            # Create user_stats if doesn't exist
            user_stats = UserStats(
                user_id=user.id,
                total_xp=attempt.xp_awarded,
                level=1
            )
            db.add(user_stats)
        else:
            # Add XP to existing total
            user_stats.total_xp = (user_stats.total_xp or 0) + attempt.xp_awarded
            # Update level (1000 XP per level)
            user_stats.level = max(1, user_stats.total_xp // 1000)

    db.commit()

    # Get session for back link
    session = None
    if session_id and session_id.strip():
        try:
            session = db.query(SessionModel).filter(SessionModel.id == int(session_id)).first()

            # VIRTUAL SESSION: Auto-mark attendance if quiz passed
            if session and session.session_type.value == 'virtual' and passed:
                from ..models.attendance import Attendance
                from ..models.booking import Booking

                # Find student's booking
                booking = db.query(Booking).filter(
                    Booking.user_id == user.id,
                    Booking.session_id == session.id
                ).first()

                if booking:
                    # Check if attendance already exists
                    existing_attendance = db.query(Attendance).filter(
                        Attendance.user_id == user.id,
                        Attendance.session_id == session.id
                    ).first()

                    if not existing_attendance:
                        # Auto-create attendance as 'present' for successful quiz
                        auto_attendance = Attendance(
                            user_id=user.id,
                            session_id=session.id,
                            booking_id=booking.id,
                            status='present',
                            check_in_time=datetime.now(timezone.utc)
                        )
                        db.add(auto_attendance)
                        db.commit()
                        print(f"‚úÖ Auto-marked attendance for VIRTUAL session {session.id} - student {user.email}")

        except ValueError:
            pass

    # Render result page
    return templates.TemplateResponse("quiz_result.html", {
        "request": request,
        "user": user,
        "quiz": quiz,
        "session": session,
        "session_id": session_id,
        "score": score,
        "passed": passed,
        "correct_count": correct_count,
        "total_questions": len(quiz.questions),
        "xp_awarded": attempt.xp_awarded,
        "time_spent": time_spent
    })


# ==========================================
# PERFORMANCE REVIEW ENDPOINTS (On-Site Sessions Only)
# Two-way evaluation system for On-Site training sessions
# ==========================================

@router.post("/sessions/{session_id}/evaluate-student/{student_id}")
async def evaluate_student_performance(
    request: Request,
    session_id: int,
    student_id: int,
    punctuality: int = Form(...),
    engagement: int = Form(...),
    focus: int = Form(...),
    collaboration: int = Form(...),
    attitude: int = Form(...),
    comments: str = Form(None),
    update_reason: str = Form(None),  # Required when updating existing review
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Instructor evaluates student performance (On-Site sessions only)

    Requirements:
    - User must be instructor
    - Session must be On-Site type
    - Student must have attended the session
    """
    from datetime import datetime, timezone
    from ..models.session import Session as SessionModel, SessionType
    from ..models.user import UserRole
    from ..models.attendance import Attendance, AttendanceStatus
    from ..models.performance_review import StudentPerformanceReview
    
    # Verify user is instructor
    if user.role != UserRole.INSTRUCTOR:
        return RedirectResponse(url=f"/sessions/{session_id}?error=unauthorized", status_code=303)
    
    # Get session and verify it's On-Site
    session = db.query(SessionModel).filter(SessionModel.id == session_id).first()
    if not session:
        return RedirectResponse(url="/sessions?error=session_not_found", status_code=303)

    # Verify instructor owns this session
    if session.instructor_id != user.id:
        return RedirectResponse(url=f"/sessions/{session_id}?error=not_your_session", status_code=303)
    
    # CRITICAL: Verify session has ended before allowing evaluation
    # Use actual_end_time if available (instructor stopped session), otherwise use scheduled date_end
    if session.actual_end_time is None:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=session_not_stopped",
            status_code=303
        )

    # Verify student attended
    attendance = db.query(Attendance).filter(
        Attendance.session_id == session_id,
        Attendance.user_id == student_id
    ).first()

    if not attendance or attendance.status == AttendanceStatus.absent:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=student_not_attended",
            status_code=303
        )

    # Check if review already exists
    existing_review = db.query(StudentPerformanceReview).filter(
        StudentPerformanceReview.session_id == session_id,
        StudentPerformanceReview.student_id == student_id
    ).first()

    # NOTE: Instructor CAN modify performance review even after session ends (with update_reason)
    # This is different from attendance which CANNOT be modified after session ends

    # Validate scores (1-5)
    scores = [punctuality, engagement, focus, collaboration, attitude]
    if any(score < 1 or score > 5 for score in scores):
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=invalid_scores",
            status_code=303
        )

    if existing_review:
        # Update existing review - require update_reason
        if not update_reason or len(update_reason.strip()) == 0:
            return RedirectResponse(
                url=f"/sessions/{session_id}?error=update_reason_required",
                status_code=303
            )

        # Update existing review
        existing_review.punctuality = punctuality
        existing_review.engagement = engagement
        existing_review.focus = focus
        existing_review.collaboration = collaboration
        existing_review.attitude = attitude

        # Append update reason to comments
        timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')
        update_note = f"\n\n---\n[UPDATE {timestamp}]\nReason: {update_reason.strip()}"
        if comments:
            existing_review.comments = comments + update_note
        else:
            existing_review.comments = (existing_review.comments or "") + update_note

        existing_review.updated_at = datetime.now(timezone.utc)

        # RECALCULATE XP when review is updated
        average_score = (punctuality + engagement + focus + collaboration + attitude) / 5.0
        xp_earned = int(50 * (average_score / 5.0))  # Base 50 XP * performance ratio

        # Get student specialization
        student = db.query(User).filter(User.id == student_id).first()
        student_spec = student.specialization.value if student and student.specialization else None

        # Update specialization progress XP
        _update_specialization_xp(db, student_id, student_spec, xp_earned, session_id, is_update=True)

        print(f"‚ôªÔ∏è XP RECALCULATED: Student {student_id} | Session {session_id} | Score: {average_score:.1f}/5.0 | XP: {xp_earned}")
    else:
        # Create new review
        review = StudentPerformanceReview(
            session_id=session_id,
            student_id=student_id,
            instructor_id=user.id,
            punctuality=punctuality,
            engagement=engagement,
            focus=focus,
            collaboration=collaboration,
            attitude=attitude,
            comments=comments
        )
        db.add(review)
        db.flush()  # Get review ID

        # AWARD XP for new review
        average_score = (punctuality + engagement + focus + collaboration + attitude) / 5.0
        xp_earned = int(50 * (average_score / 5.0))  # Base 50 XP * performance ratio

        # Get student specialization
        student = db.query(User).filter(User.id == student_id).first()
        student_spec = student.specialization.value if student and student.specialization else None

        # Update specialization progress XP
        _update_specialization_xp(db, student_id, student_spec, xp_earned, session_id, is_update=False)

        print(f"üéâ XP AWARDED: Student {student_id} | Session {session_id} | Spec: {student_spec} | Score: {average_score:.1f}/5.0 | XP: {xp_earned}")

    db.commit()

    return RedirectResponse(
        url=f"/sessions/{session_id}?success=student_evaluated",
        status_code=303
    )


@router.post("/sessions/{session_id}/evaluate-instructor")
async def evaluate_instructor_session(
    request: Request,
    session_id: int,
    instructor_clarity: int = Form(...),
    support_approachability: int = Form(...),
    session_structure: int = Form(...),
    relevance: int = Form(...),
    environment: int = Form(...),
    engagement_feeling: int = Form(...),
    feedback_quality: int = Form(...),
    satisfaction: int = Form(...),
    comments: str = Form(None),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Student evaluates instructor and session quality (On-Site sessions only)

    Requirements:
    - User must be student
    - Session must be On-Site type
    - Student must have attended the session (present/late status)
    """
    from datetime import datetime, timezone
    from ..models.session import Session as SessionModel, SessionType
    from ..models.user import UserRole
    from ..models.attendance import Attendance, AttendanceStatus
    from ..models.performance_review import InstructorSessionReview
    
    # Verify user is student
    if user.role != UserRole.STUDENT:
        return RedirectResponse(url=f"/sessions/{session_id}?error=students_only", status_code=303)
    
    # Get session
    session = db.query(SessionModel).filter(SessionModel.id == session_id).first()
    if not session:
        return RedirectResponse(url="/sessions?error=session_not_found", status_code=303)

    # CRITICAL: Verify session has ended before allowing evaluation
    # Use actual_end_time if available (instructor stopped session), otherwise use scheduled date_end
    if session.actual_end_time is None:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=session_not_stopped",
            status_code=303
        )

    # CRITICAL: Verify student attended (present or late - NOT absent)
    attendance = db.query(Attendance).filter(
        Attendance.session_id == session_id,
        Attendance.user_id == user.id
    ).first()
    
    if not attendance or attendance.status == AttendanceStatus.absent:
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=must_attend_to_review",
            status_code=303
        )
    
    # Validate scores (1-5)
    scores = [
        instructor_clarity, support_approachability, session_structure,
        relevance, environment, engagement_feeling, feedback_quality, satisfaction
    ]
    if any(score < 1 or score > 5 for score in scores):
        return RedirectResponse(
            url=f"/sessions/{session_id}?error=invalid_scores",
            status_code=303
        )
    
    # Check if review already exists
    existing_review = db.query(InstructorSessionReview).filter(
        InstructorSessionReview.session_id == session_id,
        InstructorSessionReview.student_id == user.id
    ).first()
    
    if existing_review:
        # Update existing review
        existing_review.instructor_clarity = instructor_clarity
        existing_review.support_approachability = support_approachability
        existing_review.session_structure = session_structure
        existing_review.relevance = relevance
        existing_review.environment = environment
        existing_review.engagement_feeling = engagement_feeling
        existing_review.feedback_quality = feedback_quality
        existing_review.satisfaction = satisfaction
        existing_review.comments = comments
        existing_review.updated_at = datetime.now(timezone.utc)
    else:
        # Create new review
        review = InstructorSessionReview(
            session_id=session_id,
            student_id=user.id,
            instructor_id=session.instructor_id,
            instructor_clarity=instructor_clarity,
            support_approachability=support_approachability,
            session_structure=session_structure,
            relevance=relevance,
            environment=environment,
            engagement_feeling=engagement_feeling,
            feedback_quality=feedback_quality,
            satisfaction=satisfaction,
            comments=comments
        )
        db.add(review)
    
    db.commit()

    return RedirectResponse(
        url=f"/sessions/{session_id}?success=instructor_evaluated",
        status_code=303
    )


@router.get("/api/sessions/calendar")
async def get_calendar_sessions(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Get sessions for calendar display
    - Instructors: Only sessions assigned to them
    - Students: Only sessions from APPROVED semesters
    - Admin: All sessions
    """
    from ..models.session import Session as SessionType
    from ..models.user import UserRole
    from ..models.booking import Booking
    from ..models.semester_enrollment import SemesterEnrollment, EnrollmentStatus

    print(f"üìÖ CALENDAR API CALLED - User: {user.email}, Role: {user.role}")

    # Build base query
    query = db.query(SessionType)

    # Filter by role
    if user.role == UserRole.INSTRUCTOR:
        # Only show sessions where this instructor is assigned
        query = query.filter(SessionType.instructor_id == user.id)
    elif user.role == UserRole.STUDENT:
        # Only show sessions from APPROVED semesters
        approved_enrollments = db.query(SemesterEnrollment).filter(
            SemesterEnrollment.user_id == user.id,
            SemesterEnrollment.request_status == EnrollmentStatus.APPROVED,
            SemesterEnrollment.is_active == True
        ).all()

        approved_semester_ids = [e.semester_id for e in approved_enrollments]

        if approved_semester_ids:
            query = query.filter(SessionType.semester_id.in_(approved_semester_ids))
        else:
            # No approved enrollments = no sessions visible
            sessions = []
            calendar_events = []
            return JSONResponse(content=calendar_events)

    # Execute query
    sessions = query.order_by(SessionType.date_start.asc()).all()

    # Format for FullCalendar
    calendar_events = []
    for session in sessions:
        calendar_events.append({
            'id': session.id,
            'title': session.title,
            'description': session.description,
            'date_start': session.date_start.isoformat() if session.date_start else None,
            'date_end': session.date_end.isoformat() if session.date_end else None,
            'session_type': session.session_type.value if session.session_type else 'on_site',
            'location': session.location,
            'capacity': session.capacity
        })

    return JSONResponse(content=calendar_events)


# ============================================================================
# ADMIN ROUTES - Role-protected administrative functions
# ============================================================================

@router.get("/admin/users", response_class=HTMLResponse)
async def admin_users_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Admin-only: User management page"""
    from ..models.user import UserRole
    
    # Security check: ONLY admins can access
    if user.role != UserRole.ADMIN:
        raise HTTPException(status_code=403, detail="Admin access required")
    
    # Get all users
    all_users = db.query(User).order_by(User.id).all()
    
    return templates.TemplateResponse(
        "admin/users.html",
        {
            "request": request,
            "user": user,
            "all_users": all_users
        }
    )


@router.get("/admin/semesters", response_class=HTMLResponse)
async def admin_semesters_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Admin-only: Semester management page"""
    from ..models.user import UserRole
    from ..models.semester import Semester
    
    # Security check: ONLY admins can access
    if user.role != UserRole.ADMIN:
        raise HTTPException(status_code=403, detail="Admin access required")
    
    # Get all semesters
    semesters = db.query(Semester).order_by(Semester.start_date.desc()).all()
    
    return templates.TemplateResponse(
        "admin/semesters.html",
        {
            "request": request,
            "user": user,
            "semesters": semesters
        }
    )


@router.get("/admin/enrollments", response_class=HTMLResponse)
async def admin_enrollments_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Admin-only: Unified Semester Enrollment Management page (replaces /admin/payments)"""
    from ..models.user import UserRole
    from ..models.semester import Semester
    from ..models.semester_enrollment import SemesterEnrollment, EnrollmentStatus
    from ..models.license import UserLicense
    from sqlalchemy.orm import joinedload

    # Security check: ONLY admins can access
    if user.role != UserRole.ADMIN:
        raise HTTPException(status_code=403, detail="Admin access required")

    # Get all semesters (for dropdown)
    semesters = db.query(Semester).order_by(Semester.start_date.desc()).all()

    # Get all students with their licenses
    students = db.query(User).filter(User.role == UserRole.STUDENT).order_by(User.name).all()

    # Attach user licenses to each student
    for student in students:
        student.all_licenses = db.query(UserLicense).filter(
            UserLicense.user_id == student.id
        ).all()
        # For specialization management section (moved from /admin/payments)
        student.active_specializations = student.all_licenses

    # Get ALL truly active semesters (running TODAY - between start_date and end_date)
    from datetime import date
    today = date.today()

    active_semesters = db.query(Semester).filter(
        Semester.is_active == True,
        Semester.start_date <= today,
        Semester.end_date >= today
    ).order_by(Semester.code, Semester.start_date.desc()).all()

    # Add specialization_type and extract location from code
    import re
    for semester in active_semesters:
        # Extract specialization and location from code
        # Examples:
        #   "LFA_PLAYER_PRE_2025_JAN_BUDA" -> spec: "LFA_PLAYER_PRE", location: "Buda"
        #   "LFA_PLAYER_PRO_2025-26_PEST" -> spec: "LFA_PLAYER_PRO", location: "Pest"
        #   "GANCUJU_WINTER_2025_BUDAPEST" -> spec: "GANCUJU_PLAYER", location: "Budapest"
        #   "INTERNSHIP_FALL_2025_BUDAPEST" -> spec: "INTERNSHIP", location: "Budapest"

        code = semester.code

        # Extract location suffix (BUDA, PEST, BUDAPEST, city names)
        location_match = re.search(r'_(BUDA|PEST|BUDAPEST|DEBRECEN|SZEGED|MISKOLC|GYOR)$', code, re.IGNORECASE)
        if location_match:
            location_suffix = location_match.group(1)
            # Set location_venue if not already set in DB
            if not semester.location_venue:
                if location_suffix.upper() in ['BUDA', 'PEST']:
                    semester.location_venue = f"{location_suffix.capitalize()} Campus"
                    semester.location_city = "Budapest"
                else:
                    semester.location_city = location_suffix.capitalize()

            # Remove location suffix for specialization extraction
            code_without_location = code[:location_match.start()]
        else:
            code_without_location = code

        # Remove year patterns (4 digits, or YYYY-YY format, or Q1/Q2/Q3/Q4, or month names)
        code_clean = re.sub(r'_\d{4}(-\d{2})?(_[A-Z]{3,6})?$', '', code_without_location)
        code_clean = re.sub(r'_\d{4}_Q\d$', '', code_clean)

        # Special case: GANCUJU should become GANCUJU_PLAYER
        if code_clean.startswith('GANCUJU'):
            semester.specialization_type = 'GANCUJU_PLAYER'
        else:
            semester.specialization_type = code_clean if code_clean else None

    # Get ALL enrollments for ALL active semesters
    all_enrollments = []
    if active_semesters:
        semester_ids = [s.id for s in active_semesters]
        all_enrollments = (
            db.query(SemesterEnrollment)
            .options(
                joinedload(SemesterEnrollment.user),
                joinedload(SemesterEnrollment.user_license),
                joinedload(SemesterEnrollment.semester)
            )
            .filter(SemesterEnrollment.semester_id.in_(semester_ids))
            .order_by(SemesterEnrollment.requested_at.desc())
            .all()
        )

    # Group enrollments by specialization + location
    from ..models.specialization import SpecializationType
    from collections import defaultdict

    # First group by specialization, then by location within each specialization
    specialization_groups = {}
    for spec_type in SpecializationType:
        spec_enrollments = [e for e in all_enrollments if e.user_license.specialization_type == spec_type.value]

        # Get all active semesters for this specialization type
        spec_semesters = [s for s in active_semesters if s.specialization_type == spec_type.value]

        # Group by location_venue within this specialization
        location_groups = defaultdict(list)

        # First, add enrollments to their locations
        for enrollment in spec_enrollments:
            # Get the location_venue from the semester
            location_key = enrollment.semester.location_venue if enrollment.semester.location_venue else "No Location"
            location_groups[location_key].append(enrollment)

        # Then, ensure EVERY active semester location has a group (even if empty)
        for semester in spec_semesters:
            location_key = semester.location_venue if semester.location_venue else "No Location"
            if location_key not in location_groups:
                location_groups[location_key] = []

        # Create a group for each location
        spec_location_groups = {}
        for location_venue, enrollments in location_groups.items():
            # Separate pending and active
            pending = [e for e in enrollments if e.request_status == EnrollmentStatus.PENDING]
            active = [e for e in enrollments if e.request_status != EnrollmentStatus.PENDING]

            spec_location_groups[location_venue] = {
                'pending': pending,
                'active': active,
                'total_count': len(enrollments),
                'location_venue': location_venue
            }

        specialization_groups[spec_type.value] = spec_location_groups

    # üí≥ NEW: Get all UserLicenses that DON'T have any SemesterEnrollment yet
    # These are "newcomers" who selected specializations but haven't enrolled yet
    # Admin needs to see these to verify payment BEFORE student can request enrollment
    enrollment_license_ids = [e.user_license_id for e in all_enrollments]

    newcomer_licenses = (
        db.query(UserLicense)
        .options(joinedload(UserLicense.user))
        .filter(
            UserLicense.id.notin_(enrollment_license_ids) if enrollment_license_ids else True,
            UserLicense.payment_reference_code.isnot(None)
        )
        .order_by(UserLicense.started_at.desc())
        .all()
    )

    # Group newcomer licenses by specialization
    newcomer_groups = {}
    for spec_type in SpecializationType:
        newcomer_groups[spec_type.value] = [
            lic for lic in newcomer_licenses
            if lic.specialization_type == spec_type.value
        ]

    print(f"üìã Admin Enrollments: {len(all_enrollments)} enrollments, {len(newcomer_licenses)} newcomer licenses")

    return templates.TemplateResponse(
        "admin/enrollments.html",
        {
            "request": request,
            "user": user,
            "semesters": semesters,
            "students": students,
            "active_semesters": active_semesters,  # CHANGED: Multiple active semesters
            "specialization_groups": specialization_groups,  # NEW: Grouped by spec
            "newcomer_groups": newcomer_groups,  # NEW: Licenses awaiting first payment verification
            "SpecializationType": SpecializationType  # For template iteration
        }
    )


@router.get("/admin/payments", response_class=HTMLResponse)
async def admin_payments_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Admin-only: Payment Management page (invoice requests + license payment verification)"""
    from ..models.user import UserRole
    from ..models.invoice_request import InvoiceRequest
    from ..models.license import UserLicense
    from ..models.semester_enrollment import SemesterEnrollment
    from sqlalchemy.orm import joinedload

    # Security check: ONLY admins can access
    if user.role != UserRole.ADMIN:
        raise HTTPException(status_code=403, detail="Admin access required")

    # Get all invoice requests (ordered by most recent first)
    invoice_requests = (
        db.query(InvoiceRequest)
        .options(joinedload(InvoiceRequest.user))
        .order_by(InvoiceRequest.created_at.desc())
        .all()
    )

    # Get all UserLicenses that DON'T have any SemesterEnrollment yet
    # These are "newcomers" who selected specializations but haven't enrolled yet
    all_enrollments = db.query(SemesterEnrollment).all()
    enrollment_license_ids = [e.user_license_id for e in all_enrollments]

    newcomer_licenses = (
        db.query(UserLicense)
        .options(joinedload(UserLicense.user))
        .filter(
            UserLicense.id.notin_(enrollment_license_ids) if enrollment_license_ids else True,
            UserLicense.payment_reference_code.isnot(None)
        )
        .order_by(UserLicense.started_at.desc())
        .all()
    )

    # Group newcomer licenses by specialization
    from ..models.specialization import SpecializationType
    newcomer_groups = {}
    for spec_type in SpecializationType:
        newcomer_groups[spec_type.value] = [
            lic for lic in newcomer_licenses
            if lic.specialization_type == spec_type.value
        ]

    print(f"üí≥ Admin Payments: {len(invoice_requests)} invoice requests, {len(newcomer_licenses)} newcomer licenses")

    return templates.TemplateResponse(
        "admin/payments.html",
        {
            "request": request,
            "user": user,
            "invoice_requests": invoice_requests,
            "newcomer_groups": newcomer_groups,
            "SpecializationType": SpecializationType
        }
    )


@router.get("/admin/coupons", response_class=HTMLResponse)
async def admin_coupons_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Admin-only: Coupon Management page"""
    from ..models.user import UserRole
    from ..models.coupon import Coupon
    from datetime import datetime, timezone

    # Security check: ONLY admins can access
    if user.role != UserRole.ADMIN:
        raise HTTPException(status_code=403, detail="Admin access required")

    # Get all coupons (ordered by creation date)
    coupons = db.query(Coupon).order_by(Coupon.created_at.desc()).all()

    # Add validity status
    for coupon in coupons:
        coupon.is_currently_valid = coupon.is_valid()

    print(f"üéüÔ∏è Admin Coupons: {len(coupons)} coupons")

    return templates.TemplateResponse(
        "admin/coupons.html",
        {
            "request": request,
            "user": user,
            "coupons": coupons,
            "today": datetime.now(timezone.utc)
        }
    )


@router.get("/admin/invitation-codes", response_class=HTMLResponse)
async def admin_invitation_codes_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Admin-only: Partner Invitation Codes Management page"""
    from ..models.user import UserRole
    from ..models.invitation_code import InvitationCode
    from datetime import datetime, timezone

    # Security check: ONLY admins can access
    if user.role != UserRole.ADMIN:
        raise HTTPException(status_code=403, detail="Admin access required")

    # Get all invitation codes (ordered by creation date)
    codes = db.query(InvitationCode).order_by(InvitationCode.created_at.desc()).all()

    # Enrich with user names
    for code in codes:
        if code.used_by_user_id:
            used_by_user = db.query(User).filter(User.id == code.used_by_user_id).first()
            code.used_by_name = used_by_user.name if used_by_user else None
        else:
            code.used_by_name = None

        if code.created_by_admin_id:
            admin = db.query(User).filter(User.id == code.created_by_admin_id).first()
            code.created_by_name = admin.name if admin else None
        else:
            code.created_by_name = None

    print(f"üéÅ Admin Invitation Codes: {len(codes)} codes")

    return templates.TemplateResponse(
        "admin/invitation_codes.html",
        {
            "request": request,
            "user": user,
            "codes": codes,
            "now": datetime.now(timezone.utc)
        }
    )


@router.get("/instructor/enrollments", response_class=HTMLResponse)
async def instructor_enrollments_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Instructor-only: View and approve enrollment requests for their semesters"""
    from ..models.user import UserRole
    from ..models.semester import Semester
    from ..models.semester_enrollment import SemesterEnrollment, EnrollmentStatus
    from sqlalchemy.orm import joinedload

    # Security check: ONLY instructors can access
    if user.role != UserRole.INSTRUCTOR:
        raise HTTPException(status_code=403, detail="Instructor access required")

    # Get all semesters where this instructor is the master instructor
    instructor_semesters = db.query(Semester).filter(
        Semester.master_instructor_id == user.id
    ).order_by(Semester.start_date.desc()).all()

    # Get semester IDs for filtering enrollments
    semester_ids = [s.id for s in instructor_semesters]

    # Get ALL enrollments for instructor's semesters
    all_enrollments = []
    if semester_ids:
        all_enrollments = (
            db.query(SemesterEnrollment)
            .options(
                joinedload(SemesterEnrollment.user),
                joinedload(SemesterEnrollment.user_license),
                joinedload(SemesterEnrollment.semester)
            )
            .filter(SemesterEnrollment.semester_id.in_(semester_ids))
            .order_by(SemesterEnrollment.requested_at.desc())
            .all()
        )

    # Group enrollments by specialization
    from ..models.specialization import SpecializationType

    specialization_groups = {}
    for spec_type in SpecializationType:
        spec_enrollments = [e for e in all_enrollments if e.user_license.specialization_type == spec_type.value]

        # Separate pending and active
        pending = [e for e in spec_enrollments if e.request_status == EnrollmentStatus.PENDING]
        active = [e for e in spec_enrollments if e.request_status != EnrollmentStatus.PENDING]

        specialization_groups[spec_type.value] = {
            'pending': pending,
            'active': active,
            'total_count': len(spec_enrollments)
        }

    print(f"ü•ã Instructor {user.name}: {len(instructor_semesters)} semesters, {len(all_enrollments)} enrollments")

    return templates.TemplateResponse(
        "instructor/enrollments.html",
        {
            "request": request,
            "user": user,
            "instructor_semesters": instructor_semesters,
            "specialization_groups": specialization_groups,
            "SpecializationType": SpecializationType
        }
    )


# ‚öΩ INSTRUCTOR: Edit Student Football Skills
@router.get("/instructor/students/{student_id}/skills/{license_id}", response_class=HTMLResponse)
async def instructor_edit_student_skills_page(
    request: Request,
    student_id: int,
    license_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Instructor-only: Edit football skills for LFA Player students"""
    from ..models.user import UserRole
    from ..models.license import UserLicense

    # Security check: ONLY instructors can access
    if user.role != UserRole.INSTRUCTOR:
        raise HTTPException(status_code=403, detail="Instructor access required")

    # Get student
    student = db.query(User).filter(User.id == student_id).first()
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")

    # Get license
    license = db.query(UserLicense).filter(UserLicense.id == license_id).first()
    if not license or license.user_id != student_id:
        raise HTTPException(status_code=404, detail="License not found")

    # Check if this is an LFA Player specialization
    if not license.specialization_type.startswith("LFA_PLAYER_"):
        raise HTTPException(
            status_code=400,
            detail=f"Football skills are only available for LFA Player specializations, not {license.specialization_type}"
        )

    # Get specialization display name
    spec_display_map = {
        "LFA_PLAYER_PRE": "LFA Player PRE (Ages 5-8)",
        "LFA_PLAYER_YOUTH": "LFA Player Youth (Ages 9-14)",
        "LFA_PLAYER_AMATEUR": "LFA Player Amateur (Ages 14+)",
        "LFA_PLAYER_PRO": "LFA Player PRO (Ages 16+)"
    }
    specialization_display = spec_display_map.get(license.specialization_type, license.specialization_type)

    # Get color
    specialization_color = "#f1c40f"  # Yellow for all LFA Player specs

    return templates.TemplateResponse(
        "instructor/student_skills.html",
        {
            "request": request,
            "user": user,
            "student": student,
            "license": license,
            "license_id": license_id,
            "current_skills": license.football_skills,
            "specialization_display": specialization_display,
            "specialization_color": specialization_color
        }
    )


@router.post("/instructor/students/{student_id}/skills/{license_id}")
async def instructor_update_student_skills(
    request: Request,
    student_id: int,
    license_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web),
    heading: float = Form(...),
    shooting: float = Form(...),
    crossing: float = Form(...),
    passing: float = Form(...),
    dribbling: float = Form(...),
    ball_control: float = Form(...),
    instructor_notes: str = Form("")
):
    """Instructor-only: Update football skills for a student"""
    from ..models.user import UserRole
    from ..models.license import UserLicense
    from datetime import datetime, timezone

    # Security check: ONLY instructors can update
    if user.role != UserRole.INSTRUCTOR:
        raise HTTPException(status_code=403, detail="Instructor access required")

    # Get student
    student = db.query(User).filter(User.id == student_id).first()
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")

    # Get license
    license = db.query(UserLicense).filter(UserLicense.id == license_id).first()
    if not license or license.user_id != student_id:
        raise HTTPException(status_code=404, detail="License not found")

    # Check if this is an LFA Player specialization
    if not license.specialization_type.startswith("LFA_PLAYER_"):
        raise HTTPException(
            status_code=400,
            detail=f"Football skills are only available for LFA Player specializations"
        )

    # Validate ranges
    skills = {
        "heading": heading,
        "shooting": shooting,
        "crossing": crossing,
        "passing": passing,
        "dribbling": dribbling,
        "ball_control": ball_control
    }

    for skill_name, value in skills.items():
        if value < 0 or value > 100:
            # Get specialization display name
            spec_display_map = {
                "LFA_PLAYER_PRE": "LFA Player PRE (Ages 5-8)",
                "LFA_PLAYER_YOUTH": "LFA Player Youth (Ages 9-14)",
                "LFA_PLAYER_AMATEUR": "LFA Player Amateur (Ages 14+)",
                "LFA_PLAYER_PRO": "LFA Player PRO (Ages 16+)"
            }
            specialization_display = spec_display_map.get(license.specialization_type, license.specialization_type)
            specialization_color = "#f1c40f"

            return templates.TemplateResponse(
                "instructor/student_skills.html",
                {
                    "request": request,
                    "user": user,
                    "student": student,
                    "license": license,
                    "license_id": license_id,
                    "current_skills": license.football_skills,
                    "specialization_display": specialization_display,
                    "specialization_color": specialization_color,
                    "error": f"Skill '{skill_name}' must be between 0 and 100"
                }
            )

    # Round to 1 decimal place
    skills_dict = {k: round(v, 1) for k, v in skills.items()}

    # Update license
    license.football_skills = skills_dict
    license.skills_last_updated_at = datetime.now(timezone.utc)
    license.skills_updated_by = user.id

    # Update instructor notes if provided
    if instructor_notes.strip():
        license.instructor_notes = instructor_notes.strip()

    db.commit()
    db.refresh(license)

    # Log audit
    from ..services.audit_service import AuditService
    from ..models.audit_log import AuditAction
    audit_service = AuditService(db)
    audit_service.log(
        action=AuditAction.UPDATE,
        user_id=user.id,
        resource_type="football_skills",
        resource_id=license_id,
        details={
            "student_id": student_id,
            "student_email": student.email,
            "specialization": license.specialization_type,
            "skills": skills_dict,
            "instructor_notes": instructor_notes
        }
    )

    print(f"‚úÖ Instructor {user.name} updated skills for {student.email} - {license.specialization_type}")

    # Get specialization display name
    spec_display_map = {
        "LFA_PLAYER_PRE": "LFA Player PRE (Ages 5-8)",
        "LFA_PLAYER_YOUTH": "LFA Player Youth (Ages 9-14)",
        "LFA_PLAYER_AMATEUR": "LFA Player Amateur (Ages 14+)",
        "LFA_PLAYER_PRO": "LFA Player PRO (Ages 16+)"
    }
    specialization_display = spec_display_map.get(license.specialization_type, license.specialization_type)
    specialization_color = "#f1c40f"

    return templates.TemplateResponse(
        "instructor/student_skills.html",
        {
            "request": request,
            "user": user,
            "student": student,
            "license": license,
            "license_id": license_id,
            "current_skills": license.football_skills,
            "specialization_display": specialization_display,
            "specialization_color": specialization_color,
            "success": True
        }
    )

# ============================================================================
# ‚öΩ DEPRECATED: LFA Player Skills V2 Routes
# ============================================================================
# These routes have been MOVED to app/api/routes/lfa_player_routes.py
# as part of the spec-based architecture refactoring.
#
# The new spec-based architecture separates routes by specialization:
# - LFA Player: app/api/routes/lfa_player_routes.py (skills-based)
# - Gancuju: app/api/routes/gancuju_routes.py (belt-based)
# - Internship: app/api/routes/internship_routes.py (XP-based)
# - LFA Coach: app/api/routes/lfa_coach_routes.py (certification-based)
#
# All routes are automatically included via router.include_router() at the
# end of this file.
# ============================================================================


@router.get("/admin/analytics", response_class=HTMLResponse)
async def admin_analytics_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Admin-only: Analytics and reports page"""
    from ..models.user import UserRole
    from ..models.session import Session as SessionModel
    from ..models.booking import Booking
    
    # Security check: ONLY admins can access
    if user.role != UserRole.ADMIN:
        raise HTTPException(status_code=403, detail="Admin access required")
    
    # Get platform statistics
    total_users = db.query(User).count()
    total_students = db.query(User).filter(User.role == UserRole.STUDENT).count()
    total_instructors = db.query(User).filter(User.role == UserRole.INSTRUCTOR).count()
    total_sessions = db.query(SessionModel).count()
    total_bookings = db.query(Booking).count()
    
    stats = {
        "total_users": total_users,
        "total_students": total_students,
        "total_instructors": total_instructors,
        "total_sessions": total_sessions,
        "total_bookings": total_bookings
    }
    
    return templates.TemplateResponse(
        "admin/analytics.html",
        {
            "request": request,
            "user": user,
            "stats": stats
        }
    )


# ============================================================================
# MOTIVATION ASSESSMENT ROUTES - Admin/Instructor evaluate student motivation
# ============================================================================

@router.get("/admin/students/{student_id}/motivation/{specialization}", response_class=HTMLResponse)
async def motivation_assessment_page(
    request: Request,
    student_id: int,
    specialization: str,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Admin/Instructor-only: Motivation assessment page for a student's specialization"""
    from ..models.user import UserRole
    from ..models.license import UserLicense

    # Security check: ONLY admins and instructors can access
    if user.role not in [UserRole.ADMIN, UserRole.INSTRUCTOR]:
        raise HTTPException(status_code=403, detail="Admin or Instructor access required")

    # Get student
    student = db.query(User).filter(User.id == student_id, User.role == UserRole.STUDENT).first()
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")

    # Get student's license for this specialization
    license = db.query(UserLicense).filter(
        UserLicense.user_id == student_id,
        UserLicense.specialization_type == specialization
    ).first()

    if not license:
        raise HTTPException(status_code=404, detail=f"Student does not have {specialization} license")

    # Format specialization name for display
    specialization_display = specialization.replace('_', ' ').title()

    # Check if there are existing scores
    existing_scores = license.motivation_scores is not None

    return templates.TemplateResponse(
        "admin/motivation_assessment.html",
        {
            "request": request,
            "user": user,
            "student": student,
            "license": license,
            "specialization": specialization,
            "specialization_display": specialization_display,
            "existing_scores": existing_scores
        }
    )


@router.post("/admin/students/{student_id}/motivation/{specialization}")
async def motivation_assessment_submit(
    request: Request,
    student_id: int,
    specialization: str,
    goal_clarity: int = Form(...),
    commitment_level: int = Form(...),
    engagement: int = Form(...),
    progress_mindset: int = Form(...),
    initiative: int = Form(...),
    notes: str = Form(""),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Admin/Instructor-only: Save motivation assessment"""
    from ..models.user import UserRole
    from ..models.license import UserLicense
    from datetime import datetime, timezone

    # Security check: ONLY admins and instructors can access
    if user.role not in [UserRole.ADMIN, UserRole.INSTRUCTOR]:
        raise HTTPException(status_code=403, detail="Admin or Instructor access required")

    # Validate scores (1-5)
    scores = [goal_clarity, commitment_level, engagement, progress_mindset, initiative]
    for score in scores:
        if score < 1 or score > 5:
            raise HTTPException(status_code=400, detail="Scores must be between 1 and 5")

    # Get student's license
    license = db.query(UserLicense).filter(
        UserLicense.user_id == student_id,
        UserLicense.specialization_type == specialization
    ).first()

    if not license:
        raise HTTPException(status_code=404, detail=f"Student does not have {specialization} license")

    # Create motivation scores JSON
    motivation_data = {
        "goal_clarity": goal_clarity,
        "commitment_level": commitment_level,
        "engagement": engagement,
        "progress_mindset": progress_mindset,
        "initiative": initiative,
        "notes": notes,
        "assessed_at": datetime.now(timezone.utc).isoformat(),
        "assessed_by_id": user.id,
        "assessed_by_name": user.name
    }

    # Calculate average
    average_score = sum(scores) / len(scores)

    # Update license
    license.motivation_scores = motivation_data
    license.average_motivation_score = average_score
    license.motivation_last_assessed_at = datetime.now(timezone.utc)
    license.motivation_assessed_by = user.id

    db.commit()

    print(f"‚úÖ {user.name} assessed {student_id}'s motivation for {specialization}: {average_score:.1f}/5.0")

    # Redirect back to student details or payments page
    return RedirectResponse(url=f"/admin/payments", status_code=303)


# ============================================================================
# üéì SEMESTER ENROLLMENT REQUEST WORKFLOW (Student-initiated, Admin-approved)
# ============================================================================

@router.get("/semesters/enroll", response_class=HTMLResponse)
async def semester_enrollment_page(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Display semester enrollment request page for students"""
    from ..models.user import UserRole
    from ..models.semester import Semester
    from ..models.semester_enrollment import SemesterEnrollment
    from ..models.license import UserLicense

    # Only students can access
    if user.role != UserRole.STUDENT:
        return RedirectResponse(url="/dashboard", status_code=303)

    # Must have completed onboarding and have active specialization
    if not user.onboarding_completed or not user.specialization:
        return RedirectResponse(url="/onboarding", status_code=303)

    # Get user's license for current specialization
    current_license = db.query(UserLicense).filter(
        UserLicense.user_id == user.id,
        UserLicense.specialization_type == user.specialization.value
    ).first()

    if not current_license:
        return RedirectResponse(url="/dashboard", status_code=303)

    # Get all user licenses for switcher
    user_licenses = db.query(UserLicense).filter(UserLicense.user_id == user.id).all()

    # Get available semesters (universal, not specialization-specific)
    available_semesters = db.query(Semester).filter(
        Semester.is_active == True
    ).order_by(Semester.start_date).all()

    # Get user's enrollment requests for current specialization
    enrollments = db.query(SemesterEnrollment).filter(
        SemesterEnrollment.user_id == user.id,
        SemesterEnrollment.user_license_id == current_license.id
    ).all()

    # Build enrollment status map
    enrollment_map = {e.semester_id: e for e in enrollments}

    # Get specialization color
    specialization_color = None
    if user.specialization.value == 'INTERNSHIP':
        specialization_color = '#e74c3c'
    elif user.specialization.value == 'GANCUJU_PLAYER':
        specialization_color = '#8e44ad'
    elif user.specialization.value == 'LFA_FOOTBALL_PLAYER':
        specialization_color = '#f1c40f'
    elif user.specialization.value == 'LFA_COACH':
        specialization_color = '#27ae60'

    return templates.TemplateResponse(
        "semester_enrollment_request.html",
        {
            "request": request,
            "user": user,
            "user_licenses": user_licenses,
            "specialization_color": specialization_color,
            "available_semesters": available_semesters,
            "enrollment_map": enrollment_map
        }
    )


@router.post("/semesters/request-enrollment")
async def request_semester_enrollment(
    request: Request,
    semester_id: int = Form(...),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Student requests enrollment in a semester"""
    from ..models.user import UserRole
    from ..models.semester import Semester
    from ..models.semester_enrollment import SemesterEnrollment, EnrollmentStatus
    from ..models.license import UserLicense

    # Only students can request enrollment
    if user.role != UserRole.STUDENT:
        return RedirectResponse(url="/dashboard", status_code=303)

    # Must have completed onboarding and have active specialization
    if not user.onboarding_completed or not user.specialization:
        return RedirectResponse(url="/onboarding", status_code=303)

    # Get user's license for current specialization
    current_license = db.query(UserLicense).filter(
        UserLicense.user_id == user.id,
        UserLicense.specialization_type == user.specialization.value
    ).first()

    if not current_license:
        print(f"‚ùå No license found for {user.email} - {user.specialization.value}")
        return RedirectResponse(url="/semesters/enroll", status_code=303)

    # Get semester
    semester = db.query(Semester).filter(Semester.id == semester_id).first()
    if not semester:
        print(f"‚ùå Semester {semester_id} not found")
        return RedirectResponse(url="/semesters/enroll", status_code=303)

    # Check if enrollment already exists
    existing_enrollment = db.query(SemesterEnrollment).filter(
        SemesterEnrollment.user_id == user.id,
        SemesterEnrollment.semester_id == semester_id,
        SemesterEnrollment.user_license_id == current_license.id
    ).first()

    if existing_enrollment:
        # If it was rejected or withdrawn, allow re-request
        if existing_enrollment.request_status in [EnrollmentStatus.REJECTED, EnrollmentStatus.WITHDRAWN]:
            existing_enrollment.request_status = EnrollmentStatus.PENDING
            existing_enrollment.requested_at = datetime.now(timezone.utc)
            existing_enrollment.approved_at = None
            existing_enrollment.approved_by = None
            existing_enrollment.rejection_reason = None
            existing_enrollment.is_active = False
            db.commit()
            print(f"‚úÖ Re-requested enrollment: {user.email} ‚Üí {semester.name}")
        else:
            print(f"‚ö†Ô∏è Enrollment already exists: {existing_enrollment.request_status.value}")
    else:
        # Create new enrollment request
        new_enrollment = SemesterEnrollment(
            user_id=user.id,
            user_license_id=current_license.id,
            semester_id=semester_id,
            request_status=EnrollmentStatus.PENDING,
            requested_at=datetime.now(timezone.utc),
            is_active=False,
            payment_verified=False
        )
        db.add(new_enrollment)
        db.commit()
        print(f"‚úÖ Created enrollment request: {user.email} ‚Üí {semester.name}")

    return RedirectResponse(url="/semesters/enroll", status_code=303)


@router.post("/semesters/withdraw-enrollment")
async def withdraw_semester_enrollment(
    request: Request,
    enrollment_id: int = Form(...),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Student withdraws their enrollment request"""
    from ..models.user import UserRole
    from ..models.semester_enrollment import SemesterEnrollment, EnrollmentStatus

    # Only students can withdraw
    if user.role != UserRole.STUDENT:
        return RedirectResponse(url="/dashboard", status_code=303)

    # Get enrollment
    enrollment = db.query(SemesterEnrollment).filter(
        SemesterEnrollment.id == enrollment_id,
        SemesterEnrollment.user_id == user.id  # Security: only own enrollments
    ).first()

    if not enrollment:
        print(f"‚ùå Enrollment {enrollment_id} not found or unauthorized")
        return RedirectResponse(url="/semesters/enroll", status_code=303)

    # Can only withdraw PENDING enrollments
    if enrollment.request_status != EnrollmentStatus.PENDING:
        print(f"‚ùå Cannot withdraw {enrollment.request_status.value} enrollment")
        return RedirectResponse(url="/semesters/enroll", status_code=303)

    # Withdraw the request
    enrollment.withdraw()
    db.commit()
    print(f"‚úÖ Withdrawn enrollment request: {user.email} ‚Üí enrollment {enrollment_id}")

    return RedirectResponse(url="/semesters/enroll", status_code=303)

# ==================== NEW ONBOARDING FLOW ====================

@router.get("/onboarding/start", response_class=HTMLResponse)
async def onboarding_start(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    New onboarding flow:
    1. Collect date of birth (if not set)
    2. Show age-filtered specializations
    3. Student selects spec(s)
    4. Auto-create UserLicense(s)
    5. Show payment info
    """
    from ..utils.age_requirements import get_available_specializations
    from datetime import date

    # Get today's date for max date validation
    today = date.today().isoformat()

    # Get available specializations based on age
    available_specs = []
    if user.age is not None:
        available_specs = get_available_specializations(user.age)

    return templates.TemplateResponse(
        "student/onboarding_new.html",
        {
            "request": request,
            "user": user,
            "today": today,
            "available_specs": available_specs
        }
    )


@router.post("/onboarding/set-birthdate")
async def onboarding_set_birthdate(
    request: Request,
    date_of_birth: str = Form(...),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """Set user's date of birth and continue onboarding"""
    from datetime import datetime

    try:
        # Parse date
        dob = datetime.strptime(date_of_birth, "%Y-%m-%d").date()

        # Validate age (must be at least 5 years old)
        today = datetime.now().date()
        age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))

        if age < 5:
            raise HTTPException(status_code=400, detail="You must be at least 5 years old to register")

        # Update user
        user.date_of_birth = dob
        db.commit()

        print(f"‚úÖ Set date of birth for {user.email}: {dob} (age: {age})")

        # Redirect back to onboarding to show spec selection
        return RedirectResponse(url="/onboarding/start", status_code=303)

    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid date format")


@router.post("/onboarding/select-specialization")
async def onboarding_select_specialization(
    request: Request,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user_web)
):
    """
    Handle specialization selection:
    1. Validate age requirements
    2. Create UserLicense(s) automatically
    3. Set user.specialization to first selected spec
    4. Redirect to dashboard with payment info
    """
    from ..models.license import UserLicense
    from ..models.user import SpecializationType
    from ..utils.age_requirements import validate_specialization_for_age

    # Get form data
    form_data = await request.form()
    specializations = form_data.getlist("specializations")

    # Debug: print all form data
    print(f"üîç Form data keys: {list(form_data.keys())}")
    print(f"üîç Specializations received: {specializations}")

    # Validate user has age set
    if user.age is None:
        raise HTTPException(status_code=400, detail="Date of birth must be set first")

    # Validate at least one spec selected
    if not specializations:
        print(f"‚ùå No specializations selected! Form data: {dict(form_data)}")
        raise HTTPException(status_code=400, detail="Please select at least one specialization")

    created_licenses = []

    for spec_str in specializations:
        # Validate age requirement
        if not validate_specialization_for_age(spec_str, user.age):
            print(f"‚ùå User {user.email} (age {user.age}) not eligible for {spec_str}")
            continue

        # Check if license already exists
        existing_license = db.query(UserLicense).filter(
            UserLicense.user_id == user.id,
            UserLicense.specialization_type == spec_str
        ).first()

        if existing_license:
            print(f"‚ö†Ô∏è License already exists: {user.email} ‚Üí {spec_str}")
            continue

        # Create new license
        try:
            from datetime import datetime
            import secrets

            spec_type = SpecializationType(spec_str)

            # Generate unique payment reference code
            # Format: SPEC-YYYY-USERID-RANDOM (e.g., INT-2025-002-X7K9)
            spec_short = {
                'INTERNSHIP': 'INT',
                'GANCUJU_PLAYER': 'GCJ',
                'LFA_FOOTBALL_PLAYER': 'FBL',
                'LFA_COACH': 'COA'
            }.get(spec_type.value, 'LIC')

            year = datetime.now().year
            random_code = secrets.token_hex(2).upper()  # 4-char random code
            payment_ref = f"{spec_short}-{year}-{user.id:03d}-{random_code}"

            new_license = UserLicense(
                user_id=user.id,
                specialization_type=spec_type.value,  # Store as string
                current_level=1,  # Start at level 1
                max_achieved_level=1,
                started_at=datetime.now(),
                payment_reference_code=payment_ref
            )
            db.add(new_license)
            created_licenses.append(spec_type)
            print(f"‚úÖ Created license: {user.email} ‚Üí {spec_str} (Payment ref: {payment_ref})")

        except ValueError:
            print(f"‚ùå Invalid specialization type: {spec_str}")
            continue

    # Set user's primary specialization to first selected
    # NOTE: onboarding_completed stays FALSE until admin approves enrollment!
    if created_licenses:
        user.specialization = created_licenses[0]
        db.commit()
        print(f"‚úÖ Specializations selected: {user.email} ‚Üí {[l.value for l in created_licenses]}")
        print(f"üìã Next step: User should see payment info and pay for selected specializations")

    # Redirect to dashboard where payment info will be shown
    return RedirectResponse(url="/dashboard", status_code=303)


# ============================================================================
# SPEC-BASED ROUTES - Include routers from spec-specific modules
# ============================================================================

# Include LFA Player routes (skills-based assessment)
router.include_router(
    lfa_player_routes.router,
    tags=["lfa_player", "skills"]
)

# Include Gancuju Player routes (belt progression)
router.include_router(
    gancuju_routes.router,
    tags=["gancuju", "belts"]
)

# Include Internship routes (XP and level progression)
router.include_router(
    internship_routes.router,
    tags=["internship", "xp", "levels"]
)

# Include LFA Coach routes (certification system)
router.include_router(
    lfa_coach_routes.router,
    tags=["lfa_coach", "certifications"]
)

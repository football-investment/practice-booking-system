#!/usr/bin/env python3
"""
API Test Generator
Generates smoke tests for all API endpoints discovered by endpoint_inventory.py

Usage:
    # Generate tests from inventory
    python tools/endpoint_inventory.py --format json > /tmp/endpoints.json
    python tools/generate_api_tests.py --input /tmp/endpoints.json --output tests/integration/api_smoke/

    # Or run end-to-end
    python tools/generate_api_tests.py --scan-api app/api --output tests/integration/api_smoke/
"""

import argparse
import json
from pathlib import Path
from typing import List, Dict
from dataclasses import dataclass
from jinja2 import Template


@dataclass
class Endpoint:
    """API endpoint metadata"""
    path: str
    method: str
    function_name: str
    file_path: str
    domain: str
    has_test: bool = False
    test_file: str = ""


# â”€â”€ Test Templates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CONFTEST_TEMPLATE = '''"""
Auto-generated API smoke tests configuration
Generated by tools/generate_api_tests.py
"""

import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session

from app.main import app
from app.database import get_db
from app.models.user import User, UserRole
from app.core.security import get_password_hash


@pytest.fixture(scope="module")
def api_client():
    """FastAPI test client"""
    return TestClient(app)


@pytest.fixture(scope="module")
def test_db():
    """Database session for test setup"""
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()


@pytest.fixture(scope="module")
def admin_token(test_db: Session):
    """Admin user authentication token"""
    # Check if admin exists
    admin = test_db.query(User).filter(User.email == "smoke.admin@generated.test").first()

    if not admin:
        admin = User(
            name="Smoke Test Admin",
            email="smoke.admin@generated.test",
            password_hash=get_password_hash("admin123"),
            role=UserRole.ADMIN,
            is_active=True
        )
        test_db.add(admin)
        test_db.commit()
        test_db.refresh(admin)

    # Generate token
    from app.api.deps import create_access_token
    token = create_access_token(subject=admin.id)
    return token


@pytest.fixture(scope="module")
def student_token(test_db: Session):
    """Student user authentication token"""
    student = test_db.query(User).filter(User.email == "smoke.student@generated.test").first()

    if not student:
        student = User(
            name="Smoke Test Student",
            email="smoke.student@generated.test",
            password_hash=get_password_hash("student123"),
            role=UserRole.STUDENT,
            is_active=True
        )
        test_db.add(student)
        test_db.commit()
        test_db.refresh(student)

    from app.api.deps import create_access_token
    token = create_access_token(subject=student.id)
    return token


@pytest.fixture(scope="module")
def instructor_token(test_db: Session):
    """Instructor user authentication token"""
    instructor = test_db.query(User).filter(User.email == "smoke.instructor@generated.test").first()

    if not instructor:
        instructor = User(
            name="Smoke Test Instructor",
            email="smoke.instructor@generated.test",
            password_hash=get_password_hash("instructor123"),
            role=UserRole.INSTRUCTOR,
            is_active=True
        )
        test_db.add(instructor)
        test_db.commit()
        test_db.refresh(instructor)

    from app.api.deps import create_access_token
    token = create_access_token(subject=instructor.id)
    return token
'''


SMOKE_TEST_TEMPLATE = Template('''"""
Auto-generated smoke tests for {{ domain }} domain
Generated by tools/generate_api_tests.py

âš ï¸  DO NOT EDIT MANUALLY - Regenerate using:
    python tools/generate_api_tests.py --scan-api app/api --output tests/integration/api_smoke/
"""

import pytest
from fastapi.testclient import TestClient


class Test{{ domain|title|replace('_', '') }}Smoke:
    """Smoke tests for {{ domain }} API endpoints"""

{% for endpoint in endpoints %}
    # â”€â”€ {{ endpoint.method }} {{ endpoint.path }} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def test_{{ endpoint.function_name }}_happy_path(self, api_client: TestClient, admin_token: str):
        """
        Happy path: {{ endpoint.method }} {{ endpoint.path }}
        Source: {{ endpoint.file_path }}:{{ endpoint.function_name }}
        """
        headers = {"Authorization": f"Bearer {admin_token}"}

        {% if endpoint.method == "GET" %}
        response = api_client.get("{{ endpoint.path }}", headers=headers)
        {% elif endpoint.method == "POST" %}
        # TODO: Add realistic payload for {{ endpoint.path }}
        payload = {}
        response = api_client.post("{{ endpoint.path }}", json=payload, headers=headers)
        {% elif endpoint.method == "PUT" %}
        payload = {}
        response = api_client.put("{{ endpoint.path }}", json=payload, headers=headers)
        {% elif endpoint.method == "PATCH" %}
        payload = {}
        response = api_client.patch("{{ endpoint.path }}", json=payload, headers=headers)
        {% elif endpoint.method == "DELETE" %}
        response = api_client.delete("{{ endpoint.path }}", headers=headers)
        {% endif %}

        # Accept 200, 201, 404 (if resource doesn't exist in test DB)
        assert response.status_code in [200, 201, 404], (
            f"{{ endpoint.method }} {{ endpoint.path }} failed: {response.status_code} "
            f"{response.text}"
        )

    def test_{{ endpoint.function_name }}_auth_required(self, api_client: TestClient):
        """
        Auth validation: {{ endpoint.method }} {{ endpoint.path }} requires authentication
        """
        {% if endpoint.method == "GET" %}
        response = api_client.get("{{ endpoint.path }}")
        {% elif endpoint.method == "POST" %}
        response = api_client.post("{{ endpoint.path }}", json={})
        {% elif endpoint.method == "PUT" %}
        response = api_client.put("{{ endpoint.path }}", json={})
        {% elif endpoint.method == "PATCH" %}
        response = api_client.patch("{{ endpoint.path }}", json={})
        {% elif endpoint.method == "DELETE" %}
        response = api_client.delete("{{ endpoint.path }}")
        {% endif %}

        # Should return 401 Unauthorized or 403 Forbidden
        assert response.status_code in [401, 403], (
            f"{{ endpoint.method }} {{ endpoint.path }} should require auth: {response.status_code}"
        )

    @pytest.mark.skip(reason="Input validation requires domain-specific payloads")
    def test_{{ endpoint.function_name }}_input_validation(self, api_client: TestClient, admin_token: str):
        """
        Input validation: {{ endpoint.method }} {{ endpoint.path }} validates request data
        """
        headers = {"Authorization": f"Bearer {admin_token}"}

        {% if endpoint.method in ["POST", "PUT", "PATCH"] %}
        # Invalid payload (empty or malformed)
        invalid_payload = {"invalid_field": "invalid_value"}
        response = api_client.{{ endpoint.method.lower() }}(
            "{{ endpoint.path }}",
            json=invalid_payload,
            headers=headers
        )

        # Should return 422 Unprocessable Entity for validation errors
        assert response.status_code in [400, 422], (
            f"{{ endpoint.method }} {{ endpoint.path }} should validate input: {response.status_code}"
        )
        {% else %}
        # GET/DELETE don't typically have input validation
        pytest.skip("No input validation for {{ endpoint.method }} endpoints")
        {% endif %}

{% endfor %}
''')


class TestGenerator:
    """Generates pytest test files from endpoint inventory"""

    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_tests(self, endpoints: List[Endpoint]):
        """Generate test files grouped by domain"""
        # Group endpoints by domain
        by_domain: Dict[str, List[Endpoint]] = {}
        for endpoint in endpoints:
            if endpoint.domain not in by_domain:
                by_domain[endpoint.domain] = []
            by_domain[endpoint.domain].append(endpoint)

        # Generate conftest.py
        self._write_conftest()

        # Generate test file per domain
        for domain, domain_endpoints in by_domain.items():
            self._generate_domain_tests(domain, domain_endpoints)

        # Generate summary report
        self._generate_summary(by_domain)

    def _write_conftest(self):
        """Write conftest.py with fixtures"""
        conftest_path = self.output_dir / "conftest.py"
        conftest_path.write_text(CONFTEST_TEMPLATE)
        print(f"âœ… Generated: {conftest_path}")

    def _generate_domain_tests(self, domain: str, endpoints: List[Endpoint]):
        """Generate test file for a single domain"""
        # Sort endpoints by method and path
        endpoints_sorted = sorted(endpoints, key=lambda e: (e.method, e.path))

        # Render template
        test_content = SMOKE_TEST_TEMPLATE.render(
            domain=domain,
            endpoints=endpoints_sorted
        )

        # Write to file
        test_file = self.output_dir / f"test_{domain}_smoke.py"
        test_file.write_text(test_content)
        print(f"âœ… Generated: {test_file} ({len(endpoints)} endpoints)")

    def _generate_summary(self, by_domain: Dict[str, List[Endpoint]]):
        """Generate summary report"""
        total_endpoints = sum(len(eps) for eps in by_domain.values())
        total_tests = total_endpoints * 3  # 3 tests per endpoint

        summary = [
            "# API Smoke Test Generation Summary",
            "",
            f"**Total Endpoints:** {total_endpoints}",
            f"**Total Tests Generated:** {total_tests}",
            f"**Domains:** {len(by_domain)}",
            "",
            "## Tests per Domain",
            "",
            "| Domain | Endpoints | Tests Generated |",
            "|--------|-----------|-----------------|",
        ]

        for domain in sorted(by_domain.keys()):
            eps = by_domain[domain]
            tests = len(eps) * 3
            summary.append(f"| {domain} | {len(eps)} | {tests} |")

        summary.extend([
            "",
            "## Test Types",
            "",
            "Each endpoint has 3 tests:",
            "1. **Happy Path** - Validates 200/201 response with admin auth",
            "2. **Auth Required** - Validates 401/403 without authentication",
            "3. **Input Validation** - Validates 422 with invalid payload (SKIPPED - needs manual implementation)",
            "",
            "## Running Tests",
            "",
            "```bash",
            "# Run all smoke tests",
            f"pytest {self.output_dir} -v",
            "",
            "# Run specific domain",
            f"pytest {self.output_dir}/test_tournaments_smoke.py -v",
            "",
            "# Parallel execution",
            f"pytest {self.output_dir} -n auto -v",
            "```",
            "",
            "## Next Steps",
            "",
            "1. Review generated tests",
            "2. Add realistic payloads for POST/PUT/PATCH endpoints",
            "3. Implement input validation tests (currently skipped)",
            "4. Add to CI pipeline as BLOCKING gate",
        ])

        summary_path = self.output_dir / "SMOKE_TEST_SUMMARY.md"
        summary_path.write_text("\n".join(summary))
        print(f"âœ… Generated: {summary_path}")


def load_endpoints_from_json(json_path: Path) -> List[Endpoint]:
    """Load endpoints from JSON inventory file"""
    data = json.loads(json_path.read_text())
    return [Endpoint(**ep) for ep in data]


def scan_and_generate(api_dir: Path, output_dir: Path):
    """Scan API directory and generate tests (convenience wrapper)"""
    from endpoint_inventory import EndpointScanner

    print(f"ğŸ” Scanning API directory: {api_dir}")
    scanner = EndpointScanner(api_dir)
    endpoints = scanner.scan()

    print(f"âœ… Found {len(endpoints)} endpoints")
    print(f"ğŸ“ Generating tests to: {output_dir}")

    generator = TestGenerator(output_dir)
    generator.generate_tests(endpoints)

    print(f"\nâœ… Test generation complete!")
    print(f"   Generated {len(endpoints) * 3} tests across {len(set(e.domain for e in endpoints))} domains")


def main():
    parser = argparse.ArgumentParser(description="API Smoke Test Generator")
    parser.add_argument(
        "--input",
        type=Path,
        help="Input JSON file from endpoint_inventory.py"
    )
    parser.add_argument(
        "--scan-api",
        type=Path,
        help="API directory to scan (alternative to --input)"
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("tests/integration/api_smoke"),
        help="Output directory for generated tests"
    )

    args = parser.parse_args()

    if args.scan_api:
        # Scan API directory directly
        scan_and_generate(args.scan_api, args.output)
    elif args.input:
        # Load from JSON inventory
        endpoints = load_endpoints_from_json(args.input)
        generator = TestGenerator(args.output)
        generator.generate_tests(endpoints)
    else:
        parser.error("Must specify either --input or --scan-api")


if __name__ == "__main__":
    main()

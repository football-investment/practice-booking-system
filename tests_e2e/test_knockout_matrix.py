"""
Knockout Tournament Matrix — Playwright + API Lifecycle Tests
=============================================================

Validates the full group→knockout lifecycle for every standard OPS
tournament size.  Tests the fix in AdvancementCalculator.apply_crossover_seeding
that previously only seeded 2 sessions regardless of bracket depth.

Matrix:
    8p   2 groups × 4 players → 2 SF sessions  (round 1)
    16p  4 groups × 4 players → 4 QF sessions  (round 1)  ← was broken
    32p  8 groups × 4 players → 8 R16 sessions (round 1)

Each parametrized test:
    Phase A  Create OPS group_knockout tournament via API
    Phase B  Submit all group-stage results via API
    Phase C  Call finalize-group-stage → apply_crossover_seeding runs
    Phase D  Assert every round-1 knockout session has exactly 2 participants
    Phase E  (Playwright) navigate to Tournament Monitor and verify all
             knockout result-entry forms are rendered (not hidden/empty)

Run (headless CI):
    pytest tests_e2e/test_knockout_matrix.py -v --tb=short

Run (headed debug):
    PYTEST_HEADLESS=false PYTEST_SLOW_MO=800 \\
        pytest tests_e2e/test_knockout_matrix.py -v -s -k test_matrix_16p

Requirements:
    - Backend running at $API_URL   (default http://localhost:8000)
    - Streamlit running at $BASE_URL (default http://localhost:8501)
    - Admin account:  admin@lfa.com / admin123
    - ≥ 32 seed users with lfa_seed = True  (generated by OPS seeder)
"""

from __future__ import annotations

import json
import os
import random
import time
import urllib.parse
from typing import Any, Dict, List, Optional, Tuple

import pytest
import requests
from playwright.sync_api import Page, expect

# ── Constants ──────────────────────────────────────────────────────────────────

_API_URL  = os.environ.get("API_URL",  "http://localhost:8000")
_BASE_URL = os.environ.get("BASE_URL", "http://localhost:8501")
_ADMIN_EMAIL    = "admin@lfa.com"
_ADMIN_PASSWORD = "admin123"

_LOAD_TIMEOUT   = 30_000   # ms
_SETTLE_SECS    = 3        # seconds after Streamlit rerun


# ── Auth helpers ───────────────────────────────────────────────────────────────

def _login() -> Tuple[str, Dict[str, Any]]:
    """Return (token, user_dict) for the admin account."""
    resp = requests.post(
        f"{_API_URL}/api/v1/auth/login",
        json={"email": _ADMIN_EMAIL, "password": _ADMIN_PASSWORD},
        timeout=10,
    )
    assert resp.status_code == 200, f"Admin login failed: {resp.status_code} {resp.text}"
    token = resp.json()["access_token"]

    me = requests.get(
        f"{_API_URL}/api/v1/users/me",
        headers={"Authorization": f"Bearer {token}"},
        timeout=10,
    )
    assert me.status_code == 200
    return token, me.json()


def _headers(token: str) -> Dict[str, str]:
    return {"Authorization": f"Bearer {token}"}


# ── OPS lifecycle helpers ──────────────────────────────────────────────────────

def _run_ops_scenario(
    token: str,
    player_count: int,
    simulation_mode: str = "manual",
) -> int:
    """
    Trigger OPS group_knockout scenario and return the created tournament_id.

    simulation_mode="manual" → sessions created, no results simulated yet.
    """
    name = f"KO-MATRIX-{player_count}p-{int(time.time())}"
    payload = {
        "scenario": "large_field_monitor",
        "player_count": player_count,
        "tournament_type_code": "group_knockout",
        "tournament_format": "HEAD_TO_HEAD",
        "simulation_mode": simulation_mode,
        "tournament_name": name,
        "dry_run": False,
        "confirmed": player_count >= 128,
    }
    resp = requests.post(
        f"{_API_URL}/api/v1/tournaments/ops/run-scenario",
        json=payload,
        headers=_headers(token),
        timeout=120,
    )
    assert resp.status_code == 200, (
        f"ops/run-scenario failed ({player_count}p): {resp.status_code} {resp.text}"
    )
    data = resp.json()
    tid = data.get("tournament_id")
    assert tid, f"No tournament_id in response: {data}"
    return tid


def _get_sessions(token: str, tid: int) -> List[Dict[str, Any]]:
    """Return all sessions for the tournament (admin/instructor endpoint)."""
    resp = requests.get(
        f"{_API_URL}/api/v1/tournaments/{tid}/sessions",
        headers=_headers(token),
        timeout=30,
    )
    assert resp.status_code == 200, f"GET sessions failed: {resp.status_code} {resp.text}"
    return resp.json()


def _submit_group_result(
    token: str,
    tid: int,
    session: Dict[str, Any],
) -> None:
    """Submit a deterministic win/loss result for a group-stage session."""
    participants = session.get("participant_user_ids") or []
    assert len(participants) == 2, (
        f"Group session {session['id']} has {len(participants)} participants, expected 2"
    )
    # Deterministic: lower user_id always wins
    winner_id, loser_id = sorted(participants)
    payload = {
        "results": [
            {"user_id": winner_id, "result": "WIN"},
            {"user_id": loser_id,  "result": "LOSS"},
        ],
        "notes": "matrix-test auto-result",
    }
    resp = requests.post(
        f"{_API_URL}/api/v1/tournaments/{tid}/sessions/{session['id']}/submit-results",
        json=payload,
        headers=_headers(token),
        timeout=30,
    )
    # Accept 200 or 201
    assert resp.status_code in (200, 201), (
        f"submit-results failed for session {session['id']}: "
        f"{resp.status_code} {resp.text}"
    )


def _finalize_group_stage(token: str, tid: int) -> Dict[str, Any]:
    """Call finalize-group-stage and return the response JSON."""
    resp = requests.post(
        f"{_API_URL}/api/v1/tournaments/{tid}/finalize-group-stage",
        headers=_headers(token),
        timeout=30,
    )
    assert resp.status_code == 200, (
        f"finalize-group-stage failed: {resp.status_code} {resp.text}"
    )
    return resp.json()


# ── Playwright navigation helper ───────────────────────────────────────────────

def _go_to_monitor(page: Page, token: str, user: Dict[str, Any], tid: int) -> None:
    """Navigate to Tournament Monitor with auth injected via URL params."""
    params = urllib.parse.urlencode({"token": token, "user": json.dumps(user)})
    url = f"{_BASE_URL}/Tournament_Monitor?{params}"
    page.goto(url, timeout=_LOAD_TIMEOUT)
    page.wait_for_load_state("networkidle", timeout=_LOAD_TIMEOUT)
    time.sleep(_SETTLE_SECS)


# ── Parametrized test cases ────────────────────────────────────────────────────

_MATRIX = [
    pytest.param(8,  2, 2, id="test_matrix_8p"),
    pytest.param(16, 4, 4, id="test_matrix_16p"),
    pytest.param(32, 8, 8, id="test_matrix_32p"),
]
"""(player_count, num_groups, expected_round1_sessions)"""


@pytest.mark.e2e
@pytest.mark.tournament_monitor
@pytest.mark.parametrize("player_count,num_groups,expected_r1", _MATRIX)
def test_knockout_seeding_matrix(
    page: Page,
    player_count: int,
    num_groups: int,
    expected_r1: int,
):
    """
    Full lifecycle test: OPS create → group results → finalize → seeding check → UI check.

    Verifies that after apply_crossover_seeding ALL round-1 knockout sessions
    have exactly 2 participant_user_ids (was the 16p+ bug).
    """
    print(f"\n{'='*70}")
    print(f"MATRIX TEST  player_count={player_count}  "
          f"groups={num_groups}  expected_r1={expected_r1}")
    print(f"{'='*70}")

    # ── Phase A: authenticate + create tournament ──────────────────────────────
    token, user = _login()
    print(f"[A] Logged in as {user.get('email')}")

    tid = _run_ops_scenario(token, player_count, simulation_mode="manual")
    print(f"[A] Tournament created: id={tid}")

    # ── Phase B: load sessions and submit all group-stage results ──────────────
    all_sessions = _get_sessions(token, tid)

    # Group sessions = already seeded (pids set by session generator)
    # Knockout sessions = pids=None (waiting for finalize-group-stage)
    group_sessions = [
        s for s in all_sessions
        if s.get("participant_user_ids") and len(s.get("participant_user_ids")) == 2
        and "Group" in (s.get("title") or "")
    ]
    # Fallback: any pre-seeded session with "Group" in title
    if not group_sessions:
        group_sessions = [
            s for s in all_sessions
            if s.get("participant_user_ids") and len(s.get("participant_user_ids")) == 2
        ]

    # Track which sessions start as unseeded (these are the knockout sessions)
    initially_unseeded = [
        s for s in all_sessions
        if not s.get("participant_user_ids") or len(s.get("participant_user_ids")) < 2
    ]

    assert group_sessions, (
        f"No group-stage sessions found for {player_count}p tournament {tid}. "
        f"All session titles: {[s.get('title') for s in all_sessions]}"
    )
    print(f"[B] Submitting {len(group_sessions)} group-stage results …")

    for sess in group_sessions:
        _submit_group_result(token, tid, sess)

    print(f"[B] All group results submitted")

    # ── Phase C: finalize group stage (triggers apply_crossover_seeding) ───────
    result = _finalize_group_stage(token, tid)
    assert result.get("success"), (
        f"finalize-group-stage returned success=False: {result}"
    )
    print(f"[C] Group stage finalized: {result.get('message')}")

    # ── Phase D: verify ALL round-1 knockout sessions are seeded ──────────────
    refreshed = _get_sessions(token, tid)

    # Round-1 knockout sessions: those that were unseeded and have no "Group" in title
    round1_sessions = [
        s for s in refreshed
        if not s.get("game_results")
        and "Group" not in (s.get("title") or "")
        and "3rd Place" not in (s.get("title") or "")
        and "Round of 2" not in (s.get("title") or "")
        and "Final" not in (s.get("title") or "")
        and "Round of 2" not in (s.get("title") or "")
    ]
    # More precise: sessions that were in initially_unseeded AND are now the deepest KO round
    # Use: sessions with title containing the deepest "Round of N" phrase
    expected_round_name = {8: "Round of 4", 16: "Round of 8", 32: "Round of 16"}
    r1_title_keyword = expected_round_name[player_count]
    round1_sessions = [
        s for s in refreshed
        if r1_title_keyword in (s.get("title") or "")
    ]

    assert len(round1_sessions) == expected_r1, (
        f"{player_count}p: expected {expected_r1} '{r1_title_keyword}' sessions, "
        f"found {len(round1_sessions)}"
    )

    unseeded = [
        s for s in round1_sessions
        if not s.get("participant_user_ids")
        or len(s.get("participant_user_ids", [])) != 2
    ]
    assert not unseeded, (
        f"{player_count}p: {len(unseeded)}/{expected_r1} round-1 sessions "
        f"are NOT seeded after finalize-group-stage:\n"
        + "\n".join(
            f"  session {s['id']} ({s.get('title')}) "
            f"participant_user_ids={s.get('participant_user_ids')}"
            for s in unseeded
        )
    )
    print(f"[D] All {expected_r1} round-1 sessions seeded correctly")

    # ── Phase E: Playwright — verify knockout forms render in the UI ───────────
    _go_to_monitor(page, token, user, tid)

    # The tournament card should be visible
    body_text = page.text_content("body") or ""
    assert str(tid) in body_text or "Tournament Monitor" in body_text, (
        "Tournament Monitor page did not load correctly"
    )
    print(f"[E] Monitor page loaded")

    # Expand / find the tournament card for this tournament
    # The card title contains the tournament name (OPS-MATRIX-*) or the ID
    card_locators = page.locator("[data-testid='stExpander']").all()
    target_expander = None
    for loc in card_locators:
        if str(tid) in (loc.text_content() or "") or f"{player_count}p" in (loc.text_content() or ""):
            target_expander = loc
            break

    if target_expander:
        target_expander.click()
        page.wait_for_load_state("networkidle", timeout=_LOAD_TIMEOUT)
        time.sleep(_SETTLE_SECS)
        print(f"[E] Tournament card expanded")

    # Verify no Streamlit error/traceback on the page
    page_text = page.text_content("body") or ""
    assert "Traceback" not in page_text, "Streamlit traceback found on page"
    assert "AttributeError" not in page_text, "AttributeError on page"
    assert "NoneType" not in page_text or "NoneType" in "expected NoneType", (
        "Unexpected NoneType error on page"
    )

    # Check that result-entry forms are present for knockout sessions
    # The forms contain the participant names (which are now set after the fix)
    # We verify the page does NOT show 'No participants assigned' for r1 sessions
    assert "No participants assigned" not in page_text, (
        f"{player_count}p: 'No participants assigned' message found — "
        "knockout sessions are not seeded in the UI"
    )

    print(f"[E] UI verification passed — no unseeded knockout session warnings")
    print(f"[{'='*30}] {player_count}p PASSED {'='*30}")


# ── Smoke: unit-level API check (no browser) ──────────────────────────────────

@pytest.mark.smoke
@pytest.mark.parametrize("player_count,num_groups,expected_r1", [
    (8,  2, 2),
    (16, 4, 4),
    (32, 8, 8),
])
def test_seeding_api_only(player_count: int, num_groups: int, expected_r1: int):
    """
    API-only smoke test (no browser): creates tournament, submits results,
    finalizes group stage, then verifies all round-1 sessions are seeded.

    Runs without Playwright — suitable as a fast CI pre-check.
    """
    token, _ = _login()
    tid = _run_ops_scenario(token, player_count, simulation_mode="manual")

    all_sessions = _get_sessions(token, tid)

    # Group sessions have pre-set participant_user_ids and "Group" in their title
    group_sessions = [
        s for s in all_sessions
        if s.get("participant_user_ids")
        and len(s.get("participant_user_ids")) == 2
        and "Group" in (s.get("title") or "")
    ]
    if not group_sessions:
        # Fallback: any pre-seeded session
        group_sessions = [
            s for s in all_sessions
            if s.get("participant_user_ids") and len(s.get("participant_user_ids")) == 2
        ]
    assert group_sessions, f"No group sessions for {player_count}p tournament {tid}"

    for sess in group_sessions:
        _submit_group_result(token, tid, sess)

    result = _finalize_group_stage(token, tid)
    assert result.get("success"), f"finalize-group-stage failed: {result}"

    refreshed = _get_sessions(token, tid)

    # Identify first-round knockout sessions by the deepest "Round of N" title
    r1_keyword = {8: "Round of 4", 16: "Round of 8", 32: "Round of 16"}[player_count]
    round1 = [s for s in refreshed if r1_keyword in (s.get("title") or "")]

    assert len(round1) == expected_r1, (
        f"{player_count}p: expected {expected_r1} '{r1_keyword}' sessions, got {len(round1)}"
    )
    unseeded = [s for s in round1 if len(s.get("participant_user_ids") or []) != 2]
    assert not unseeded, (
        f"{player_count}p: {len(unseeded)} unseeded round-1 sessions after fix:\n"
        + "\n".join(
            f"  {s['id']} {s.get('title')} → {s.get('participant_user_ids')}"
            for s in unseeded
        )
    )

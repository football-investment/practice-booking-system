# ü§ñ PRACTICE BOOKING SYSTEM - OPTIMALIZ√ÅLT CLAUDE AI EXTRACT
# =========================================================
# Gener√°lva: Sun Sep 21 08:08:59 CEST 2025
# Projekt: Practice Booking System (React + Python/FastAPI)
# Optimaliz√°l√°s: M√©ret-optimaliz√°lt <2MB

## üìã PROJEKT √ñSSZEFOGLAL√ì
Practice Booking System - Edz√©sfoglal√°si rendszer React frontend + Python/FastAPI backend

## üéØ OPTIMALIZ√ÅL√ÅSI STRAT√âGIA
- ‚úÖ Csak l√©nyegi forr√°sk√≥d f√°jlok
- ‚úÖ Kommentek √©s docstring-ek elt√°vol√≠t√°sa
- ‚úÖ JSON minifik√°l√°s
- ‚úÖ M√©retkorl√°t: 50KB/f√°jl, 2MB √∂sszesen
- ‚ùå SQL dump-ok, node_modules, build f√°jlok kiz√°rva
- ‚ùå Test f√°jlok √©s nagy dokument√°ci√≥k kiz√°rva

## üìÅ TARTALOM


================================================================================
FILE: app/main.py [CRITICAL-BACKEND]
================================================================================

from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
from sqlalchemy.exc import SQLAlchemyError
from pydantic import ValidationError

from .config import settings
from .api.api_v1.api import api_router
from .core.init_admin import create_initial_admin
from .core.health import HealthChecker
from .middleware.logging import LoggingMiddleware
from .middleware.security import (
    RateLimitMiddleware, 
    SecurityHeadersMiddleware, 
    RequestSizeLimitMiddleware
)
from .core.exceptions import (
    http_exception_handler,
    starlette_http_exception_handler,
    validation_exception_handler,
    database_exception_handler,
    pydantic_validation_exception_handler,
    general_exception_handler,
    business_logic_exception_handler,
    BusinessLogicError
)
@asynccontextmanager
async def lifespan(app: FastAPI):
    create_initial_admin()
    yield
app = FastAPI(
    title=settings.APP_NAME,
    description="Practice Booking System API",
    version="1.0.0",
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    lifespan=lifespan
)

if settings.ENABLE_SECURITY_HEADERS:
    app.add_middleware(SecurityHeadersMiddleware)

if settings.ENABLE_REQUEST_SIZE_LIMIT:
    app.add_middleware(RequestSizeLimitMiddleware, max_size_mb=10)

if settings.ENABLE_RATE_LIMITING:
    app.add_middleware(
        RateLimitMiddleware, 
        calls=settings.RATE_LIMIT_CALLS, 
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS
    )

if settings.ENABLE_STRUCTURED_LOGGING:
    app.add_middleware(LoggingMiddleware)  # Should be after rate limiting for accurate logs

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with specific origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.add_exception_handler(HTTPException, http_exception_handler)
app.add_exception_handler(StarletteHTTPException, starlette_http_exception_handler)
app.add_exception_handler(RequestValidationError, validation_exception_handler)
app.add_exception_handler(SQLAlchemyError, database_exception_handler)
app.add_exception_handler(ValidationError, pydantic_validation_exception_handler)
app.add_exception_handler(BusinessLogicError, business_logic_exception_handler)
app.add_exception_handler(Exception, general_exception_handler)

app.include_router(api_router, prefix=settings.API_V1_STR)
@app.get("/")
async def root():
    return {
        "message": "Practice Booking System API",
        "version": "1.0.0",
        "docs": f"{settings.API_V1_STR}/docs"
    }
@app.get("/health")
async def health_check():
    return {"status": "healthy"}
@app.get("/health/detailed")
async def detailed_health_check():
    return await HealthChecker.get_comprehensive_health()
@app.get("/health/ready")
async def readiness_check():
    db_health = await HealthChecker.get_database_health()
    return {
        "status": "ready" if db_health["status"] != "unhealthy" else "not_ready",
        "database": db_health["status"]
    }
@app.get("/health/live")
async def liveness_check():
    return {"status": "alive"}
================================================================================
FILE: app/database.py [CRITICAL-BACKEND]
================================================================================

from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker
from .config import settings

engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
def create_database():
    from .models import (
        user, semester, group, session, booking, 
        attendance, feedback, notification
    )
    Base.metadata.create_all(bind=engine)
================================================================================
FILE: app/models/user.py [CRITICAL-BACKEND]
================================================================================

from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Enum
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
import enum
from typing import Optional

from ..database import Base
from .specialization import SpecializationType
class UserRole(enum.Enum):
    ADMIN = "admin"
    INSTRUCTOR = "instructor"
    STUDENT = "student"
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    nickname = Column(String, nullable=True)
    email = Column(String, unique=True, nullable=False, index=True)
    password_hash = Column(String, nullable=False)
    role = Column(Enum(UserRole), nullable=False, default=UserRole.STUDENT)
    is_active = Column(Boolean, default=True)
    onboarding_completed = Column(Boolean, default=False)
    phone = Column(String, nullable=True)
    emergency_contact = Column(String, nullable=True)
    emergency_phone = Column(String, nullable=True)
    date_of_birth = Column(DateTime, nullable=True)
    medical_notes = Column(String, nullable=True)
    interests = Column(String, nullable=True)  # JSON string of interests array
    
    specialization = Column(
        Enum(SpecializationType), 
        nullable=True,
        comment="User's chosen specialization track (Player/Coach)"
    )
    
    payment_verified = Column(
        Boolean, 
        nullable=False, 
        default=False,
        comment="Whether student has paid semester fees"
    )
    payment_verified_at = Column(
        DateTime, 
        nullable=True,
        comment="Timestamp when payment was verified"
    )
    payment_verified_by = Column(
        Integer, 
        ForeignKey("users.id"), 
        nullable=True,
        comment="Admin who verified the payment"
    )
    
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    created_by = Column(Integer, ForeignKey("users.id"), nullable=True)

    creator = relationship("User", remote_side=[id], foreign_keys=[created_by], post_update=True)
    created_users = relationship("User", foreign_keys=[created_by], remote_side=[created_by], overlaps="creator", post_update=True)
    
    payment_verifier = relationship("User", remote_side=[id], foreign_keys=[payment_verified_by], post_update=True)
    groups = relationship("Group", secondary="group_users", back_populates="users")
    bookings = relationship("Booking", back_populates="user")
    attendances = relationship("Attendance", foreign_keys="Attendance.user_id", back_populates="user")
    feedbacks = relationship("Feedback", back_populates="user")
    notifications = relationship("Notification", back_populates="user")
    taught_sessions = relationship("Session", back_populates="instructor")
    marked_attendances = relationship("Attendance", foreign_keys="Attendance.marked_by", back_populates="marker")
    
    instructed_projects = relationship("Project", back_populates="instructor")
    project_enrollments = relationship("ProjectEnrollment", back_populates="user")
    sent_messages = relationship("Message", back_populates="sender", foreign_keys="Message.sender_id")
    received_messages = relationship("Message", back_populates="recipient", foreign_keys="Message.recipient_id")
    
    @property
    def specialization_display(self) -> str:
        return SpecializationType.get_display_name(self.specialization)
    
    @property
    def specialization_icon(self) -> str:
        return SpecializationType.get_icon(self.specialization)
    
    @property
    def has_specialization(self) -> bool:
        return self.specialization is not None
    
    def can_access_session(self, session) -> bool:
        """
        Check if user can access session based on specialization
        ‚ö†Ô∏è CRITICAL: This preserves Mbapp√© cross-semester logic
        """
        if self.email == "mbappe@lfa.com":
            return True  # Mbapp√© can access ALL sessions
        
        if not self.specialization:
            return True
            
        if not hasattr(session, 'target_specialization') or not session.target_specialization:
            return True
            
        if hasattr(session, 'mixed_specialization') and session.mixed_specialization:
            return True
            
        return session.target_specialization == self.specialization
    
    def can_enroll_in_project(self, project) -> bool:
        if not self.specialization:
            return True
            
        if not hasattr(project, 'target_specialization') or not project.target_specialization:
            return True
            
        if hasattr(project, 'mixed_specialization') and project.mixed_specialization:
            return True
            
        return project.target_specialization == self.specialization
    
    @property
    def payment_status_display(self) -> str:
        if self.payment_verified:
            return "‚úÖ Verified"
        return "‚ùå Not Verified"
    
    @property
    def can_enroll_in_semester(self) -> bool:
        if self.role in [UserRole.ADMIN, UserRole.INSTRUCTOR]:
            return True
        
        return self.payment_verified
    
    def verify_payment(self, admin_user: 'User') -> None:
        self.payment_verified = True
        self.payment_verified_at = datetime.now(timezone.utc)
        self.payment_verified_by = admin_user.id
    
    def unverify_payment(self) -> None:
        self.payment_verified = False
        self.payment_verified_at = None
        self.payment_verified_by = None
================================================================================
FILE: app/models/booking.py [CRITICAL-BACKEND]
================================================================================

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.ext.hybrid import hybrid_property
from datetime import datetime, timezone
import enum

from ..database import Base
class BookingStatus(enum.Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    CANCELLED = "cancelled"
    WAITLISTED = "waitlisted"
class Booking(Base):
    __tablename__ = "bookings"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    session_id = Column(Integer, ForeignKey("sessions.id"), nullable=False)
    status = Column(Enum(BookingStatus), default=BookingStatus.PENDING)
    waitlist_position = Column(Integer, nullable=True)
    notes = Column(String, nullable=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    cancelled_at = Column(DateTime, nullable=True)
    
    attended_status = Column(String(20), nullable=True)

    user = relationship("User", back_populates="bookings")
    session = relationship("Session", back_populates="bookings")
    attendance = relationship("Attendance", back_populates="booking", uselist=False)
    notifications = relationship("Notification", back_populates="related_booking")

    @hybrid_property
    def attended(self):
        if self.attendance:
            return self.attendance.status.value in ['present', 'late']
        return False

    @attended.expression  
    def attended(cls):
        return cls.attended_status.in_(['present', 'late'])

    @hybrid_property
    def can_give_feedback(self):
        
        if self.status != BookingStatus.CONFIRMED:
            return False
        
        if not self.attended:
            return False
        
        return not any(f.session_id == self.session_id for f in self.user.feedbacks)

    @hybrid_property  
    def feedback_submitted(self):
        return any(f.session_id == self.session_id for f in self.user.feedbacks)

    def update_attendance_status(self):
        if self.attendance:
            self.attended_status = self.attendance.status.value
        else:
            self.attended_status = None
================================================================================
FILE: app/models/session.py [CRITICAL-BACKEND]
================================================================================

from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Enum, Boolean
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
import enum
from typing import Optional

from ..database import Base
from .specialization import SpecializationType
class SessionMode(enum.Enum):
    ONLINE = "online"
    OFFLINE = "offline"
    HYBRID = "hybrid"
class Session(Base):
    __tablename__ = "sessions"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    date_start = Column(DateTime, nullable=False)
    date_end = Column(DateTime, nullable=False)
    mode = Column(Enum(SessionMode), default=SessionMode.OFFLINE)
    capacity = Column(Integer, default=20)
    location = Column(String, nullable=True)  # for offline sessions
    meeting_link = Column(String, nullable=True)  # for online sessions
    sport_type = Column(String, default='General')  # Enhanced field for UI
    level = Column(String, default='All Levels')  # Enhanced field for UI
    instructor_name = Column(String, nullable=True)  # Enhanced field for UI
    semester_id = Column(Integer, ForeignKey("semesters.id"), nullable=False)
    group_id = Column(Integer, ForeignKey("groups.id"), nullable=True)  # FIXED: Made nullable to allow sessions without groups
    instructor_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    
    target_specialization = Column(
        Enum(SpecializationType),
        nullable=True,
        comment="Target specialization for this session (null = all specializations)"
    )
    
    mixed_specialization = Column(
        Boolean,
        default=False,
        comment="Whether this session is open to all specializations"
    )
    
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))

    semester = relationship("Semester", back_populates="sessions")
    group = relationship("Group", back_populates="sessions")
    instructor = relationship("User", back_populates="taught_sessions")
    bookings = relationship("Booking", back_populates="session")
    attendances = relationship("Attendance", back_populates="session")
    feedbacks = relationship("Feedback", back_populates="session")
    notifications = relationship("Notification", back_populates="related_session")
    project_sessions = relationship("ProjectSession", back_populates="session")

    @property
    def related_projects(self):
        return [ps.project for ps in self.project_sessions]
    
    @property
    def is_project_session(self):
        return len(self.project_sessions) > 0
    
    @property
    def specialization_info(self) -> str:
        if self.mixed_specialization:
            return "Vegyes (Player + Coach)"
        elif self.target_specialization:
            return SpecializationType.get_display_name(self.target_specialization)
        return "Minden szakir√°ny"
    
    @property
    def specialization_badge(self) -> str:
        if self.mixed_specialization:
            return "‚öΩüë®‚Äçüè´"
        elif self.target_specialization:
            return SpecializationType.get_icon(self.target_specialization)
        return "üéØ"
    
    @property
    def is_accessible_to_all(self) -> bool:
        return self.mixed_specialization or self.target_specialization is None
================================================================================
FILE: app/schemas/user.py [CRITICAL-BACKEND]
================================================================================

from pydantic import BaseModel, EmailStr, ConfigDict
from typing import Optional, List
from datetime import datetime
from ..models.user import UserRole
class UserBase(BaseModel):
    name: str
    nickname: Optional[str] = None
    email: EmailStr
    role: UserRole = UserRole.STUDENT
    is_active: bool = True
class UserCreate(UserBase):
    password: str
class UserUpdate(BaseModel):
    name: Optional[str] = None
    nickname: Optional[str] = None
    email: Optional[EmailStr] = None
    role: Optional[UserRole] = None
    is_active: Optional[bool] = None
class UserUpdateSelf(BaseModel):
    name: Optional[str] = None
    nickname: Optional[str] = None
    email: Optional[EmailStr] = None
    onboarding_completed: Optional[bool] = None
    phone: Optional[str] = None
    emergency_contact: Optional[str] = None
    emergency_phone: Optional[str] = None
    date_of_birth: Optional[datetime] = None
    medical_notes: Optional[str] = None
    interests: Optional[str] = None  # JSON string of interests array
class User(UserBase):
    id: int
    onboarding_completed: Optional[bool] = False
    phone: Optional[str] = None
    emergency_contact: Optional[str] = None
    emergency_phone: Optional[str] = None
    date_of_birth: Optional[datetime] = None
    medical_notes: Optional[str] = None
    interests: Optional[str] = None  # JSON string of interests array
    payment_verified: Optional[bool] = False
    payment_verified_at: Optional[datetime] = None
    payment_verified_by: Optional[int] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    created_by: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)
class UserWithStats(User):
    total_bookings: int
    completed_sessions: int
    feedback_count: int
class UserList(BaseModel):
    users: List[User]
    total: int
    page: int
    size: int
================================================================================
FILE: app/schemas/booking.py [CRITICAL-BACKEND]
================================================================================

from pydantic import BaseModel, ConfigDict
from typing import Optional, List
from datetime import datetime
from ..models.booking import BookingStatus
from .user import User
from .session import Session
class BookingBase(BaseModel):
    session_id: int
    notes: Optional[str] = None
class BookingCreate(BookingBase):
    pass
class BookingUpdate(BaseModel):
    notes: Optional[str] = None
    status: Optional[BookingStatus] = None
class Booking(BookingBase):
    id: int
    user_id: int
    status: BookingStatus
    waitlist_position: Optional[int] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    cancelled_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)
class BookingWithRelations(Booking):
    user: User
    session: Session
    attended: Optional[bool] = None  # Whether the user attended this session
class BookingList(BaseModel):
    bookings: List[BookingWithRelations]
    total: int
    page: int
    size: int
class BookingStatusUpdate(BaseModel):
    status: BookingStatus
    notes: Optional[str] = None
class BookingConfirm(BaseModel):
    notes: Optional[str] = None
class BookingCancel(BaseModel):
    reason: Optional[str] = None
================================================================================
FILE: app/core/security.py [CRITICAL-BACKEND]
================================================================================

from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)
def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)
================================================================================
FILE: requirements.txt [CONFIG]
================================================================================

fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
psycopg2==2.9.9
alembic==1.12.1
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
pydantic==2.5.0
pydantic-settings==2.1.0
python-dotenv==1.0.0
email-validator==2.1.2
pytest==7.4.3
httpx==0.25.2
pytest-asyncio==0.21.1
================================================================================
FILE: frontend/package.json [CONFIG]
================================================================================

{"name":"frontend","version":"0.1.0","private":true,"dependencies":{"@testing-library/dom":"^10.4.1","@testing-library/jest-dom":"^6.8.0","@testing-library/react":"^16.3.0","@testing-library/user-event":"^13.5.0","axios":"^1.11.0","react":"^19.1.1","react-dom":"^19.1.1","react-router-dom":"^6.30.1","react-scripts":"^5.0.1","web-vitals":"^2.1.4"},"scripts":{"start":"HOST=0.0.0.0 react-scripts start","build":"react-scripts build","test":"react-scripts test","eject":"react-scripts eject"},"eslintConfig":{"extends":["react-app","react-app/jest"]},"browserslist":{"production":[">0.2%","not dead","not op_mini all"],"development":["last 1 chrome version","last 1 firefox version","last 1 safari version"]}}

================================================================================
FILE: alembic.ini [CONFIG]
================================================================================

# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python-dateutil library that can be
# installed by adding `alembic[tz]` to the pip requirements
# string value is passed to dateutil.tz.gettz()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses
# os.pathsep. If this key is omitted entirely, it falls back to the legacy
# behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = sqlite://username:password@localhost:5432/practice_booking_system


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
================================================================================
FILE: .env.example [CONFIG]
================================================================================

# Database
DATABASE_URL=postgresql://username:password@localhost:5432/practice_booking_system

# JWT
SECRET_KEY=your-super-secret-jwt-key-change-this
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# App
APP_NAME="Practice Booking System"
DEBUG=True
API_V1_STR="/api/v1"

# Initial Admin
ADMIN_EMAIL=admin@company.com
ADMIN_PASSWORD=admin123
ADMIN_NAME=System Administrator

# Booking Rules
MAX_BOOKINGS_PER_SEMESTER=10
BOOKING_DEADLINE_HOURS=24
================================================================================
FILE: app/models/user.py [MODEL]
================================================================================

from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Enum
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
import enum
from typing import Optional

from ..database import Base
from .specialization import SpecializationType
class UserRole(enum.Enum):
    ADMIN = "admin"
    INSTRUCTOR = "instructor"
    STUDENT = "student"
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    nickname = Column(String, nullable=True)
    email = Column(String, unique=True, nullable=False, index=True)
    password_hash = Column(String, nullable=False)
    role = Column(Enum(UserRole), nullable=False, default=UserRole.STUDENT)
    is_active = Column(Boolean, default=True)
    onboarding_completed = Column(Boolean, default=False)
    phone = Column(String, nullable=True)
    emergency_contact = Column(String, nullable=True)
    emergency_phone = Column(String, nullable=True)
    date_of_birth = Column(DateTime, nullable=True)
    medical_notes = Column(String, nullable=True)
    interests = Column(String, nullable=True)  # JSON string of interests array
    
    specialization = Column(
        Enum(SpecializationType), 
        nullable=True,
        comment="User's chosen specialization track (Player/Coach)"
    )
    
    payment_verified = Column(
        Boolean, 
        nullable=False, 
        default=False,
        comment="Whether student has paid semester fees"
    )
    payment_verified_at = Column(
        DateTime, 
        nullable=True,
        comment="Timestamp when payment was verified"
    )
    payment_verified_by = Column(
        Integer, 
        ForeignKey("users.id"), 
        nullable=True,
        comment="Admin who verified the payment"
    )
    
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    created_by = Column(Integer, ForeignKey("users.id"), nullable=True)

    creator = relationship("User", remote_side=[id], foreign_keys=[created_by], post_update=True)
    created_users = relationship("User", foreign_keys=[created_by], remote_side=[created_by], overlaps="creator", post_update=True)
    
    payment_verifier = relationship("User", remote_side=[id], foreign_keys=[payment_verified_by], post_update=True)
    groups = relationship("Group", secondary="group_users", back_populates="users")
    bookings = relationship("Booking", back_populates="user")
    attendances = relationship("Attendance", foreign_keys="Attendance.user_id", back_populates="user")
    feedbacks = relationship("Feedback", back_populates="user")
    notifications = relationship("Notification", back_populates="user")
    taught_sessions = relationship("Session", back_populates="instructor")
    marked_attendances = relationship("Attendance", foreign_keys="Attendance.marked_by", back_populates="marker")
    
    instructed_projects = relationship("Project", back_populates="instructor")
    project_enrollments = relationship("ProjectEnrollment", back_populates="user")
    sent_messages = relationship("Message", back_populates="sender", foreign_keys="Message.sender_id")
    received_messages = relationship("Message", back_populates="recipient", foreign_keys="Message.recipient_id")
    
    @property
    def specialization_display(self) -> str:
        return SpecializationType.get_display_name(self.specialization)
    
    @property
    def specialization_icon(self) -> str:
        return SpecializationType.get_icon(self.specialization)
    
    @property
    def has_specialization(self) -> bool:
        return self.specialization is not None
    
    def can_access_session(self, session) -> bool:
        """
        Check if user can access session based on specialization
        ‚ö†Ô∏è CRITICAL: This preserves Mbapp√© cross-semester logic
        """
        if self.email == "mbappe@lfa.com":
            return True  # Mbapp√© can access ALL sessions
        
        if not self.specialization:
            return True
            
        if not hasattr(session, 'target_specialization') or not session.target_specialization:
            return True
            
        if hasattr(session, 'mixed_specialization') and session.mixed_specialization:
            return True
            
        return session.target_specialization == self.specialization
    
    def can_enroll_in_project(self, project) -> bool:
        if not self.specialization:
            return True
            
        if not hasattr(project, 'target_specialization') or not project.target_specialization:
            return True
            
        if hasattr(project, 'mixed_specialization') and project.mixed_specialization:
            return True
            
        return project.target_specialization == self.specialization
    
    @property
    def payment_status_display(self) -> str:
        if self.payment_verified:
            return "‚úÖ Verified"
        return "‚ùå Not Verified"
    
    @property
    def can_enroll_in_semester(self) -> bool:
        if self.role in [UserRole.ADMIN, UserRole.INSTRUCTOR]:
            return True
        
        return self.payment_verified
    
    def verify_payment(self, admin_user: 'User') -> None:
        self.payment_verified = True
        self.payment_verified_at = datetime.now(timezone.utc)
        self.payment_verified_by = admin_user.id
    
    def unverify_payment(self) -> None:
        self.payment_verified = False
        self.payment_verified_at = None
        self.payment_verified_by = None
================================================================================
FILE: app/models/quiz.py [MODEL]
================================================================================

from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey, Enum as SQLEnum, Float, UniqueConstraint
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum
from app.database import Base

class QuestionType(enum.Enum):
    MULTIPLE_CHOICE = "multiple_choice"
    TRUE_FALSE = "true_false"
    FILL_IN_BLANK = "fill_in_blank"
    MATCHING = "matching"
    SHORT_ANSWER = "short_answer"
    LONG_ANSWER = "long_answer"
    CALCULATION = "calculation"
    SCENARIO_BASED = "scenario_based"

class QuizCategory(enum.Enum):
    GENERAL = "general"
    MARKETING = "marketing"
    ECONOMICS = "economics"
    INFORMATICS = "informatics"
    SPORTS_PHYSIOLOGY = "sports_physiology"
    NUTRITION = "nutrition"

class QuizDifficulty(enum.Enum):
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"

class Quiz(Base):
    __tablename__ = "quizzes"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(200), nullable=False)
    description = Column(Text, nullable=True)
    category = Column(SQLEnum(QuizCategory), nullable=False)
    difficulty = Column(SQLEnum(QuizDifficulty), nullable=False, default=QuizDifficulty.MEDIUM)
    time_limit_minutes = Column(Integer, nullable=False, default=15)  # id≈ëkorl√°t percekben
    xp_reward = Column(Integer, nullable=False, default=50)  # XP jutalom sikeres kit√∂lt√©s√©rt
    passing_score = Column(Float, nullable=False, default=70.0)  # minimum pont sz√°zal√©kban
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    questions = relationship("QuizQuestion", back_populates="quiz", cascade="all, delete-orphan")
    attempts = relationship("QuizAttempt", back_populates="quiz")

class QuizQuestion(Base):
    __tablename__ = "quiz_questions"
    
    id = Column(Integer, primary_key=True, index=True)
    quiz_id = Column(Integer, ForeignKey("quizzes.id"), nullable=False)
    question_text = Column(Text, nullable=False)
    question_type = Column(SQLEnum(QuestionType), nullable=False)
    points = Column(Integer, nullable=False, default=1)
    order_index = Column(Integer, nullable=False, default=0)  # k√©rd√©sek sorrendje
    explanation = Column(Text, nullable=True)  # magyar√°zat a helyes v√°laszhoz
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    quiz = relationship("Quiz", back_populates="questions")
    answer_options = relationship("QuizAnswerOption", back_populates="question", cascade="all, delete-orphan")
    user_answers = relationship("QuizUserAnswer", back_populates="question")

class QuizAnswerOption(Base):
    __tablename__ = "quiz_answer_options"
    
    id = Column(Integer, primary_key=True, index=True)
    question_id = Column(Integer, ForeignKey("quiz_questions.id"), nullable=False)
    option_text = Column(String(500), nullable=False)
    is_correct = Column(Boolean, nullable=False, default=False)
    order_index = Column(Integer, nullable=False, default=0)  # v√°laszok sorrendje
    
    question = relationship("QuizQuestion", back_populates="answer_options")

class QuizAttempt(Base):
    __tablename__ = "quiz_attempts"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    quiz_id = Column(Integer, ForeignKey("quizzes.id"), nullable=False)
    started_at = Column(DateTime(timezone=True), server_default=func.now())
    completed_at = Column(DateTime(timezone=True), nullable=True)
    time_spent_minutes = Column(Float, nullable=True)  # t√©nylegesen elt√∂lt√∂tt id≈ë
    score = Column(Float, nullable=True)  # el√©rt pont sz√°zal√©kban
    total_questions = Column(Integer, nullable=False)
    correct_answers = Column(Integer, nullable=False, default=0)
    xp_awarded = Column(Integer, nullable=False, default=0)
    passed = Column(Boolean, nullable=False, default=False)
    
    user = relationship("User")
    quiz = relationship("Quiz", back_populates="attempts")
    user_answers = relationship("QuizUserAnswer", back_populates="attempt", cascade="all, delete-orphan")

class QuizUserAnswer(Base):
    __tablename__ = "quiz_user_answers"
    
    id = Column(Integer, primary_key=True, index=True)
    attempt_id = Column(Integer, ForeignKey("quiz_attempts.id"), nullable=False)
    question_id = Column(Integer, ForeignKey("quiz_questions.id"), nullable=False)
    selected_option_id = Column(Integer, ForeignKey("quiz_answer_options.id"), nullable=True)  # t√∂bbv√°laszt√°sos √©s igaz/hamis k√©rd√©sekhez
    answer_text = Column(String(1000), nullable=True)  # kieg√©sz√≠t≈ës feladatokhoz
    is_correct = Column(Boolean, nullable=False, default=False)
    answered_at = Column(DateTime(timezone=True), server_default=func.now())
    
    attempt = relationship("QuizAttempt", back_populates="user_answers")
    question = relationship("QuizQuestion", back_populates="user_answers")
    selected_option = relationship("QuizAnswerOption")

class UserQuestionPerformance(Base):
    __tablename__ = "user_question_performance"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    question_id = Column(Integer, ForeignKey("quiz_questions.id"), nullable=False)
    
    total_attempts = Column(Integer, default=0)
    correct_attempts = Column(Integer, default=0)
    last_attempt_correct = Column(Boolean, default=False)
    last_attempted_at = Column(DateTime(timezone=True), nullable=True)
    
    difficulty_weight = Column(Float, default=1.0)  # 1.0 = normal, >1.0 = needs more practice
    next_review_at = Column(DateTime(timezone=True), nullable=True)  # spaced repetition
    mastery_level = Column(Float, default=0.0)  # 0.0-1.0 scale
    
    user = relationship("User")
    question = relationship("QuizQuestion")
    
    __table_args__ = (UniqueConstraint('user_id', 'question_id', name='unique_user_question'),)
    
    @property
    def success_rate(self):
        return (self.correct_attempts / self.total_attempts) if self.total_attempts > 0 else 0.0
class AdaptiveLearningSession(Base):
    __tablename__ = "adaptive_learning_sessions"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    category = Column(SQLEnum(QuizCategory), nullable=False)
    
    started_at = Column(DateTime(timezone=True), server_default=func.now())
    ended_at = Column(DateTime(timezone=True), nullable=True)
    questions_presented = Column(Integer, default=0)
    questions_correct = Column(Integer, default=0)
    xp_earned = Column(Integer, default=0)
    
    target_difficulty = Column(Float, default=0.5)  # 0.0-1.0
    performance_trend = Column(Float, default=0.0)  # -1.0 to 1.0
    
    session_time_limit_seconds = Column(Integer, default=1800)  # 30 minutes default
    session_start_time = Column(DateTime(timezone=True), nullable=True)
    
    user = relationship("User")
class QuestionMetadata(Base):
    __tablename__ = "question_metadata"
    
    id = Column(Integer, primary_key=True, index=True)
    question_id = Column(Integer, ForeignKey("quiz_questions.id"), nullable=False)
    
    estimated_difficulty = Column(Float, default=0.5)  # 0.0-1.0
    cognitive_load = Column(Float, default=0.5)  # 0.0-1.0
    concept_tags = Column(String(500), nullable=True)  # JSON array of concepts
    prerequisite_concepts = Column(String(500), nullable=True)  # JSON array
    
    average_time_seconds = Column(Float, nullable=True)
    global_success_rate = Column(Float, nullable=True)
    last_analytics_update = Column(DateTime(timezone=True), nullable=True)
    
    question = relationship("QuizQuestion")
    
    __table_args__ = (UniqueConstraint('question_id', name='unique_question_metadata'),)
================================================================================
FILE: app/models/specialization.py [MODEL]
================================================================================

"""
üéì User Specialization Models and Enums
Defines the Player/Coach specialization system for the LFA education platform
"""
import enum
from typing import Optional
class SpecializationType(enum.Enum):
    PLAYER = "PLAYER"
    COACH = "COACH"
    INTERNSHIP = "INTERNSHIP"
    
    @classmethod
    def get_display_name(cls, specialization: Optional['SpecializationType']) -> str:
        if not specialization:
            return "Nincs kiv√°lasztva"
            
        display_names = {
            cls.PLAYER: "Player (J√°t√©kos fejleszt√©s)",
            cls.COACH: "Coach (Edz≈ëi, vezet√©si k√©szs√©gek)",
            cls.INTERNSHIP: "Internship (Gyakornoki program)"
        }
        return display_names.get(specialization, str(specialization))
    
    @classmethod
    def get_description(cls, specialization: Optional['SpecializationType']) -> str:
        if not specialization:
            return "M√©g nincs kiv√°lasztva szakir√°ny"
            
        descriptions = {
            cls.PLAYER: "J√°t√©kos fejleszt√©si f√≥kusz - technikai k√©szs√©gek, taktikai tud√°s, fizikai fejl≈ëd√©s, ment√°lis er≈ëss√©g",
            cls.COACH: "Edz≈ëi √©s vezet√©si f√≥kusz - csapatvezet√©s, taktikai elemz√©s, kommunik√°ci√≥, strat√©giai tervez√©s",
            cls.INTERNSHIP: "Gyakornoki program - val√≥s munkak√∂rnyezeti tapasztalat, mentorship, gyakorlati projektmunka, karrierfejleszt√©s"
        }
        return descriptions.get(specialization, "")
    
    @classmethod
    def get_features(cls, specialization: Optional['SpecializationType']) -> list:
        if not specialization:
            return []
            
        features = {
            cls.PLAYER: [
                "Technikai k√©szs√©gfejleszt√©s",
                "Taktikai meg√©rt√©s",
                "Fizikai kond√≠ci√≥",
                "Ment√°lis er≈ëss√©g",
                "Csapatj√°t√©k"
            ],
            cls.COACH: [
                "Csapatvezet√©si k√©szs√©gek", 
                "Taktikai elemz√©s",
                "Kommunik√°ci√≥",
                "Strat√©giai tervez√©s",
                "Motiv√°ci√≥s technik√°k"
            ],
            cls.INTERNSHIP: [
                "Val√≥s projektmunka",
                "Mentorship √©s t√°mogat√°s",
                "Munkak√∂rnyezeti tapasztalat",
                "Szakmai h√°l√≥zat√©p√≠t√©s",
                "Karrierfejleszt√©s"
            ]
        }
        return features.get(specialization, [])
    
    @classmethod
    def get_icon(cls, specialization: Optional['SpecializationType']) -> str:
        if not specialization:
            return "‚ùì"
            
        icons = {
            cls.PLAYER: "‚öΩ",
            cls.COACH: "üë®‚Äçüè´",
            cls.INTERNSHIP: "üéì"
        }
        return icons.get(specialization, "üéØ")
    
    @classmethod
    def get_session_access_info(cls, specialization: Optional['SpecializationType']) -> str:
        if not specialization:
            return "Minden session el√©rhet≈ë (nincs specializ√°ci√≥)"
        
        access_info = {
            cls.PLAYER: "Player-specifikus, vegyes √©s √°ltal√°nos sessionok",
            cls.COACH: "Coach-specifikus, vegyes √©s √°ltal√°nos session√∂k",
            cls.INTERNSHIP: "Gyakornoki mentorship session√∂k, gyakorlati workshopok √©s minden √°ltal√°nos session"
        }
        return access_info.get(specialization, "Ismeretlen hozz√°f√©r√©s")
    
    @classmethod
    def get_project_access_info(cls, specialization: Optional['SpecializationType']) -> str:
        if not specialization:
            return "Minden projekt el√©rhet≈ë (nincs specializ√°ci√≥)"
        
        access_info = {
            cls.PLAYER: "Player-f√≥kusz√∫, interdiszciplin√°ris √©s √°ltal√°nos projektek",
            cls.COACH: "Coach-f√≥kusz√∫, interdiszciplin√°ris √©s √°ltal√°nos projektek",
            cls.INTERNSHIP: "Gyakornoki projektek, val√≥s munkak√∂rnyezeti feladatok √©s interdiszciplin√°ris kollabor√°ci√≥s projektek"
        }
        return access_info.get(specialization, "Ismeretlen hozz√°f√©r√©s")
    
    @classmethod
    def get_progression_path(cls) -> list:
        return [
            {
                'code': cls.PLAYER.value,
                'name': cls.get_display_name(cls.PLAYER),
                'description': 'Alapk√©pz√©s - j√°t√©kos fejleszt√©s',
                'semester': 1,
                'prerequisite': None
            },
            {
                'code': cls.COACH.value,
                'name': cls.get_display_name(cls.COACH),
                'description': 'Halad√≥ k√©pz√©s - edz≈ëi k√©szs√©gek',
                'semester': 2,
                'prerequisite': cls.PLAYER.value
            },
            {
                'code': cls.INTERNSHIP.value,
                'name': cls.get_display_name(cls.INTERNSHIP),
                'description': 'Gyakorlati program - b√°rmikor el√©rhet≈ë',
                'semester': 'any',
                'prerequisite': None
            }
        ]
    
    @classmethod
    def get_available_for_user(cls, current_specialization: Optional['SpecializationType'], semester_count: int = 1) -> list:
        available = []
        progression = cls.get_progression_path()
        
        for spec in progression:
            if spec['code'] == cls.INTERNSHIP.value:
                available.append(spec)
            elif semester_count == 1 and spec['semester'] == 1:
                available.append(spec)
            elif semester_count >= 2 and spec['semester'] == 2:
                if current_specialization == cls.PLAYER or current_specialization is None:
                    available.append(spec)
        
        return available
    
    @classmethod
    def validate_specialization_change(cls, current: Optional['SpecializationType'], new: 'SpecializationType', semester_count: int = 1) -> tuple[bool, str]:
        if new == cls.INTERNSHIP:
            return True, "Gyakornoki program b√°rmikor el√©rhet≈ë"
        
        if semester_count == 1:
            if new == cls.PLAYER:
                return True, "Player specializ√°ci√≥ v√°laszthat√≥ az els≈ë szemeszterben"
            else:
                return False, "Els≈ë szemeszterben csak Player specializ√°ci√≥ v√°laszthat√≥"
        
        if semester_count >= 2:
            if new == cls.COACH and (current == cls.PLAYER or current is None):
                return True, "Coach specializ√°ci√≥ v√°laszthat√≥ Player ut√°n a m√°sodik szemesztert≈ël"
            elif new == cls.PLAYER:
                return True, "Player specializ√°ci√≥ mindig v√°laszthat√≥"
            else:
                return False, "Coach specializ√°c√≥hoz Player el≈ëk√©pzetts√©g sz√ºks√©ges"
        
        return False, "√ârv√©nytelen specializ√°ci√≥ v√°lt√°s"
================================================================================
FILE: app/models/semester.py [MODEL]
================================================================================

from sqlalchemy import Column, Integer, String, Date, Boolean, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime, timezone

from ..database import Base
class Semester(Base):
    __tablename__ = "semesters"

    id = Column(Integer, primary_key=True, index=True)
    code = Column(String, unique=True, nullable=False, index=True)  # "2024/1"
    name = Column(String, nullable=False)  # "2024/25 ≈ëszi f√©l√©v"
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))

    groups = relationship("Group", back_populates="semester")
    sessions = relationship("Session", back_populates="semester")
    projects = relationship("Project", back_populates="semester")
================================================================================
FILE: app/models/feedback.py [MODEL]
================================================================================

from sqlalchemy import Column, Integer, Text, Float, Boolean, DateTime, ForeignKey, CheckConstraint
from sqlalchemy.orm import relationship
from datetime import datetime, timezone

from ..database import Base
class Feedback(Base):
    __tablename__ = "feedback"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    session_id = Column(Integer, ForeignKey("sessions.id"), nullable=False)
    rating = Column(Float, nullable=False)  # Overall rating
    instructor_rating = Column(Float, nullable=True)  # Instructor specific rating
    session_quality = Column(Float, nullable=True)   # Session quality rating
    would_recommend = Column(Boolean, nullable=True)  # Recommendation
    comment = Column(Text, nullable=True)
    is_anonymous = Column(Boolean, default=False)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))

    __table_args__ = (
        CheckConstraint('rating >= 1.0 AND rating <= 5.0', name='rating_range'),
        CheckConstraint('instructor_rating IS NULL OR (instructor_rating >= 1.0 AND instructor_rating <= 5.0)', name='instructor_rating_range'),
        CheckConstraint('session_quality IS NULL OR (session_quality >= 1.0 AND session_quality <= 5.0)', name='session_quality_range'),
    )

    user = relationship("User", back_populates="feedbacks")
    session = relationship("Session", back_populates="feedbacks")
================================================================================
FILE: app/models/notification.py [MODEL]
================================================================================

from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey, Enum
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
import enum

from ..database import Base
class NotificationType(enum.Enum):
    BOOKING_CONFIRMED = "booking_confirmed"
    BOOKING_CANCELLED = "booking_cancelled"
    SESSION_REMINDER = "session_reminder"
    SESSION_CANCELLED = "session_cancelled"
    WAITLIST_PROMOTED = "waitlist_promoted"
    GENERAL = "general"
class Notification(Base):
    __tablename__ = "notifications"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    title = Column(String, nullable=False)
    message = Column(Text, nullable=False)
    type = Column(Enum(NotificationType), default=NotificationType.GENERAL)
    is_read = Column(Boolean, default=False)
    related_session_id = Column(Integer, ForeignKey("sessions.id"), nullable=True)
    related_booking_id = Column(Integer, ForeignKey("bookings.id"), nullable=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    read_at = Column(DateTime, nullable=True)

    user = relationship("User", back_populates="notifications")
    related_session = relationship("Session", back_populates="notifications")
    related_booking = relationship("Booking", back_populates="notifications")
================================================================================
FILE: app/models/attendance.py [MODEL]
================================================================================

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Enum
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
import enum

from ..database import Base
class AttendanceStatus(enum.Enum):
    PRESENT = "present"
    ABSENT = "absent"
    LATE = "late"
    EXCUSED = "excused"
class Attendance(Base):
    __tablename__ = "attendance"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    session_id = Column(Integer, ForeignKey("sessions.id"), nullable=False)
    booking_id = Column(Integer, ForeignKey("bookings.id"), nullable=False)
    status = Column(Enum(AttendanceStatus), default=AttendanceStatus.PRESENT)
    check_in_time = Column(DateTime, nullable=True)
    check_out_time = Column(DateTime, nullable=True)
    notes = Column(String, nullable=True)
    marked_by = Column(Integer, ForeignKey("users.id"), nullable=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))

    user = relationship("User", foreign_keys=[user_id], back_populates="attendances")
    session = relationship("Session", back_populates="attendances")
    booking = relationship("Booking", back_populates="attendance")
    marker = relationship("User", foreign_keys=[marked_by], back_populates="marked_attendances")
================================================================================
FILE: app/models/booking.py [MODEL]
================================================================================

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.ext.hybrid import hybrid_property
from datetime import datetime, timezone
import enum

from ..database import Base
class BookingStatus(enum.Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    CANCELLED = "cancelled"
    WAITLISTED = "waitlisted"
class Booking(Base):
    __tablename__ = "bookings"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    session_id = Column(Integer, ForeignKey("sessions.id"), nullable=False)
    status = Column(Enum(BookingStatus), default=BookingStatus.PENDING)
    waitlist_position = Column(Integer, nullable=True)
    notes = Column(String, nullable=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    cancelled_at = Column(DateTime, nullable=True)
    
    attended_status = Column(String(20), nullable=True)

    user = relationship("User", back_populates="bookings")
    session = relationship("Session", back_populates="bookings")
    attendance = relationship("Attendance", back_populates="booking", uselist=False)
    notifications = relationship("Notification", back_populates="related_booking")

    @hybrid_property
    def attended(self):
        if self.attendance:
            return self.attendance.status.value in ['present', 'late']
        return False

    @attended.expression  
    def attended(cls):
        return cls.attended_status.in_(['present', 'late'])

    @hybrid_property
    def can_give_feedback(self):
        
        if self.status != BookingStatus.CONFIRMED:
            return False
        
        if not self.attended:
            return False
        
        return not any(f.session_id == self.session_id for f in self.user.feedbacks)

    @hybrid_property  
    def feedback_submitted(self):
        return any(f.session_id == self.session_id for f in self.user.feedbacks)

    def update_attendance_status(self):
        if self.attendance:
            self.attended_status = self.attendance.status.value
        else:
            self.attended_status = None
================================================================================
FILE: app/schemas/auth.py [SCHEMA]
================================================================================

from pydantic import BaseModel, EmailStr
from typing import Optional
class Login(BaseModel):
    email: EmailStr
    password: str
class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
class TokenData(BaseModel):
    username: Optional[str] = None
class RefreshToken(BaseModel):
    refresh_token: str
class ChangePassword(BaseModel):
    old_password: str
    new_password: str
class ResetPassword(BaseModel):
    new_password: str
================================================================================
FILE: app/schemas/user.py [SCHEMA]
================================================================================

from pydantic import BaseModel, EmailStr, ConfigDict
from typing import Optional, List
from datetime import datetime
from ..models.user import UserRole
class UserBase(BaseModel):
    name: str
    nickname: Optional[str] = None
    email: EmailStr
    role: UserRole = UserRole.STUDENT
    is_active: bool = True
class UserCreate(UserBase):
    password: str
class UserUpdate(BaseModel):
    name: Optional[str] = None
    nickname: Optional[str] = None
    email: Optional[EmailStr] = None
    role: Optional[UserRole] = None
    is_active: Optional[bool] = None
class UserUpdateSelf(BaseModel):
    name: Optional[str] = None
    nickname: Optional[str] = None
    email: Optional[EmailStr] = None
    onboarding_completed: Optional[bool] = None
    phone: Optional[str] = None
    emergency_contact: Optional[str] = None
    emergency_phone: Optional[str] = None
    date_of_birth: Optional[datetime] = None
    medical_notes: Optional[str] = None
    interests: Optional[str] = None  # JSON string of interests array
class User(UserBase):
    id: int
    onboarding_completed: Optional[bool] = False
    phone: Optional[str] = None
    emergency_contact: Optional[str] = None
    emergency_phone: Optional[str] = None
    date_of_birth: Optional[datetime] = None
    medical_notes: Optional[str] = None
    interests: Optional[str] = None  # JSON string of interests array
    payment_verified: Optional[bool] = False
    payment_verified_at: Optional[datetime] = None
    payment_verified_by: Optional[int] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    created_by: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)
class UserWithStats(User):
    total_bookings: int
    completed_sessions: int
    feedback_count: int
class UserList(BaseModel):
    users: List[User]
    total: int
    page: int
    size: int
================================================================================
FILE: app/schemas/quiz.py [SCHEMA]
================================================================================

from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field
from datetime import datetime
from app.models.quiz import QuestionType, QuizCategory, QuizDifficulty

class QuizAnswerOptionBase(BaseModel):
    option_text: str = Field(..., max_length=500)
    is_correct: bool = False
    order_index: int = 0

class QuizAnswerOptionCreate(QuizAnswerOptionBase):
    pass

class QuizAnswerOptionResponse(QuizAnswerOptionBase):
    id: int
    question_id: int
    
    class Config:
        from_attributes = True

class QuizAnswerOptionPublic(BaseModel):
    id: int
    option_text: str
    order_index: int
    
    class Config:
        from_attributes = True

class QuizQuestionBase(BaseModel):
    question_text: str
    question_type: QuestionType
    points: int = 1
    order_index: int = 0
    explanation: Optional[str] = None

class QuizQuestionCreate(QuizQuestionBase):
    answer_options: List[QuizAnswerOptionCreate] = []

class QuizQuestionUpdate(BaseModel):
    question_text: Optional[str] = None
    question_type: Optional[QuestionType] = None
    points: Optional[int] = None
    order_index: Optional[int] = None
    explanation: Optional[str] = None
    answer_options: Optional[List[QuizAnswerOptionCreate]] = None

class QuizQuestionResponse(QuizQuestionBase):
    id: int
    quiz_id: int
    created_at: datetime
    answer_options: List[QuizAnswerOptionResponse] = []
    
    class Config:
        from_attributes = True

class QuizQuestionPublic(BaseModel):
    id: int
    question_text: str
    question_type: QuestionType
    points: int
    order_index: int
    answer_options: List[QuizAnswerOptionPublic] = []
    
    class Config:
        from_attributes = True

class QuizBase(BaseModel):
    title: str = Field(..., max_length=200)
    description: Optional[str] = None
    category: QuizCategory
    difficulty: QuizDifficulty = QuizDifficulty.MEDIUM
    time_limit_minutes: int = 15
    xp_reward: int = 50
    passing_score: float = 70.0
    is_active: bool = True

class QuizCreate(QuizBase):
    questions: List[QuizQuestionCreate] = []

class QuizUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    category: Optional[QuizCategory] = None
    difficulty: Optional[QuizDifficulty] = None
    time_limit_minutes: Optional[int] = None
    xp_reward: Optional[int] = None
    passing_score: Optional[float] = None
    is_active: Optional[bool] = None

class QuizResponse(QuizBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None
    questions: List[QuizQuestionResponse] = []
    
    class Config:
        from_attributes = True

class QuizListItem(BaseModel):
    id: int
    title: str
    description: Optional[str] = None
    category: QuizCategory
    difficulty: QuizDifficulty
    time_limit_minutes: int
    xp_reward: int
    question_count: int
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class QuizPublic(BaseModel):
    id: int
    title: str
    description: Optional[str] = None
    category: QuizCategory
    difficulty: QuizDifficulty
    time_limit_minutes: int
    xp_reward: int
    passing_score: float
    questions: List[QuizQuestionPublic] = []
    
    class Config:
        from_attributes = True

class QuizUserAnswerCreate(BaseModel):
    question_id: int
    selected_option_id: Optional[int] = None  # Multiple choice and True/False
    answer_text: Optional[str] = None  # Fill in the blank

class QuizAttemptStart(BaseModel):
    quiz_id: int

class QuizAttemptSubmit(BaseModel):
    attempt_id: int
    answers: List[QuizUserAnswerCreate]

class QuizUserAnswerResponse(BaseModel):
    id: int
    question_id: int
    selected_option_id: Optional[int] = None
    answer_text: Optional[str] = None
    is_correct: bool
    answered_at: datetime
    
    class Config:
        from_attributes = True

class QuizAttemptResponse(BaseModel):
    id: int
    user_id: int
    quiz_id: int
    started_at: datetime
    completed_at: Optional[datetime] = None
    time_spent_minutes: Optional[float] = None
    score: Optional[float] = None
    total_questions: int
    correct_answers: int
    xp_awarded: int
    passed: bool
    user_answers: List[QuizUserAnswerResponse] = []
    
    class Config:
        from_attributes = True

class QuizAttemptSummary(BaseModel):
    id: int
    quiz_title: str
    quiz_category: QuizCategory
    started_at: datetime
    completed_at: Optional[datetime] = None
    score: Optional[float] = None
    passed: bool
    xp_awarded: int
    time_spent_minutes: Optional[float] = None
    
    class Config:
        from_attributes = True

class QuizStatistics(BaseModel):
    quiz_id: int
    quiz_title: str
    total_attempts: int
    completed_attempts: int
    average_score: Optional[float] = None
    pass_rate: float = 0.0
    average_time_minutes: Optional[float] = None

class UserQuizStatistics(BaseModel):
    user_id: int
    total_quizzes_attempted: int
    total_quizzes_completed: int
    total_quizzes_passed: int
    total_xp_earned: int
    average_score: Optional[float] = None
    completion_rate: float = 0.0
    pass_rate: float = 0.0
    favorite_category: Optional[QuizCategory] = None

class QuizDashboardOverview(BaseModel):
    available_quizzes: int
    completed_quizzes: int
    total_xp_from_quizzes: int
    best_category: Optional[QuizCategory] = None
    recent_attempts: List[QuizAttemptSummary] = []
    
class QuizCategoryProgress(BaseModel):
    category: QuizCategory
    available_quizzes: int
    completed_quizzes: int
    average_score: Optional[float] = None
    total_xp_earned: int
================================================================================
FILE: app/schemas/semester.py [SCHEMA]
================================================================================

from pydantic import BaseModel, ConfigDict
from typing import Optional, List
from datetime import datetime, date
class SemesterBase(BaseModel):
    code: str
    name: str
    start_date: date
    end_date: date
    is_active: bool = True
class SemesterCreate(SemesterBase):
    pass
class SemesterUpdate(BaseModel):
    code: Optional[str] = None
    name: Optional[str] = None
    start_date: Optional[date] = None
    end_date: Optional[date] = None
    is_active: Optional[bool] = None
class Semester(SemesterBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)
class SemesterWithStats(Semester):
    total_groups: int
    total_sessions: int
    total_bookings: int
    active_users: int
class SemesterList(BaseModel):
    semesters: List[SemesterWithStats]
    total: int
================================================================================
FILE: app/schemas/feedback.py [SCHEMA]
================================================================================

from pydantic import BaseModel, field_validator, ConfigDict
from typing import Optional, List
from datetime import datetime
from .user import User
from .session import Session
class FeedbackBase(BaseModel):
    session_id: int
    rating: float
    instructor_rating: Optional[float] = None
    session_quality: Optional[float] = None
    would_recommend: Optional[bool] = None
    comment: Optional[str] = None
    is_anonymous: bool = False

    @field_validator('rating')
    @classmethod
    def validate_rating(cls, v):
        if not 1.0 <= v <= 5.0:
            raise ValueError('Rating must be between 1.0 and 5.0')
        return v

    @field_validator('instructor_rating')
    @classmethod
    def validate_instructor_rating(cls, v):
        if v is not None and not 1.0 <= v <= 5.0:
            raise ValueError('Instructor rating must be between 1.0 and 5.0')
        return v

    @field_validator('session_quality')
    @classmethod
    def validate_session_quality(cls, v):
        if v is not None and not 1.0 <= v <= 5.0:
            raise ValueError('Session quality must be between 1.0 and 5.0')
        return v
class FeedbackCreate(FeedbackBase):
    pass
class FeedbackUpdate(BaseModel):
    rating: Optional[float] = None
    instructor_rating: Optional[float] = None
    session_quality: Optional[float] = None
    would_recommend: Optional[bool] = None
    comment: Optional[str] = None
    is_anonymous: Optional[bool] = None

    @field_validator('rating')
    @classmethod
    def validate_rating(cls, v):
        if v is not None and not 1.0 <= v <= 5.0:
            raise ValueError('Rating must be between 1.0 and 5.0')
        return v

    @field_validator('instructor_rating')
    @classmethod
    def validate_instructor_rating(cls, v):
        if v is not None and not 1.0 <= v <= 5.0:
            raise ValueError('Instructor rating must be between 1.0 and 5.0')
        return v

    @field_validator('session_quality')
    @classmethod
    def validate_session_quality(cls, v):
        if v is not None and not 1.0 <= v <= 5.0:
            raise ValueError('Session quality must be between 1.0 and 5.0')
        return v
class Feedback(FeedbackBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)
class FeedbackWithRelations(Feedback):
    user: Optional[User] = None  # None if anonymous
    session: Session
class FeedbackList(BaseModel):
    feedbacks: List[FeedbackWithRelations]
    total: int
    page: int
    size: int
class FeedbackSummary(BaseModel):
    session_id: int
    average_rating: float
    total_feedback: int
    rating_distribution: dict  # {1: count, 2: count, ...}
    recent_comments: List[str]
================================================================================
FILE: app/schemas/notification.py [SCHEMA]
================================================================================

from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime
from ..models.notification import NotificationType
class NotificationBase(BaseModel):
    title: str
    message: str
    type: NotificationType = NotificationType.GENERAL
    related_session_id: Optional[int] = None
    related_booking_id: Optional[int] = None
class NotificationCreate(NotificationBase):
    user_id: int
class NotificationUpdate(BaseModel):
    title: Optional[str] = None
    message: Optional[str] = None
    type: Optional[NotificationType] = None
    is_read: Optional[bool] = None
class Notification(NotificationBase):
    id: int
    user_id: int
    is_read: bool
    created_at: datetime
    read_at: Optional[datetime] = None

    class Config:
        from_attributes = True
class NotificationList(BaseModel):
    notifications: List[Notification]
    total: int
    unread_count: int
class MarkAsRead(BaseModel):
    notification_ids: List[int]
================================================================================
FILE: start_backend.sh [UTILITY]
================================================================================

#!/bin/bash

# üöÄ PRACTICE BOOKING SYSTEM - BACKEND IND√çT√ÅS
# Egyszer≈± backend server ind√≠t√°s ellen≈ërz√©sekkel

echo "üöÄ PRACTICE BOOKING SYSTEM - BACKEND STARTUP"
echo "============================================="

# Sz√≠nes output
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

log_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è $1${NC}"
}

# Ellen≈ërz√©sek
echo ""
echo "üîç EL≈êZETES ELLEN≈êRZ√âSEK"
echo "======================="

# 1. Projekt k√∂nyvt√°r ellen≈ërz√©se
if [ ! -f "app/main.py" ]; then
    log_error "Nem vagyunk a practice_booking_system k√∂nyvt√°rban!"
    echo "   Navig√°lj a projekt root k√∂nyvt√°r√°ba √©s futtasd √∫jra."
    exit 1
fi
log_success "Projekt k√∂nyvt√°r OK"

# 2. Python ellen≈ërz√©s
if ! command -v python3 &> /dev/null; then
    log_error "Python3 nincs telep√≠tve!"
    exit 1
fi
log_success "Python3 telep√≠tve: $(python3 --version)"

# 3. Virtual environment ellen≈ërz√©s
if [ ! -d "venv" ]; then
    log_warning "Virtual environment nem tal√°lhat√≥"
    log_info "L√©trehoz√°s: python3 -m venv venv"
    
    read -p "L√©trehozzam most? (y/n): " create_venv
    if [ "$create_venv" = "y" ]; then
        python3 -m venv venv
        log_success "Virtual environment l√©trehozva"
    else
        log_error "Virtual environment sz√ºks√©ges a fut√°shoz"
        exit 1
    fi
fi

# 4. Virtual environment aktiv√°l√°s
if [ -f "venv/bin/activate" ]; then
    source venv/bin/activate
    log_success "Virtual environment aktiv√°lva"
else
    log_error "Virtual environment aktiv√°l√°s sikertelen"
    exit 1
fi

# 5. Dependencies ellen≈ërz√©s
if ! python -c "import fastapi" &> /dev/null; then
    log_warning "Dependencies hi√°nyoznak"
    log_info "Telep√≠t√©s: pip install -r requirements.txt"
    
    read -p "Telep√≠tsem most? (y/n): " install_deps
    if [ "$install_deps" = "y" ]; then
        pip install -r requirements.txt
        log_success "Dependencies telep√≠tve"
    else
        log_error "Dependencies sz√ºks√©gesek a fut√°shoz"
        exit 1
    fi
fi

# 6. Port ellen≈ërz√©s
if lsof -i :8000 &> /dev/null; then
    log_warning "Port 8000 m√°r haszn√°latban"
    log_info "Le√°ll√≠tom a megl√©v≈ë folyamatot..."
    
    PID=$(lsof -ti :8000)
    kill -9 $PID 2>/dev/null
    sleep 2
    
    if lsof -i :8000 &> /dev/null; then
        log_error "Nem siker√ºlt felszabad√≠tani a 8000-es portot"
        exit 1
    fi
    log_success "Port felszabad√≠tva"
fi

# 7. Database ellen≈ërz√©s
log_info "Database kapcsolat tesztel√©se..."
if python -c "
from app.database import engine
try:
    with engine.connect() as conn:
        print('Database connection OK')
except Exception as e:
    print(f'Database error: {e}')
    exit(1)
" 2>/dev/null; then
    log_success "Database kapcsolat OK"
else
    log_error "Database kapcsolat sikertelen"
    log_info "Ellen≈ërizd a PostgreSQL st√°tusz√°t √©s a .env f√°jlt"
    exit 1
fi

# SERVER IND√çT√ÅS
echo ""
echo "üéØ SERVER IND√çT√ÅS"
echo "================"

log_info "Backend server ind√≠t√°sa a http://localhost:8000 c√≠men..."
log_info "API dokument√°ci√≥: http://localhost:8000/docs"
log_info ""
log_warning "A server le√°ll√≠t√°s√°hoz nyomd meg Ctrl+C"
echo ""

# Ind√≠t√°s verbose m√≥ddal
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

# Ha ide eljutunk, a server le√°llt
echo ""
log_info "Backend server le√°llt"
================================================================================
FILE: start_frontend.sh [UTILITY]
================================================================================

#!/bin/bash

# üé® PRACTICE BOOKING SYSTEM - FRONTEND IND√çT√ÅS  
# Egyszer≈± React frontend ind√≠t√°s ellen≈ërz√©sekkel

echo "üé® PRACTICE BOOKING SYSTEM - FRONTEND STARTUP"
echo "============================================="

# Sz√≠nes output
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

log_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è $1${NC}"
}

# Ellen≈ërz√©sek
echo ""
echo "üîç EL≈êZETES ELLEN≈êRZ√âSEK"
echo "======================="

# 1. Projekt k√∂nyvt√°r ellen≈ërz√©se
if [ ! -d "frontend" ]; then
    log_error "Frontend k√∂nyvt√°r nem tal√°lhat√≥!"
    echo "   Futtasd ezt a scriptet a practice_booking_system root k√∂nyvt√°r√°b√≥l."
    exit 1
fi
log_success "Frontend k√∂nyvt√°r OK"

# 2. Node.js ellen≈ërz√©s
if ! command -v node &> /dev/null; then
    log_error "Node.js nincs telep√≠tve!"
    log_info "Telep√≠tsd a Node.js-t: https://nodejs.org"
    exit 1
fi
log_success "Node.js telep√≠tve: $(node --version)"

# 3. npm ellen≈ërz√©s
if ! command -v npm &> /dev/null; then
    log_error "npm nincs telep√≠tve!"
    exit 1
fi
log_success "npm telep√≠tve: $(npm --version)"

# 4. Frontend k√∂nyvt√°rba v√°lt√°s
cd frontend
log_success "Frontend k√∂nyvt√°rba v√°lt√°s"

# 5. package.json ellen≈ërz√©s
if [ ! -f "package.json" ]; then
    log_error "package.json nem tal√°lhat√≥!"
    log_info "Futtasd el≈ëbb a frontend_setup.sh scriptet"
    exit 1
fi
log_success "package.json OK"

# 6. Dependencies ellen≈ërz√©s
if [ ! -d "node_modules" ]; then
    log_warning "node_modules k√∂nyvt√°r hi√°nyzik"
    log_info "Dependencies telep√≠t√©se..."
    
    npm install
    
    if [ $? -eq 0 ]; then
        log_success "Dependencies telep√≠tve"
    else
        log_error "Dependencies telep√≠t√©se sikertelen"
        exit 1
    fi
else
    log_success "node_modules OK"
fi

# 7. Port ellen≈ërz√©s  
if lsof -i :3000 &> /dev/null; then
    log_warning "Port 3000 m√°r haszn√°latban"
    log_info "Le√°ll√≠tom a megl√©v≈ë folyamatot..."
    
    PID=$(lsof -ti :3000)
    kill -9 $PID 2>/dev/null
    sleep 2
    
    if lsof -i :3000 &> /dev/null; then
        log_error "Nem siker√ºlt felszabad√≠tani a 3000-es portot"
        exit 1
    fi
    log_success "Port felszabad√≠tva"
fi

# 8. Backend kapcsolat ellen≈ërz√©s
log_info "Backend el√©rhet≈ës√©g tesztel√©se..."
if curl -s http://localhost:8000/health &> /dev/null; then
    log_success "Backend el√©rhet≈ë a localhost:8000-n"
else
    log_warning "Backend nem el√©rhet≈ë!"
    log_info "Ellen≈ërizd, hogy fut-e a backend server (localhost:8000)"
    log_info "Ha nem fut, ind√≠tsd el k√ºl√∂n termin√°lban: ./start_backend.sh"
    echo ""
    read -p "Folytatod a frontend ind√≠t√°s√°t backend n√©lk√ºl? (y/n): " continue_anyway
    if [ "$continue_anyway" != "y" ]; then
        exit 1
    fi
fi

# 9. React app compilation teszt
log_info "React app szintaxis ellen≈ërz√©s..."
if npm run build --silent &> /dev/null; then
    log_success "React app fordul"
    rm -rf build  # Cleanup
else
    log_error "React app compilation errors"
    log_info "Futtasd: npm run build a r√©szletes hib√°k√©rt"
    exit 1
fi

# FRONTEND IND√çT√ÅS
echo ""
echo "üéØ FRONTEND IND√çT√ÅS"
echo "=================="

log_info "React development server ind√≠t√°sa..."
log_info "Frontend URL: http://localhost:3000"
log_info "Backend proxy: http://localhost:8000"
log_info ""
log_info "üîê TESZT BEJELENTKEZ√âS:"
log_info "Email:    admin@company.com"
log_info "Jelsz√≥:   admin123"
log_info ""
log_warning "A frontend le√°ll√≠t√°s√°hoz nyomd meg Ctrl+C"
echo ""

# React dev server ind√≠t√°s
npm start

# Ha ide eljutunk, a server le√°llt
echo ""
log_info "Frontend server le√°llt"
================================================================================
FILE: pilot_user_setup.sh [UTILITY]
================================================================================

#!/bin/bash

# üë• PRACTICE BOOKING SYSTEM - PILOT USER SETUP
# T√∂bb instructor √©s student account l√©trehoz√°sa pilot programhoz

echo "üë• PRACTICE BOOKING SYSTEM - PILOT USER SETUP"
echo "============================================="
echo "T√∂bb oktat√≥ √©s hallgat√≥ account l√©trehoz√°sa a pilot tesztel√©shez"
echo ""

# Sz√≠nes output
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Environment variables
ADMIN_EMAIL="${ADMIN_EMAIL:-admin@company.com}"
ADMIN_PASSWORD="${ADMIN_PASSWORD:-admin123}"

log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

log_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è $1${NC}"
}

log_user() {
    echo -e "${PURPLE}üë§ $1${NC}"
}

# Seg√©df√ºggv√©nyek
api_call() {
    local method=$1
    local endpoint=$2
    local token=$3
    local data=$4
    
    if [ -n "$data" ]; then
        curl -s -X "$method" \
             -H "Content-Type: application/json" \
             -H "Authorization: Bearer $token" \
             -d "$data" \
             "http://localhost:8000$endpoint"
    else
        curl -s -X "$method" \
             -H "Authorization: Bearer $token" \
             "http://localhost:8000$endpoint"
    fi
}

# Ellen≈ërz√©sek
echo "üîç EL≈êZETES ELLEN≈êRZ√âSEK"
echo "======================"

# Backend fut√°s ellen≈ërz√©s
if ! curl -s http://localhost:8000/health &> /dev/null; then
    log_error "Backend nem fut a localhost:8000-n!"
    log_info "Ind√≠tsd el el≈ëbb: ./start_backend.sh"
    exit 1
fi
log_success "Backend fut"

# Admin bejelentkez√©s
log_info "Admin bejelentkez√©s..."
ADMIN_LOGIN=$(api_call "POST" "/api/v1/auth/login" "" '{"email":"'$ADMIN_EMAIL'","password":"'$ADMIN_PASSWORD'"}')
ADMIN_TOKEN=$(echo $ADMIN_LOGIN | jq -r '.access_token' 2>/dev/null)

if [ -z "$ADMIN_TOKEN" ] || [ "$ADMIN_TOKEN" = "null" ]; then
    log_error "Admin bejelentkez√©s sikertelen!"
    echo "Response: $ADMIN_LOGIN"
    exit 1
fi
log_success "Admin bejelentkez√©s sikeres"

# User sz√°mok meghat√°roz√°sa
echo ""
echo "üìä PILOT PROGRAM M√âRET BE√ÅLL√çT√ÅSA"
echo "================================"

echo "Aj√°nlott pilot m√©ret:"
echo "  - 3-4 oktat√≥ (k√ºl√∂nb√∂z≈ë szakter√ºletek)"
echo "  - 12-20 hallgat√≥ (k√ºl√∂nb√∂z≈ë csoportokb√≥l)"
echo "  - 1-2 admin (monitoring + support)"
echo ""

read -p "H√°ny oktat√≥t hozzon l√©tre? (alap√©rtelmezett: 4): " INSTRUCTOR_COUNT
INSTRUCTOR_COUNT=${INSTRUCTOR_COUNT:-4}

read -p "H√°ny hallgat√≥t hozzon l√©tre? (alap√©rtelmezett: 15): " STUDENT_COUNT  
STUDENT_COUNT=${STUDENT_COUNT:-15}

echo ""
log_info "L√©trehozand√≥ accountok: $INSTRUCTOR_COUNT oktat√≥ + $STUDENT_COUNT hallgat√≥"

# Meger≈ës√≠t√©s
read -p "Folytatod a l√©trehoz√°st? (y/n): " confirm
if [ "$confirm" != "y" ]; then
    log_info "Felhaszn√°l√≥ megszak√≠totta"
    exit 0
fi

# Oktat√≥ accountok l√©trehoz√°sa
echo ""
echo "üë®‚Äçüè´ OKTAT√ì ACCOUNTOK L√âTREHOZ√ÅSA"
echo "==============================="

INSTRUCTOR_NAMES=(
    "Dr. Nagy P√©ter"
    "Prof. Kov√°cs Anna" 
    "Dr. Szab√≥ M√°rton"
    "Dr. T√≥th Eszter"
    "Dr. Kiss J√°nos"
    "Prof. Varga Kl√°ra"
)

INSTRUCTOR_DOMAINS=(
    "matematika"
    "fizika" 
    "informatika"
    "kemia"
    "biologia"
    "english"
)

INSTRUCTOR_SUCCESS=0
INSTRUCTOR_FAILED=0

for ((i=1; i<=INSTRUCTOR_COUNT; i++)); do
    # Random n√©v √©s domain v√°laszt√°s
    name_idx=$(($i % ${#INSTRUCTOR_NAMES[@]}))
    domain_idx=$(($i % ${#INSTRUCTOR_DOMAINS[@]}))
    
    name="${INSTRUCTOR_NAMES[$name_idx]}"
    domain="${INSTRUCTOR_DOMAINS[$domain_idx]}"
    email="${domain}.oktato${i}@pilot.test"
    
    log_info "Oktat√≥ l√©trehoz√°sa: $name ($email)"
    
    USER_DATA="{
        \"name\": \"$name\",
        \"email\": \"$email\",
        \"password\": \"oktato123\",
        \"role\": \"instructor\"
    }"
    
    RESULT=$(api_call "POST" "/api/v1/users/" "$ADMIN_TOKEN" "$USER_DATA")
    USER_ID=$(echo $RESULT | jq -r '.id' 2>/dev/null)
    
    if [ -n "$USER_ID" ] && [ "$USER_ID" != "null" ]; then
        log_success "Oktat√≥ l√©trehozva: $name (ID: $USER_ID)"
        log_user "   üìß Email: $email | üîë Jelsz√≥: oktato123"
        INSTRUCTOR_SUCCESS=$((INSTRUCTOR_SUCCESS + 1))
    else
        log_error "Oktat√≥ l√©trehoz√°s sikertelen: $name"
        INSTRUCTOR_FAILED=$((INSTRUCTOR_FAILED + 1))
    fi
    
    # R√∂vid v√°rakoz√°s az API rate limiting elker√ºl√©s√©re  
    sleep 0.2
done

# Hallgat√≥ accountok l√©trehoz√°sa
echo ""
echo "üéì HALLGAT√ì ACCOUNTOK L√âTREHOZ√ÅSA"
echo "=============================="

STUDENT_FIRST_NAMES=(
    "√Åron" "Bence" "Csaba" "D√°niel" "Erik" "Ferenc"
    "G√°bor" "Henrik" "Istv√°n" "J√°nos" "Krist√≥f" "L√°szl√≥"
    "Anna" "Beatrix" "Csilla" "Dorina" "Eszter" "Fanni"
    "Gr√©ta" "Hanna" "Ildik√≥" "Judit" "Kata" "Lilla"
)

STUDENT_LAST_NAMES=(
    "Nagy" "Kov√°cs" "T√≥th" "Szab√≥" "Horv√°th" "Varga"
    "Kiss" "Moln√°r" "N√©meth" "Farkas" "Balogh" "Papp"
    "Tak√°cs" "Juh√°sz" "Lakatos" "M√©sz√°ros" "Ol√°h" "Simon"
)

STUDENT_SUCCESS=0
STUDENT_FAILED=0

for ((i=1; i<=STUDENT_COUNT; i++)); do
    # Random n√©v gener√°l√°s
    first_idx=$(($RANDOM % ${#STUDENT_FIRST_NAMES[@]}))
    last_idx=$(($RANDOM % ${#STUDENT_LAST_NAMES[@]}))
    
    first_name="${STUDENT_FIRST_NAMES[$first_idx]}"
    last_name="${STUDENT_LAST_NAMES[$last_idx]}"
    full_name="$first_name $last_name"
    
    # Email gener√°l√°s
    email_base=$(echo "$first_name$last_name" | tr '[:upper:]' '[:lower:]' | sed 's/[√°√©√≠√≥√∂≈ë√º≈±]/a/g')
    email="${email_base}${i}@pilot.test"
    
    log_info "Hallgat√≥ l√©trehoz√°sa: $full_name ($email)"
    
    USER_DATA="{
        \"name\": \"$full_name\",
        \"email\": \"$email\",
        \"password\": \"hallgato123\",
        \"role\": \"student\"
    }"
    
    RESULT=$(api_call "POST" "/api/v1/users/" "$ADMIN_TOKEN" "$USER_DATA")
    USER_ID=$(echo $RESULT | jq -r '.id' 2>/dev/null)
    
    if [ -n "$USER_ID" ] && [ "$USER_ID" != "null" ]; then
        log_success "Hallgat√≥ l√©trehozva: $full_name (ID: $USER_ID)"
        if [ $((i % 5)) -eq 0 ]; then  # Minden 5. hallgat√≥n√°l mutassa az adatokat
            log_user "   üìß Email: $email | üîë Jelsz√≥: hallgato123"
        fi
        STUDENT_SUCCESS=$((STUDENT_SUCCESS + 1))
    else
        log_error "Hallgat√≥ l√©trehoz√°s sikertelen: $full_name"
        STUDENT_FAILED=$((STUDENT_FAILED + 1))
    fi
    
    # Progress indicator
    if [ $((i % 3)) -eq 0 ]; then
        echo -n "."
    fi
    
    # R√∂vid v√°rakoz√°s
    sleep 0.1
done

echo ""

# Database valid√°ci√≥
echo ""
echo "üîç ADATB√ÅZIS VALID√ÅCI√ì"  
echo "===================="

log_info "User sz√°mok ellen≈ërz√©se az adatb√°zisban..."

# Python script a sz√°mok ellen≈ërz√©s√©re
cat > temp_user_count.py << EOF
from app.database import SessionLocal
from app.models.user import User, UserRole

db = SessionLocal()
try:
    total = db.query(User).filter(User.is_active == True).count()
    admins = db.query(User).filter(User.role == UserRole.ADMIN, User.is_active == True).count()
    instructors = db.query(User).filter(User.role == UserRole.INSTRUCTOR, User.is_active == True).count()
    students = db.query(User).filter(User.role == UserRole.STUDENT, User.is_active == True).count()
    
    print(f"TOTAL:{total}")
    print(f"ADMIN:{admins}")
    print(f"INSTRUCTOR:{instructors}")
    print(f"STUDENT:{students}")
finally:
    db.close()
EOF

DB_RESULT=$(python temp_user_count.py 2>/dev/null)
rm temp_user_count.py

if [ -n "$DB_RESULT" ]; then
    TOTAL_DB=$(echo "$DB_RESULT" | grep "TOTAL:" | cut -d: -f2)
    ADMIN_DB=$(echo "$DB_RESULT" | grep "ADMIN:" | cut -d: -f2)
    INSTRUCTOR_DB=$(echo "$DB_RESULT" | grep "INSTRUCTOR:" | cut -d: -f2)
    STUDENT_DB=$(echo "$DB_RESULT" | grep "STUDENT:" | cut -d: -f2)
    
    log_success "Adatb√°zis user sz√°mok:"
    echo "   üë®‚Äçüíº Admin: $ADMIN_DB"
    echo "   üë®‚Äçüè´ Oktat√≥: $INSTRUCTOR_DB"  
    echo "   üéì Hallgat√≥: $STUDENT_DB"
    echo "   üìä √ñsszesen: $TOTAL_DB akt√≠v user"
else
    log_warning "Adatb√°zis ellen≈ërz√©s sikertelen"
fi

# √ñsszefoglal√≥ jelent√©s
echo ""
echo "üìã PILOT SETUP √ñSSZEFOGLAL√ì"
echo "=========================="

log_success "Oktat√≥ accountok: $INSTRUCTOR_SUCCESS/$INSTRUCTOR_COUNT sikeres"
log_success "Hallgat√≥ accountok: $STUDENT_SUCCESS/$STUDENT_COUNT sikeres"

if [ $INSTRUCTOR_FAILED -gt 0 ] || [ $STUDENT_FAILED -gt 0 ]; then
    log_warning "Sikertelen l√©trehoz√°sok: $((INSTRUCTOR_FAILED + STUDENT_FAILED))"
fi

echo ""
echo "üîê BEJELENTKEZ√âSI ADATOK"
echo "======================="
echo ""
echo "üë®‚Äçüíº ADMIN:"
echo "   üìß $ADMIN_EMAIL | üîë $ADMIN_PASSWORD"
echo ""
echo "üë®‚Äçüè´ OKTAT√ìK (p√©lda):"
echo "   üìß matematika.oktato1@pilot.test | üîë oktato123"
echo "   üìß fizika.oktato2@pilot.test | üîë oktato123"
echo "   üìß informatika.oktato3@pilot.test | üîë oktato123"
echo ""
echo "üéì HALLGAT√ìK (p√©lda):"  
echo "   üìß √°ronnag1@pilot.test | üîë hallgato123"
echo "   üìß beatrixkov√°cs2@pilot.test | üîë hallgato123"
echo "   üìß csabat√≥th3@pilot.test | üîë hallgato123"
echo ""

# Pilot tesztel√©si instrukci√≥k
echo "üéØ PILOT TESZTEL√âSI INSTRUKCI√ìK"
echo "=============================="
echo ""
echo "1. üì± ADMIN FELADATOK:"
echo "   - Szemeszter l√©trehoz√°s (2024 ≈ëszi szemeszter)"
echo "   - Csoportok kialak√≠t√°sa (4-5 hallgat√≥/csoport)"
echo "   - Oktat√≥k hozz√°rendel√©se csoportokhoz"
echo ""
echo "2. üë®‚Äçüè´ OKTAT√ì FELADATOK:"  
echo "   - Practice session-√∂k l√©trehoz√°sa"
echo "   - Id≈ëpontok √©s helysz√≠nek be√°ll√≠t√°sa"
echo "   - Kapacit√°sok meghat√°roz√°sa"
echo ""
echo "3. üéì HALLGAT√ì FELADATOK:"
echo "   - Regisztr√°ci√≥ gyakorlatokra"
echo "   - Lemond√°sok tesztel√©se"
echo "   - Feedback k√ºld√©s"
echo ""

# Login URL inform√°ci√≥
echo "üåê TESZTEL√âSI URL:"
echo "   http://localhost:3000"
echo ""

log_success "PILOT USER SETUP BEFEJEZVE!"
log_info "A pilot program most $((INSTRUCTOR_SUCCESS + STUDENT_SUCCESS + 1)) akt√≠v user-rel tesztelhet≈ë"
================================================================================
FILE: README.md [DOCS]
================================================================================

# üèà Practice Booking System

**Automated Cross-Platform Practice Booking System with Comprehensive CI/CD Testing**

[![CI/CD Pipeline](https://github.com/footballinvestment/practice-booking-system/actions/workflows/cross-platform-testing.yml/badge.svg)](https://github.com/footballinvestment/practice-booking-system/actions/workflows/cross-platform-testing.yml)
[![iOS Safari Compatible](https://img.shields.io/badge/iOS%20Safari-Compatible-brightgreen.svg)](https://github.com/footballinvestment/practice-booking-system)
[![Cross Browser](https://img.shields.io/badge/Cross%20Browser-Chrome%20|%20Firefox%20|%20Safari%20|%20Edge-blue.svg)](https://github.com/footballinvestment/practice-booking-system)

## üöÄ **Quick Start**

### Prerequisites
- Python 3.11+
- Node.js 18+
- PostgreSQL 14+
- Git

### Installation
```bash
git clone https://github.com/footballinvestment/practice-booking-system.git
cd practice-booking-system

# Backend setup
pip install -r requirements.txt
python scripts/fresh_database_reset.py

# Frontend setup
cd frontend && npm install && cd ..

# Start both servers
./start_both.sh
```

**URLs:**
- Frontend: http://localhost:3000
- Backend API: http://localhost:8000
- API Docs: http://localhost:8000/docs

---

## üåê **Cross-Platform Testing**

### **Automated CI/CD Pipeline**
Every push triggers comprehensive testing across:

- **‚úÖ Backend**: FastAPI + PostgreSQL + pytest
- **‚úÖ Frontend**: React + Jest + build verification  
- **‚úÖ Cross-Browser**: Chrome, Firefox, Safari, Edge
- **‚úÖ iOS Safari**: Real device testing (iPhone, iPad)
- **‚úÖ Performance**: Lighthouse CI (>80 score target)
- **‚úÖ Security**: OWASP + CodeQL scanning

### **Test Accounts** 
```
Fresh Students (for onboarding testing):
- alex.newcomer@student.com / student123
- emma.fresh@student.com / student123
- mike.starter@student.com / student123

Instructor:
- sarah.johnson@instructor.com / instructor123

Admin:
- admin@devstudio.com / admin123
```

## üèóÔ∏è **Architecture**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   React SPA     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   FastAPI       ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  PostgreSQL     ‚îÇ
‚îÇ   (Port 3000)   ‚îÇ    ‚îÇ   (Port 8000)   ‚îÇ    ‚îÇ   Database      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Playwright E2E  ‚îÇ    ‚îÇ GitHub Actions  ‚îÇ    ‚îÇ BrowserStack    ‚îÇ
‚îÇ    Testing      ‚îÇ    ‚îÇ    CI/CD        ‚îÇ    ‚îÇ  iOS Safari     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üì± **Supported Platforms**

| Platform | Support | Tested |
|----------|---------|--------|
| **Chrome Desktop** | ‚úÖ Full | Automated |
| **Firefox Desktop** | ‚úÖ Full | Automated |
| **Safari Desktop** | ‚úÖ Full | Automated |
| **Edge Desktop** | ‚úÖ Full | Automated |
| **iOS Safari** | ‚úÖ Full | BrowserStack |
| **iPad Safari** | ‚úÖ Full | BrowserStack |
| **Chrome Mobile** | ‚úÖ Full | Emulated |

## üß™ **Testing**

### **Local Testing**
```bash
# Backend tests
pytest app/tests/ -v

# Frontend tests
cd frontend && npm test

# E2E tests (requires Playwright)
cd e2e-tests && npm install && npx playwright test
```

### **CI/CD Pipeline**
Tests automatically run on:
- Push to main/develop
- Pull requests
- Manual workflow dispatch

**Pipeline Duration:** 35-45 minutes (parallel execution)

## üìä **Features**

### **Student Features**
- üÜï **Fresh Student Onboarding** (JSON serialization fix implemented)
- üìÖ **Session Booking System** (capacity management + waitlist)
- üèÉ **Project Enrollment** (with prerequisites)
- üì± **Mobile-First Design** (iOS Safari optimized)
- üéØ **Achievement System** (gamification)

### **Instructor Features**
- üìã **Session Management** 
- üë• **Student Progress Tracking**
- üìä **Analytics Dashboard**
- üí¨ **Messaging System**

### **Admin Features**
- üîß **System Configuration**
- üìà **Reporting & Analytics**
- üë§ **User Management**
- üîí **Security Monitoring**

## ‚ö° Quick Start

### Prerequisites

- Python 3.8+
- PostgreSQL 12+
- pip (Python package manager)

### Installation

1. **Clone the repository**
   ```bash
   cd practice_booking_system
   ```

2. **Create virtual environment**
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\\Scripts\\activate
   ```

3. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   ```

4. **Configure environment**
   ```bash
   cp .env.example .env
   # Edit .env with your database credentials and settings
   ```

5. **Initialize database**
   ```bash
   python init_db.py
   ```

6. **Start the application**
   ```bash
   uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
   ```

### üéØ Default Admin Access

After initialization, you can log in with:
- **Email**: Use the admin account created during initialization
- **Password**: Check your `.env` file for the configured admin password

**‚ö†Ô∏è Important**: Always use secure credentials in production!

## üîß Configuration

### Environment Variables

Configure the following variables in your `.env` file:

```bash
# Database
DATABASE_URL=postgresql://username:password@localhost:5432/practice_booking_system

# JWT Security
SECRET_KEY=your-super-secret-jwt-key-change-this
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# Application
APP_NAME="Practice Booking System"
DEBUG=True
API_V1_STR="/api/v1"

# Initial Admin (configure your admin credentials)
ADMIN_EMAIL=your-admin-email@company.com
ADMIN_PASSWORD=your-secure-admin-password
ADMIN_NAME=System Administrator

# Business Rules
MAX_BOOKINGS_PER_SEMESTER=10
BOOKING_DEADLINE_HOURS=24
```

### Database Setup

1. **Create PostgreSQL database**
   ```sql
   CREATE DATABASE practice_booking_system;
   CREATE USER your_user WITH PASSWORD 'your_password';
   GRANT ALL PRIVILEGES ON DATABASE practice_booking_system TO your_user;
   ```

2. **Run migrations** (if using Alembic)
   ```bash
   alembic upgrade head
   ```

## üìö API Documentation

### Interactive Documentation

Once the application is running, access the interactive API documentation:

- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

### Authentication

The API uses JWT Bearer token authentication. Include the token in your requests:

```bash
curl -H "Authorization: Bearer YOUR_JWT_TOKEN" http://localhost:8000/api/v1/users/me
```

### API Endpoints Overview

#### üîê Authentication
```
POST   /api/v1/auth/login              # Login (get JWT tokens)
POST   /api/v1/auth/refresh            # Refresh access token
POST   /api/v1/auth/logout             # Logout
GET    /api/v1/auth/me                 # Get current user info
POST   /api/v1/auth/change-password    # Change password
```

#### üë• User Management (Admin Only)
```
POST   /api/v1/users/                  # Create user
GET    /api/v1/users/                  # List users (with pagination)
GET    /api/v1/users/{id}              # Get user details
PATCH  /api/v1/users/{id}              # Update user
DELETE /api/v1/users/{id}              # Deactivate user
POST   /api/v1/users/{id}/reset-password # Reset user password
PATCH  /api/v1/users/me                # Update own profile
```

#### üìÖ Semester Management
```
POST   /api/v1/semesters/              # Create semester (Admin)
GET    /api/v1/semesters/              # List semesters
GET    /api/v1/semesters/{id}          # Get semester details
PATCH  /api/v1/semesters/{id}          # Update semester (Admin)
DELETE /api/v1/semesters/{id}          # Delete semester (Admin)
```

#### üë• Group Management
```
POST   /api/v1/groups/                 # Create group (Admin)
GET    /api/v1/groups/                 # List groups
GET    /api/v1/groups/{id}             # Get group details
PATCH  /api/v1/groups/{id}             # Update group (Admin)
DELETE /api/v1/groups/{id}             # Delete group (Admin)
POST   /api/v1/groups/{id}/users       # Add user to group (Admin)
DELETE /api/v1/groups/{id}/users/{user_id} # Remove user from group (Admin)
```

#### üè´ Session Management
```
POST   /api/v1/sessions/               # Create session (Admin/Instructor)
GET    /api/v1/sessions/               # List sessions (with filters)
GET    /api/v1/sessions/{id}           # Get session details
PATCH  /api/v1/sessions/{id}           # Update session (Admin/Instructor)
DELETE /api/v1/sessions/{id}           # Delete session (Admin/Instructor)
```

#### üìù Booking Management
```
POST   /api/v1/bookings/               # Create booking
GET    /api/v1/bookings/me             # Get own bookings
DELETE /api/v1/bookings/{id}           # Cancel own booking
GET    /api/v1/sessions/{id}/bookings  # Get session bookings (Admin/Instructor)
POST   /api/v1/bookings/{id}/confirm   # Confirm booking (Admin)
POST   /api/v1/bookings/{id}/cancel    # Cancel booking (Admin)
```

#### ‚úÖ Attendance Tracking
```
POST   /api/v1/attendance/             # Create attendance record (Admin/Instructor)
GET    /api/v1/attendance/             # List attendance for session
POST   /api/v1/attendance/{booking_id}/checkin # Check in to session
PATCH  /api/v1/attendance/{id}         # Update attendance (Admin/Instructor)
```

#### ‚≠ê Feedback System
```
POST   /api/v1/feedback/               # Create feedback
GET    /api/v1/feedback/me             # Get own feedback
PATCH  /api/v1/feedback/{id}           # Update own feedback
DELETE /api/v1/feedback/{id}           # Delete own feedback
GET    /api/v1/sessions/{id}/feedback  # Get session feedback (Admin/Instructor)
GET    /api/v1/sessions/{id}/feedback/summary # Get feedback summary
```

#### üìä Reporting
```
GET    /api/v1/reports/semester/{id}   # Semester report (Admin)
GET    /api/v1/reports/user/{id}       # User participation report (Admin)
GET    /api/v1/reports/export/sessions # Export sessions CSV (Admin)
```

## üë• User Roles & Permissions

### üîí Permission Matrix

| Feature | Admin | Instructor | Student |
|---------|-------|------------|---------|
| User Management | ‚úÖ Full | ‚ùå | ‚ùå |
| Semester Management | ‚úÖ Full | ‚ùå | ‚ùå |
| Group Management | ‚úÖ Full | ‚ùå | ‚ùå |
| Session Management | ‚úÖ Full | ‚úÖ Create/Edit | ‚ùå |
| Booking Management | ‚úÖ Full | ‚úÖ View/Manage | ‚úÖ Own only |
| Attendance Tracking | ‚úÖ Full | ‚úÖ Sessions | ‚úÖ Check-in only |
| Feedback Management | ‚úÖ View All | ‚úÖ View Sessions | ‚úÖ Own only |
| Reporting | ‚úÖ Full | ‚ùå | ‚ùå |

### üë§ User Role Descriptions

#### **Admin** 
- Complete system access
- User account management
- System configuration
- All reporting capabilities
- Data export functions

#### **Instructor**
- Session creation and management
- Booking oversight for their sessions
- Attendance tracking capabilities
- Feedback viewing for their sessions
- Limited to their assigned sessions

#### **Student**
- Session browsing and booking
- Attendance check-in
- Feedback submission
- Profile management
- Limited to their own data

## üß™ Testing

### Running Tests

```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=app

# Run specific test file
pytest app/tests/test_auth.py

# Run with verbose output
pytest -v
```

### Test Coverage

The project includes comprehensive testing:

- **Unit Tests**: Core functionality (auth, permissions, security)
- **Integration Tests**: API endpoints with database integration
- **End-to-End Tests**: Complete workflows across all user roles
- **Security Tests**: Permission boundaries and access control

**Test Results**: See `test_results.md` for detailed test documentation with 95+ test cases and 100% pass rate.

## üöÄ Production Deployment

### Docker Deployment (Recommended)

1. **Create Dockerfile**
   ```dockerfile
   FROM python:3.9-slim
   
   WORKDIR /app
   COPY requirements.txt .
   RUN pip install -r requirements.txt
   
   COPY . .
   
   CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
   ```

2. **Create docker-compose.yml**
   ```yaml
   version: '3.8'
   services:
     api:
       build: .
       ports:
         - "8000:8000"
       environment:
         - DATABASE_URL=postgresql://user:password@db:5432/practice_booking_system
       depends_on:
         - db
     
     db:
       image: postgres:13
       environment:
         - POSTGRES_DB=practice_booking_system
         - POSTGRES_USER=user
         - POSTGRES_PASSWORD=password
       volumes:
         - postgres_data:/var/lib/postgresql/data
   
   volumes:
     postgres_data:
   ```

3. **Deploy**
   ```bash
   docker-compose up -d
   ```

### Security Checklist for Production

- [ ] Change default admin credentials
- [ ] Use strong SECRET_KEY (generate with `openssl rand -hex 32`)
- [ ] Set DEBUG=False
- [ ] Configure HTTPS/TLS
- [ ] Set up proper CORS origins
- [ ] Configure database connection pooling
- [ ] Set up monitoring and logging
- [ ] Configure backup strategy
- [ ] Set up rate limiting

### Environment Variables for Production

```bash
# Security
SECRET_KEY=your-production-secret-key-32-characters-minimum
DEBUG=False

# Database
DATABASE_URL=postgresql://user:password@host:5432/database

# CORS (restrict to your frontend domain)
CORS_ORIGINS=["https://yourdomain.com"]
```

## üìä Monitoring & Logging

### Health Checks

The API provides health check endpoints:

```bash
GET /health          # Basic health check
GET /              # API information
```

### Logging

Configure logging in production:

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("app.log"),
        logging.StreamHandler()
    ]
)
```

## üîß Troubleshooting

### Common Issues

1. **Database Connection Failed**
   ```bash
   # Check PostgreSQL service
   sudo systemctl status postgresql
   
   # Verify connection string
   psql "postgresql://user:password@localhost:5432/database"
   ```

2. **JWT Token Issues**
   ```bash
   # Regenerate secret key
   python -c "import secrets; print(secrets.token_urlsafe(32))"
   ```

3. **Permission Denied Errors**
   ```bash
   # Check user roles in database
   psql -d practice_booking_system -c "SELECT id, email, role FROM users;"
   ```

4. **Migration Issues**
   ```bash
   # Reset migrations (development only!)
   alembic downgrade base
   alembic upgrade head
   ```

### Debug Mode

Enable debug mode for development:

```bash
DEBUG=True uvicorn app.main:app --reload --log-level debug
```

## ü§ù Contributing

### Development Setup

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass
6. Submit a pull request

### Code Standards

- Follow PEP 8 for Python code style
- Add type hints for all functions
- Write docstrings for public methods
- Maintain test coverage above 90%
- Use meaningful commit messages

## üìù License

This project is proprietary software for internal company use.

## üìû Support

For technical support or questions:

- **Documentation**: Check this README and `test_results.md`
- **API Documentation**: http://localhost:8000/docs
- **Issues**: Create an issue in the project repository

## üîÑ Changelog

### v1.0.0 (2024-08-19)

- ‚úÖ Complete FastAPI backend implementation
- ‚úÖ JWT authentication with role-based access control
- ‚úÖ Comprehensive user management system
- ‚úÖ Practice booking system with waitlists
- ‚úÖ Attendance tracking functionality
- ‚úÖ Feedback collection system
- ‚úÖ Comprehensive reporting capabilities
- ‚úÖ 95+ test cases with 100% pass rate
- ‚úÖ Production-ready security features
- ‚úÖ Complete API documentation

---

**üéØ Production Status**: ‚úÖ **READY FOR DEPLOYMENT**

This system has been thoroughly tested and is ready for production use with proper security measures and comprehensive functionality as specified in the project requirements.
================================================================================
üìä OPTIMALIZ√ÅL√ÅSI STATISZTIK√ÅK
================================================================================

üìÅ Befoglalt f√°jlok: 16
üóëÔ∏è Kihagyott f√°jlok: 0  
üì¶ V√©gs≈ë m√©ret: 104K
üéØ Optimaliz√°l√°si ar√°ny: 0%
üíæ M√©retcs√∂kkent√©s: ~60-80% az eredeti 4.7MB-hoz k√©pest

‚ö° OPTIMALIZ√ÅL√ÅSI TECHNIK√ÅK:
- ‚úÇÔ∏è Python kommentek √©s docstring-ek elt√°vol√≠tva
- ‚úÇÔ∏è JavaScript/TypeScript kommentek elt√°vol√≠tva  
- üóúÔ∏è JSON f√°jlok minifik√°lva
- üì¶ Csak l√©nyegi f√°jlok befoglalva
- üö´ SQL dump-ok, test f√°jlok, node_modules kiz√°rva

üéØ Ez az optimaliz√°lt verzi√≥ csak a m≈±k√∂d√©shez kritikus k√≥dokat tartalmazza,
   jelent≈ësen cs√∂kkentett f√°jlm√©rettel a gyorsabb Claude AI feldolgoz√°shoz.

